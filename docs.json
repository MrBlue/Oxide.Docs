{
  "Hooks": [
    {
      "Type": 0,
      "Name": "OnTick",
      "HookName": "OnTick",
      "HookParameters": {},
      "ReturnBehavior": 0,
      "TargetType": "ServerMgr",
      "Category": "Server",
      "MethodData": {
        "MethodName": "DoTick",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "private void DoTick()\r\n{\r\n\tInterface.CallHook(\"OnTick\");\r\n\tFacepunch.RCon.Update();\r\n\tCompanionServer.Server.Update();\r\n\tfor (int i = 0; i < Network.Net.sv.connections.Count; i++)\r\n\t{\r\n\t\tNetwork.Connection connection = Network.Net.sv.connections[i];\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerDisconnected",
      "HookName": "OnPlayerDisconnected",
      "HookParameters": {
        "basePlayer": "BasePlayer",
        "strReason": "string"
      },
      "ReturnBehavior": 0,
      "TargetType": "ServerMgr",
      "Category": "Player",
      "MethodData": {
        "MethodName": "OnDisconnected",
        "ReturnType": "void",
        "Arguments": {
          "strReason": "string",
          "connection": "Network.Connection"
        }
      },
      "CodeAfterInjection": "...\r\n\tPlatformService.Instance.EndPlayerSession(connection.userid);\r\n\tglobal::EACServer.OnLeaveGame(connection);\r\n\tglobal::BasePlayer basePlayer = connection.player as global::BasePlayer;\r\n\tif (basePlayer)\r\n\t{\r\n\t\tInterface.CallHook(\"OnPlayerDisconnected\", basePlayer, strReason);\r\n\t\tbasePlayer.OnDisconnected();\r\n\t}\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemRemovedFromContainer",
      "HookName": "OnItemRemovedFromContainer",
      "HookParameters": {
        "instance": "ItemContainer",
        "item": "Item"
      },
      "ReturnBehavior": 0,
      "TargetType": "ItemContainer",
      "Category": "Item",
      "MethodData": {
        "MethodName": "Remove",
        "ReturnType": "bool",
        "Arguments": {
          "item": "Item"
        }
      },
      "CodeAfterInjection": "...\r\n\tthis.MarkDirty();\r\n\tif (this.onItemAddedRemoved != null)\r\n\t{\r\n\t\tthis.onItemAddedRemoved(item, false);\r\n\t}\r\n\tInterface.CallHook(\"OnItemRemovedFromContainer\", this, item);\r\n\treturn true;\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemAddedToContainer",
      "HookName": "OnItemAddedToContainer",
      "HookParameters": {
        "instance": "ItemContainer",
        "item": "Item"
      },
      "ReturnBehavior": 0,
      "TargetType": "ItemContainer",
      "Category": "Item",
      "MethodData": {
        "MethodName": "Insert",
        "ReturnType": "bool",
        "Arguments": {
          "item": "Item"
        }
      },
      "CodeAfterInjection": "...\r\n\tthis.MarkDirty();\r\n\tif (this.onItemAddedRemoved != null)\r\n\t{\r\n\t\tthis.onItemAddedRemoved(item, true);\r\n\t}\r\n\tInterface.CallHook(\"OnItemAddedToContainer\", this, item);\r\n\treturn true;\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntitySpawned",
      "HookName": "OnEntitySpawned",
      "HookDescription": "Called after any networked entity has spawned",
      "HookParameters": {
        "instance": "BaseNetworkable"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseNetworkable",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "Spawn",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tthis.InitShared();\r\n\tthis.ServerInit();\r\n\tthis.PostInitShared();\r\n\tthis.UpdateNetworkGroup();\r\n\tthis.isSpawned = true;\r\n\tInterface.CallHook(\"OnEntitySpawned\", this);\r\n\tthis.SendNetworkUpdateImmediate(true);\r\n\tif (Rust.Application.isLoading && !Rust.Application.isLoadingSave)\r\n\t{\r\n\t\tbase.gameObject.SendOnSendNetworkUpdate(this as global::BaseEntity);\r\n\t}\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanUseLockedEntity [CodeLock, open]",
      "HookName": "CanUseLockedEntity",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "CodeLock"
      },
      "ReturnBehavior": 1,
      "TargetType": "CodeLock",
      "Category": "Player",
      "MethodData": {
        "MethodName": "OnTryToOpen",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public override bool OnTryToOpen(global::BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanUseLockedEntity\", player, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif (!base.IsLocked())\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanUseLockedEntity [CodeLock, close]",
      "HookName": "CanUseLockedEntity",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "CodeLock"
      },
      "ReturnBehavior": 1,
      "TargetType": "CodeLock",
      "Category": "Player",
      "MethodData": {
        "MethodName": "OnTryToClose",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public override bool OnTryToClose(global::BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanUseLockedEntity\", player, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif (!base.IsLocked())\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanUseLockedEntity [KeyLock, close]",
      "HookName": "CanUseLockedEntity",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "KeyLock"
      },
      "ReturnBehavior": 1,
      "TargetType": "KeyLock",
      "Category": "Player",
      "MethodData": {
        "MethodName": "OnTryToClose",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public override bool OnTryToClose(global::BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanUseLockedEntity\", player, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn this.HasLockPermission(player) || !base.IsLocked();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanUseLockedEntity [KeyLock, open]",
      "HookName": "CanUseLockedEntity",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "KeyLock"
      },
      "ReturnBehavior": 1,
      "TargetType": "KeyLock",
      "Category": "Player",
      "MethodData": {
        "MethodName": "OnTryToOpen",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public override bool OnTryToOpen(global::BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanUseLockedEntity\", player, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn this.HasLockPermission(player) || !base.IsLocked();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemCraft",
      "HookName": "OnItemCraft",
      "HookParameters": {
        "itemCraftTask": "ItemCraftTask",
        "owner": "BasePlayer",
        "fromTempBlueprint": "Item"
      },
      "ReturnBehavior": 1,
      "TargetType": "ItemCrafter",
      "Category": "Item",
      "MethodData": {
        "MethodName": "CraftItem",
        "ReturnType": "bool",
        "Arguments": {
          "bp": "ItemBlueprint",
          "owner": "BasePlayer",
          "instanceData": "ProtoBuf.Item/InstanceData",
          "amount": "int",
          "skinID": "int",
          "fromTempBlueprint": "Item",
          "free": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\tfromTempBlueprint.RemoveFromContainer();\r\n\t\titemCraftTask.takenItems.Add(fromTempBlueprint);\r\n\t\titemCraftTask.conditionScale = 0.5f;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"OnItemCraft\", itemCraftTask, owner, fromTempBlueprint);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\tif (fromTempBlueprint != null && itemCraftTask.instanceData != null)\r\n\t\t{\r\n\t\t\tfromTempBlueprint.instanceData = itemCraftTask.instanceData;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnLootEntity",
      "HookName": "OnLootEntity",
      "HookParameters": {
        "instance": "PlayerLoot",
        "targetEntity": "BaseEntity"
      },
      "ReturnBehavior": 0,
      "TargetType": "PlayerLoot",
      "Category": "Player",
      "MethodData": {
        "MethodName": "StartLootingEntity",
        "ReturnType": "bool",
        "Arguments": {
          "targetEntity": "BaseEntity",
          "doPositionChecks": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tAssert.IsTrue(targetEntity.isServer, \"Assure is server\");\r\n\tthis.PositionChecks = doPositionChecks;\r\n\tthis.entitySource = targetEntity;\r\n\tthis.itemSource = null;\r\n\tInterface.CallHook(\"OnLootEntity\", this.GetComponent<global::BasePlayer>(), targetEntity);\r\n\tthis.MarkDirty();\r\n\tglobal::ILootableEntity lootableEntity;\r\n\tif ((lootableEntity = (targetEntity as global::ILootableEntity)) != null)\r\n\t{\r\n\t\tlootableEntity.LastLootedBy = base.baseEntity.userID;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnLootItem",
      "HookName": "OnLootItem",
      "HookParameters": {
        "instance": "PlayerLoot",
        "item": "Item"
      },
      "ReturnBehavior": 0,
      "TargetType": "PlayerLoot",
      "Category": "Player",
      "MethodData": {
        "MethodName": "StartLootingItem",
        "ReturnType": "void",
        "Arguments": {
          "item": "Item"
        }
      },
      "CodeAfterInjection": "...\r\n\tthis.PositionChecks = true;\r\n\tthis.containers.Add(item.contents);\r\n\titem.contents.onDirty += new System.Action(this.MarkDirty);\r\n\tthis.itemSource = item;\r\n\tthis.entitySource = item.GetWorldEntity();\r\n\tInterface.CallHook(\"OnLootItem\", this.GetComponent<global::BasePlayer>(), item);\r\n\tthis.MarkDirty();\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityEnter",
      "HookName": "OnEntityEnter",
      "HookDescription": "Called when an entity enters a trigger (water area, radiation zone, hurt zone, etc.)",
      "HookParameters": {
        "instance": "TriggerBase",
        "ent": "BaseEntity"
      },
      "ReturnBehavior": 1,
      "TargetType": "TriggerBase",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "OnEntityEnter",
        "ReturnType": "void",
        "Arguments": {
          "ent": "BaseEntity"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (this.entityContents == null)\r\n\t{\r\n\t\tthis.entityContents = new HashSet<global::BaseEntity>();\r\n\t}\r\n\tif (Interface.CallHook(\"OnEntityEnter\", this, ent) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.entityContents.Add(ent);\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityLeave",
      "HookName": "OnEntityLeave",
      "HookDescription": "Called when an entity leaves a trigger (water area, radiation zone, hurt zone, etc.)",
      "HookParameters": {
        "instance": "TriggerBase",
        "ent": "BaseEntity"
      },
      "ReturnBehavior": 1,
      "TargetType": "TriggerBase",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "OnEntityLeave",
        "ReturnType": "void",
        "Arguments": {
          "ent": "BaseEntity"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (this.entityContents == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnEntityLeave\", this, ent) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.entityContents.Remove(ent);\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemDeployed [Regular]",
      "HookName": "OnItemDeployed",
      "HookParameters": {
        "instance": "Deployer",
        "modDeployable": "ItemModDeployable",
        "baseEntity": "BaseEntity"
      },
      "ReturnBehavior": 0,
      "TargetType": "Deployer",
      "Category": "Item",
      "MethodData": {
        "MethodName": "DoDeploy_Regular",
        "ReturnType": "void",
        "Arguments": {
          "deployable": "Deployable",
          "ray": "UnityEngine.Ray"
        }
      },
      "CodeAfterInjection": "...\r\n\tbaseEntity.skinID = ownerItem.skin;\r\n\tbaseEntity.SendMessage(\"SetDeployedBy\", ownerPlayer, SendMessageOptions.DontRequireReceiver);\r\n\tbaseEntity.OwnerID = ownerPlayer.userID;\r\n\tbaseEntity.Spawn();\r\n\tmodDeployable.OnDeployed(baseEntity, ownerPlayer);\r\n\tInterface.CallHook(\"OnItemDeployed\", this, modDeployable, baseEntity);\r\n\tFacepunch.Rust.Analytics.Azure.OnEntityBuilt(baseEntity, ownerPlayer);\r\n\tbase.UseItemAmount(1);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemDeployed [Slot]",
      "HookName": "OnItemDeployed",
      "HookParameters": {
        "instance": "Deployer",
        "baseEntity": "BaseEntity",
        "baseEntity2": "BaseEntity"
      },
      "ReturnBehavior": 0,
      "TargetType": "Deployer",
      "Category": "Item",
      "MethodData": {
        "MethodName": "DoDeploy_Slot",
        "ReturnType": "void",
        "Arguments": {
          "deployable": "Deployable",
          "ray": "UnityEngine.Ray",
          "entityID": "NetworkableId"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t{\r\n\t\t\tglobal::Effect.server.Run(deployable.placeEffect.resourcePath, baseEntity.transform.position, Vector3.up, null, false);\r\n\t\t}\r\n\t}\r\n\tmodDeployable.OnDeployed(baseEntity2, ownerPlayer);\r\n\tInterface.CallHook(\"OnItemDeployed\", this, baseEntity, baseEntity2);\r\n\tFacepunch.Rust.Analytics.Azure.OnEntityBuilt(baseEntity2, ownerPlayer);\r\n\tbase.UseItemAmount(1);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "IOnBaseCombatEntityHurt",
      "HookName": "IOnBaseCombatEntityHurt",
      "HookParameters": {
        "instance": "BaseCombatEntity",
        "info": "HitInfo"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseCombatEntity",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "Hurt",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "...\r\n\t\tinfo.damageTypes.Scale(Rust.DamageType.Bleeding, ConVar.Server.bleedingdamage);\r\n\t\tif (!(this is global::BasePlayer))\r\n\t\t{\r\n\t\t\tinfo.damageTypes.Scale(Rust.DamageType.Fun_Water, 0f);\r\n\t\t}\r\n\t\tif (Interface.CallHook(\"IOnBaseCombatEntityHurt\", this, info) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis.DebugHurt(info);\r\n\t\tthis.health = health - info.damageTypes.Total();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnDispenserGather",
      "HookName": "OnDispenserGather",
      "HookParameters": {
        "instance": "ResourceDispenser",
        "entity": "BasePlayer",
        "item": "Item"
      },
      "ReturnBehavior": 1,
      "TargetType": "ResourceDispenser",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "GiveResourceFromItem",
        "ReturnType": "void",
        "Arguments": {
          "entity": "BasePlayer",
          "itemAmt": "ItemAmount",
          "gatherDamage": "float",
          "destroyFraction": "float",
          "attackWeapon": "AttackEntity"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (num3 >= 1f)\r\n\t{\r\n\t\tint num6 = this.CalculateGatherBonus(entity, itemAmt, num3);\r\n\t\tint iAmount = Mathf.FloorToInt(num3) + num6;\r\n\t\tglobal::Item item = global::ItemManager.CreateByItemID(itemAmt.itemid, iAmount, 0uL);\r\n\t\tif (Interface.CallHook(\"OnDispenserGather\", this, entity, item) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (item == null)\r\n\t\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerAttack [Melee]",
      "HookName": "OnPlayerAttack",
      "HookParameters": {
        "instance": "BaseMelee",
        "info": "HitInfo"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseMelee",
      "Category": "Player",
      "MethodData": {
        "MethodName": "DoAttackShared",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "public virtual void DoAttackShared(global::HitInfo info)\r\n{\r\n\tif (Interface.CallHook(\"OnPlayerAttack\", this.GetOwnerPlayer(), info) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.GetAttackStats(info);\r\n\tif (info.HitEntity != null)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerAttack [Projectile]",
      "HookName": "OnPlayerAttack",
      "HookParameters": {
        "instance": "BasePlayer",
        "hitInfo": "HitInfo"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "OnProjectileAttack",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (flag6)\r\n\t{\r\n\t\tthis.stats.Add(firedProjectile.itemMod.category + \"_hit_\" + hitEntity.Categorize(), 1, global::Stats.Steam);\r\n\t}\r\n\tif (Interface.CallHook(\"OnPlayerAttack\", this, hitInfo) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (firedProjectile.integrity <= 0f)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRunPlayerMetabolism",
      "HookName": "OnRunPlayerMetabolism",
      "HookParameters": {
        "instance": "PlayerMetabolism",
        "ownerEntity": "BaseCombatEntity",
        "delta": "Single"
      },
      "ReturnBehavior": 1,
      "TargetType": "PlayerMetabolism",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RunMetabolism",
        "ReturnType": "void",
        "Arguments": {
          "ownerEntity": "BaseCombatEntity",
          "delta": "float"
        }
      },
      "CodeAfterInjection": "protected override void RunMetabolism(global::BaseCombatEntity ownerEntity, float delta)\r\n{\r\n\tif (Interface.CallHook(\"OnRunPlayerMetabolism\", this, ownerEntity, delta) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::BaseGameMode activeGameMode = global::BaseGameMode.GetActiveGameMode(true);\r\n\tfloat currentTemperature = this.owner.currentTemperature;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "IOnUserApprove",
      "HookName": "IOnUserApprove",
      "HookParameters": {
        "connection": "Connection"
      },
      "ReturnBehavior": 1,
      "TargetType": "ConnectionAuth",
      "Category": "Player",
      "MethodData": {
        "MethodName": "OnNewConnection",
        "ReturnType": "void",
        "Arguments": {
          "connection": "Network.Connection"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (global::DeveloperList.Contains(connection.userid))\r\n\t{\r\n\t\tDebugEx.Log(connection.ToString() + \" is a developer\", StackTraceLogType.None);\r\n\t\tconnection.authLevel = 3u;\r\n\t}\r\n\tif (Interface.CallHook(\"IOnUserApprove\", connection) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::ConnectionAuth.m_AuthConnection.Add(connection);\r\n\tbase.StartCoroutine(this.AuthorisationRoutine(connection));\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnStructureUpgrade",
      "HookName": "OnStructureUpgrade",
      "HookParameters": {
        "instance": "BuildingBlock",
        "player": "BasePlayer",
        "enum": "Enum",
        "num": "ulong"
      },
      "ReturnBehavior": 1,
      "TargetType": "BuildingBlock",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "DoUpgradeToGrade",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (!this.CanChangeToGrade(@enum, num, msg.player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnStructureUpgrade\", this, msg.player, @enum, num) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!this.CanAffordUpgrade(@enum, num, msg.player))\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnStructureUpgrade [Delayed]",
      "HookName": "OnStructureUpgrade",
      "HookParameters": {
        "instance": "BuildingBlock",
        "player": "BasePlayer",
        "enum": "Enum",
        "num": "ulong"
      },
      "ReturnBehavior": 1,
      "TargetType": "BuildingBlock",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "DoUpgradeToGrade_Delayed",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (!this.CanChangeToGrade(@enum, num, msg.player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnStructureUpgrade\", this, msg.player, @enum, num) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!this.CanAffordUpgrade(@enum, num, msg.player))\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnStructureDemolish [immediate = true]",
      "HookName": "OnStructureDemolish",
      "HookParameters": {
        "instance": "BuildingBlock",
        "player": "BasePlayer",
        "Unknown": "Unknown"
      },
      "ReturnBehavior": 1,
      "TargetType": "BuildingBlock",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "DoImmediateDemolish",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (!msg.player.IsAdmin)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnStructureDemolish\", this, msg.player, true) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tFacepunch.Rust.Analytics.Azure.OnBuildingBlockDemolished(msg.player, this);\r\n\tbase.Kill(global::BaseNetworkable.DestroyMode.Gib);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnStructureRotate",
      "HookName": "OnStructureRotate",
      "HookParameters": {
        "instance": "BuildingBlock",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BuildingBlock",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "DoRotation",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (!this.blockDefinition.canRotateAfterPlacement)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnStructureRotate\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.transform.localRotation *= Quaternion.Euler(this.blockDefinition.rotationAmount);\r\n\tbase.RefreshEntityLinks();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFuelConsume",
      "HookName": "OnFuelConsume",
      "HookParameters": {
        "instance": "BaseOven",
        "fuel": "Item",
        "burnable": "ItemModBurnable"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseOven",
      "Category": "Fuel",
      "MethodData": {
        "MethodName": "ConsumeFuel",
        "ReturnType": "void",
        "Arguments": {
          "fuel": "Item",
          "burnable": "ItemModBurnable"
        }
      },
      "CodeAfterInjection": "private void ConsumeFuel(global::Item fuel, global::ItemModBurnable burnable)\r\n{\r\n\tif (Interface.CallHook(\"OnFuelConsume\", this, fuel, burnable) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.allowByproductCreation && burnable.byproductItem != null && UnityEngine.Random.Range(0f, 1f) > burnable.byproductChance)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanUpdateSign [Signage]",
      "HookName": "CanUpdateSign",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "Signage"
      },
      "ReturnBehavior": 1,
      "TargetType": "Signage",
      "Category": "Player",
      "MethodData": {
        "MethodName": "CanUpdateSign",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public virtual bool CanUpdateSign(global::BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanUpdateSign\", player, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif (player.IsAdmin || player.IsDeveloper)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSignLocked [Signage]",
      "HookName": "OnSignLocked",
      "HookParameters": {
        "instance": "Signage",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "Signage",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "LockSign",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t\treturn;\r\n\t}\r\n\tbase.SetFlag(global::BaseEntity.Flags.Locked, true, false, true);\r\n\tbase.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);\r\n\tbase.OwnerID = msg.player.userID;\r\n\tInterface.CallHook(\"OnSignLocked\", this, msg.player);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSignUpdated [Signage]",
      "HookName": "OnSignUpdated",
      "HookParameters": {
        "instance": "Signage",
        "player": "BasePlayer",
        "num": "int"
      },
      "ReturnBehavior": 0,
      "TargetType": "Signage",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "UpdateSign",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t}\r\n\t\tthis.textureIDs[num] = global::FileStorage.server.Store(array, global::FileStorage.Type.png, this.net.ID, (uint)num);\r\n\t}\r\n\tthis.LogEdit(msg.player);\r\n\tbase.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);\r\n\tInterface.CallHook(\"OnSignUpdated\", this, msg.player, num);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "IOnLoseCondition",
      "HookName": "IOnLoseCondition",
      "HookParameters": {
        "instance": "Item",
        "amount": "Single"
      },
      "ReturnBehavior": 1,
      "TargetType": "Item",
      "Category": "Item",
      "MethodData": {
        "MethodName": "LoseCondition",
        "ReturnType": "void",
        "Arguments": {
          "amount": "float"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (ConVar.Debugging.disablecondition)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"IOnLoseCondition\", this, amount) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat condition = this.condition;\r\n\tthis.condition -= amount;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerSleepEnd",
      "HookName": "OnPlayerSleepEnd",
      "HookParameters": {
        "instance": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "EndSleeping",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (!this.IsSleeping())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnPlayerSleepEnd\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.SetPlayerFlag(global::BasePlayer.PlayerFlags.Sleeping, false);\r\n\tthis.sleepStartTime = -1f;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityGroundMissing",
      "HookName": "OnEntityGroundMissing",
      "HookDescription": "Called when an entity (sleepingbag, sign, furnace,...) is going to be destroyed because the buildingblock it is on was removed",
      "HookParameters": {
        "baseEntity": "BaseEntity"
      },
      "ReturnBehavior": 1,
      "TargetType": "DestroyOnGroundMissing",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "OnGroundMissing",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "private void OnGroundMissing()\r\n{\r\n\tglobal::BaseEntity baseEntity = base.gameObject.ToBaseEntity();\r\n\tif (baseEntity != null)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnEntityGroundMissing\", baseEntity) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tglobal::BaseCombatEntity baseCombatEntity = baseEntity as global::BaseCombatEntity;\r\n\t\tif (baseCombatEntity != null)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnDoorOpened",
      "HookName": "OnDoorOpened",
      "HookParameters": {
        "instance": "Door",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "Door",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "RPC_OpenDoor",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (this.checkPhysBoxesOnOpen)\r\n\t{\r\n\t\tthis.StartCheckingForBlockages(true);\r\n\t}\r\n\tInterface.CallHook(\"OnDoorOpened\", this, rpc.player);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnDoorClosed",
      "HookName": "OnDoorClosed",
      "HookParameters": {
        "instance": "Door",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "Door",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "RPC_CloseDoor",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (this.isSecurityDoor && this.NavMeshLink != null)\r\n\t{\r\n\t\tthis.SetNavMeshLinkEnabled(false);\r\n\t}\r\n\tthis.StartCheckingForBlockages(false);\r\n\tInterface.CallHook(\"OnDoorClosed\", this, rpc.player);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerTick",
      "HookName": "OnPlayerTick",
      "HookParameters": {
        "instance": "BasePlayer",
        "msg": "PlayerTick",
        "wasPlayerStalled": "Boolean"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "OnReceiveTick",
        "ReturnType": "void",
        "Arguments": {
          "msg": "PlayerTick",
          "wasPlayerStalled": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (msg.inputState != null)\r\n\t{\r\n\t\tthis.serverInput.Flip(msg.inputState);\r\n\t}\r\n\tif (Interface.CallHook(\"OnPlayerTick\", this, msg, wasPlayerStalled) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.serverInput.current.buttons != this.serverInput.previous.buttons)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "IOnBasePlayerAttacked",
      "HookName": "IOnBasePlayerAttacked",
      "HookParameters": {
        "instance": "BasePlayer",
        "info": "HitInfo"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "OnAttacked",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "public override void OnAttacked(global::HitInfo info)\r\n{\r\n\tif (Interface.CallHook(\"IOnBasePlayerAttacked\", this, info) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat health = base.health;\r\n\tif (this.InSafeZone() && !this.IsHostile() && info.Initiator != null && info.Initiator != this)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "IOnBasePlayerHurt",
      "HookName": "IOnBasePlayerHurt",
      "HookParameters": {
        "instance": "BasePlayer",
        "info": "HitInfo"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "Hurt",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (this.IsImmortalTo(info) && info.damageTypes.Total() >= 0f)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"IOnBasePlayerHurt\", this, info) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (ConVar.Server.pve && info.Initiator && info.Initiator is global::BasePlayer && info.Initiator != this)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnExplosiveThrown",
      "HookName": "OnExplosiveThrown",
      "HookParameters": {
        "player": "BasePlayer",
        "baseEntity": "BaseEntity",
        "instance": "ThrownWeapon"
      },
      "ReturnBehavior": 0,
      "TargetType": "ThrownWeapon",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "DoThrow",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t\tbaseEntity.SetAngularVelocity(new Vector3(UnityEngine.Random.Range(-1f, 1f), UnityEngine.Random.Range(-1f, 1f), UnityEngine.Random.Range(-1f, 1f)) * this.tumbleVelocity);\r\n\t}\r\n\tbaseEntity.Spawn();\r\n\tthis.SetUpThrownWeapon(baseEntity);\r\n\tbase.StartAttackCooldown(this.repeatDelay);\r\n\tInterface.CallHook(\"OnExplosiveThrown\", msg.player, baseEntity, this);\r\n\tbase.UseItemAmount(1);\r\n\tglobal::BasePlayer player = msg.player;\r\n\tif (player != null)\r\n\t{\r\n\t\tglobal::TimedExplosive timedExplosive = baseEntity as global::TimedExplosive;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMeleeThrown",
      "HookName": "OnMeleeThrown",
      "HookParameters": {
        "player": "BasePlayer",
        "item": "Item"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseMelee",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "CLProject",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (projectileShoot != null)\r\n\t{\r\n\t\tprojectileShoot.Dispose();\r\n\t}\r\n\titem.SetParent(null);\r\n\tInterface.CallHook(\"OnMeleeThrown\", player, item);\r\n\tif (this.canAiHearIt)\r\n\t{\r\n\t\tfloat num = 0f;\r\n\t\tif (component.projectileObject != null)\r\n\t\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemCraftFinished",
      "HookName": "OnItemCraftFinished",
      "HookParameters": {
        "task": "ItemCraftTask",
        "item": "Item"
      },
      "ReturnBehavior": 0,
      "TargetType": "ItemCrafter",
      "Category": "Item",
      "MethodData": {
        "MethodName": "FinishCrafting",
        "ReturnType": "void",
        "Arguments": {
          "task": "ItemCraftTask"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\ttask.taskUID,\r\n\t\t1,\r\n\t\ttask.amount\r\n\t});\r\n\tInterface.CallHook(\"OnItemCraftFinished\", task, item);\r\n\tif (task.instanceData != null)\r\n\t{\r\n\t\titem.instanceData = task.instanceData;\r\n\t}\r\n\tif (!string.IsNullOrEmpty(task.blueprint.UnlockAchievment))\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnHealingItemUse",
      "HookName": "OnHealingItemUse",
      "HookParameters": {
        "instance": "MedicalTool",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "MedicalTool",
      "Category": "Item",
      "MethodData": {
        "MethodName": "GiveEffectsTo",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (!component)\r\n\t{\r\n\t\tDebug.LogWarning(\"No consumable for medicaltool :\" + base.name);\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnHealingItemUse\", this, player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::BasePlayer ownerPlayer = base.GetOwnerPlayer();\r\n\tFacepunch.Rust.Analytics.Azure.OnMedUsed(ownerItemDefinition.shortname, ownerPlayer, player);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanResearchItem",
      "HookName": "CanResearchItem",
      "HookParameters": {
        "player": "BasePlayer",
        "targetItem": "Item"
      },
      "ReturnBehavior": 1,
      "TargetType": "ResearchTable",
      "Category": "Player",
      "MethodData": {
        "MethodName": "DoResearch",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tglobal::Item targetItem = this.GetTargetItem();\r\n\tif (targetItem == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanResearchItem\", player, targetItem) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (targetItem.amount > 1)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemResearch",
      "HookName": "OnItemResearch",
      "HookParameters": {
        "instance": "ResearchTable",
        "targetItem": "Item",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "ResearchTable",
      "Category": "Item",
      "MethodData": {
        "MethodName": "DoResearch",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tglobal::Item targetItem = this.GetTargetItem();\r\n\tif (targetItem == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanResearchItem\", player, targetItem) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (targetItem.amount > 1)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemResearched",
      "HookName": "OnItemResearched",
      "HookParameters": {
        "instance": "ResearchTable",
        "num": "int"
      },
      "ReturnBehavior": 3,
      "TargetType": "ResearchTable",
      "Category": "Item",
      "MethodData": {
        "MethodName": "ResearchAttemptFinished",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tglobal::Item targetItem = this.GetTargetItem();\r\n\tglobal::Item scrapItem = this.GetScrapItem();\r\n\tif (targetItem != null && scrapItem != null)\r\n\t{\r\n\t\tint num = this.ScrapForResearch(targetItem);\r\n\t\tobject returnvar = Interface.CallHook(\"OnItemResearched\", this, num);\r\n\t\tif (returnvar is int)\r\n\t\t{\r\n\t\t\tnum = (int)returnvar;\r\n\t\t}\r\n\t\tif (scrapItem.amount >= num)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanLootPlayer",
      "HookName": "CanLootPlayer",
      "HookParameters": {
        "instance": "BasePlayer",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "CanBeLooted",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public override bool CanBeLooted(global::BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanLootPlayer\", this, player);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn !(player == this) && (this.IsWounded() || this.IsSleeping());\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanBeWounded",
      "HookName": "CanBeWounded",
      "HookParameters": {
        "instance": "BasePlayer",
        "info": "HitInfo"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "EligibleForWounding",
        "ReturnType": "bool",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "public virtual bool EligibleForWounding(global::HitInfo info)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanBeWounded\", this, info);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif (!ConVar.Server.woundingenabled)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRocketLaunched",
      "HookName": "OnRocketLaunched",
      "HookParameters": {
        "player": "BasePlayer",
        "raycastHit": "BaseEntity"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseLauncher",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "SV_Launch",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\tcomponent2.InitializeVelocity(this.GetInheritedVelocity(player, vector2) + vector2 * component2.speed);\r\n\t}\r\n\tbaseEntity2.Spawn();\r\n\tFacepunch.Rust.Analytics.Azure.OnExplosiveLaunched(player, baseEntity2, this);\r\n\tInterface.CallHook(\"OnRocketLaunched\", player, baseEntity2);\r\n\tbase.StartAttackCooldown(base.ScaleRepeatDelay(this.repeatDelay));\r\n\tglobal::Item ownerItem = base.GetOwnerItem();\r\n\tif (ownerItem == null)\r\n\t{\r\n\t\treturn;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnWeaponFired",
      "HookName": "OnWeaponFired",
      "HookParameters": {
        "instance": "BaseProjectile",
        "player": "BasePlayer",
        "component": "ItemModProjectile",
        "projectileShoot": "ProjectileShoot"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseProjectile",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "CLProject",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\tglobal::AntiHack.Log(player, global::AntiHackType.ProjectileHack, \"Count mismatch (\" + base.ShortPrefabName + \")\");\r\n\t\tplayer.stats.combat.LogInvalid(player, this, \"count_mismatch\");\r\n\t\treturn;\r\n\t}\r\n\tInterface.CallHook(\"OnWeaponFired\", this, msg.player, component, projectileShoot);\r\n\tif (player.InGesture)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.SignalBroadcast(global::BaseEntity.Signal.Attack, string.Empty, msg.connection);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemUse",
      "HookName": "OnItemUse",
      "HookParameters": {
        "instance": "Item",
        "amountToConsume": "int"
      },
      "ReturnBehavior": 3,
      "TargetType": "Item",
      "Category": "Item",
      "MethodData": {
        "MethodName": "UseItem",
        "ReturnType": "void",
        "Arguments": {
          "amountToConsume": "int"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (amountToConsume <= 0)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"OnItemUse\", this, amountToConsume);\r\n\tif (returnvar is int)\r\n\t{\r\n\t\tamountToConsume = (int)returnvar;\r\n\t}\r\n\tthis.amount -= amountToConsume;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnHammerHit",
      "HookName": "OnHammerHit",
      "HookParameters": {
        "ownerPlayer": "BasePlayer",
        "info": "HitInfo"
      },
      "ReturnBehavior": 1,
      "TargetType": "Hammer",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "DoAttackShared",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tglobal::BasePlayer ownerPlayer = base.GetOwnerPlayer();\r\n\tglobal::BaseCombatEntity baseCombatEntity = info.HitEntity as global::BaseCombatEntity;\r\n\tif (baseCombatEntity != null && ownerPlayer != null && base.isServer)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnHammerHit\", ownerPlayer, info) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tusing (TimeWarning.New(\"DoRepair\", 50))\r\n\t\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSurveyGather",
      "HookName": "OnSurveyGather",
      "HookParameters": {
        "instance": "SurveyCharge",
        "itemManager": "ItemManager"
      },
      "ReturnBehavior": 0,
      "TargetType": "SurveyCharge",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "Explode",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\t\t}\r\n\t\t\tfor (int i = 0; i < num; i++)\r\n\t\t\t{\r\n\t\t\t\tglobal::Item OxideGen_15 = global::ItemManager.Create(current.type, iAmount, 0uL);\r\n\t\t\t\tglobal::Item arg_1B3_0 = OxideGen_15;\r\n\t\t\t\tInterface.CallHook(\"OnSurveyGather\", this, OxideGen_15);\r\n\t\t\t\tVector3 modifiedAimConeDirection = global::AimConeUtil.GetModifiedAimConeDirection(20f, Vector3.up, true);\r\n\t\t\t\targ_1B3_0.Drop(base.transform.position + Vector3.up * 1f, this.GetInheritedDropVelocity() + modifiedAimConeDirection * UnityEngine.Random.Range(5f, 10f), UnityEngine.Random.rotation).SetAngularVelocity(UnityEngine.Random.rotation.eulerAngles * 5f);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnAirdrop",
      "HookName": "OnAirdrop",
      "HookDescription": "Called when an airdrop has been called",
      "HookParameters": {
        "instance": "CargoPlane",
        "newDropPosition": "Vector3"
      },
      "ReturnBehavior": 0,
      "TargetType": "CargoPlane",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "UpdateDropPosition",
        "ReturnType": "void",
        "Arguments": {
          "newDropPosition": "UnityEngine.Vector3"
        }
      },
      "CodeAfterInjection": "...\r\n\tthis.secondsToTake = Vector3.Distance(this.startPos, this.endPos) / 50f;\r\n\tthis.secondsToTake *= UnityEngine.Random.Range(0.95f, 1.05f);\r\n\tbase.transform.position = this.startPos;\r\n\tbase.transform.rotation = Quaternion.LookRotation(this.endPos - this.startPos);\r\n\tthis.dropPosition = newDropPosition;\r\n\tInterface.CallHook(\"OnAirdrop\", this, newDropPosition);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnStructureRepair",
      "HookName": "OnStructureRepair",
      "HookParameters": {
        "instance": "BaseCombatEntity",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseCombatEntity",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "DoRepair",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "...\r\n\tglobal::BasePlayer player = player2;\r\n\tif (!this.repair.enabled)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnStructureRepair\", this, player2) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat num = 30f;\r\n\tif (this.SecondsSinceAttacked <= num)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemRepair",
      "HookName": "OnItemRepair",
      "HookParameters": {
        "player": "BasePlayer",
        "itemToRepair": "Item"
      },
      "ReturnBehavior": 1,
      "TargetType": "RepairBench",
      "Category": "Item",
      "MethodData": {
        "MethodName": "RepairAnItem",
        "ReturnType": "void",
        "Arguments": {
          "itemToRepair": "Item",
          "player": "BasePlayer",
          "repairBenchEntity": "BaseEntity",
          "maxConditionLostOnRepair": "float",
          "mustKnowBlueprint": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n\t\tif (!player.blueprints.HasUnlocked(itemDefinition) && (!(itemDefinition.Blueprint != null) || itemDefinition.Blueprint.isResearchable))\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\tif (Interface.CallHook(\"OnItemRepair\", player, itemToRepair) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat num = global::RepairBench.RepairCostFraction(itemToRepair);\r\n\tbool flag = false;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTrapSnapped",
      "HookName": "OnTrapSnapped",
      "HookParameters": {
        "instance": "BaseTrapTrigger",
        "obj": "GameObject",
        "col": "Collider"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseTrapTrigger",
      "Category": "Traps",
      "MethodData": {
        "MethodName": "OnObjectAdded",
        "ReturnType": "void",
        "Arguments": {
          "obj": "UnityEngine.GameObject",
          "col": "UnityEngine.Collider"
        }
      },
      "CodeAfterInjection": "internal override void OnObjectAdded(GameObject obj, Collider col)\r\n{\r\n\tInterface.CallHook(\"OnTrapSnapped\", this, obj, col);\r\n\tbase.OnObjectAdded(obj, col);\r\n\tthis._trap.ObjectEntered(obj);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTrapDisarm",
      "HookName": "OnTrapDisarm",
      "HookParameters": {
        "instance": "Landmine",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "Landmine",
      "Category": "Traps",
      "MethodData": {
        "MethodName": "RPC_Disarm",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (!this.Armed())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnTrapDisarm\", this, rpc.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.SetFlag(global::BaseEntity.Flags.On, false, false, true);\r\n\tif (UnityEngine.Random.Range(0, 100) < 15)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTrapArm",
      "HookName": "OnTrapArm",
      "HookParameters": {
        "instance": "BearTrap",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BearTrap",
      "Category": "Traps",
      "MethodData": {
        "MethodName": "RPC_Arm",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (this.Armed())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnTrapArm\", this, rpc.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.Arm();\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMapImageUpdated",
      "HookName": "OnMapImageUpdated",
      "HookParameters": {},
      "ReturnBehavior": 0,
      "TargetType": "MapEntity",
      "Category": "Item",
      "MethodData": {
        "MethodName": "ImageUpdate",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (b == 1)\r\n\t{\r\n\t\tthis.paintImages[(int)b2] = num3;\r\n\t}\r\n\tbase.InvalidateNetworkCache();\r\n\tInterface.CallHook(\"OnMapImageUpdated\");\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemCraftCancelled",
      "HookName": "OnItemCraftCancelled",
      "HookParameters": {
        "itemCraftTask": "ItemCraftTask"
      },
      "ReturnBehavior": 0,
      "TargetType": "ItemCrafter",
      "Category": "Item",
      "MethodData": {
        "MethodName": "CancelTask",
        "ReturnType": "bool",
        "Arguments": {
          "iID": "int",
          "ReturnItems": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n\titemCraftTask.cancelled = true;\r\n\tif (itemCraftTask.owner == null)\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\tInterface.CallHook(\"OnItemCraftCancelled\", itemCraftTask);\r\n\titemCraftTask.owner.Command(\"note.craft_done\", new object[]\r\n\t{\r\n\t\titemCraftTask.taskUID,\r\n\t\t0\r\n\t});\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnResourceDepositCreated",
      "HookName": "OnResourceDepositCreated",
      "HookParameters": {
        "arg_2D5_0": "ResourceDeposit"
      },
      "ReturnBehavior": 0,
      "TargetType": "ResourceDepositManager",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "CreateFromPosition",
        "ReturnType": "ResourceDepositManager/ResourceDeposit",
        "Arguments": {
          "pos": "UnityEngine.Vector3"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t{\r\n\t\t\tresourceDeposit.Add(global::ItemManager.FindItemDefinition(\"hq.metal.ore\"), 1f, UnityEngine.Random.Range(5000, 10000), UnityEngine.Random.Range(30f, 50f), global::ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM, false);\r\n\t\t}\r\n\t}\r\n\tthis._deposits.Add(indexFrom, resourceDeposit);\r\n\tInterface.CallHook(\"OnResourceDepositCreated\", resourceDeposit);\r\n\tUnityEngine.Random.state = arg_2D5_0;\r\n\treturn resourceDeposit;\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemUpgrade",
      "HookName": "OnItemUpgrade",
      "HookParameters": {
        "item": "Item",
        "item2": "Item",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "ItemModUpgrade",
      "Category": "Item",
      "MethodData": {
        "MethodName": "ServerCommand",
        "ReturnType": "void",
        "Arguments": {
          "item": "Item",
          "command": "string",
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t}\r\n\t\tif (UnityEngine.Random.Range(0f, 1f) <= this.upgradeSuccessChance)\r\n\t\t{\r\n\t\t\titem.UseItem(this.numForUpgrade);\r\n\t\t\tglobal::Item item2 = global::ItemManager.Create(this.upgradedItem, this.numUpgradedItem, 0uL);\r\n\t\t\tInterface.CallHook(\"OnItemUpgrade\", item, item2, player);\r\n\t\t\tif (!item2.MoveToContainer(player.inventory.containerMain, -1, true, false, null, true))\r\n\t\t\t{\r\n\t\t\t\titem2.Drop(player.GetDropPosition(), player.GetDropVelocity(), default(Quaternion));\r\n\t\t\t}\r\n\t\t\tif (this.successEffect.isValid)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCupboardAuthorize [BuildingPrivlidge]",
      "HookName": "OnCupboardAuthorize",
      "HookParameters": {
        "instance": "BuildingPrivlidge",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BuildingPrivlidge",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "AddSelfAuthorize",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (!this.CanAdministrate(rpc.player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnCupboardAuthorize\", this, rpc.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.AddPlayer(rpc.player);\r\n\tbase.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCupboardDeauthorize",
      "HookName": "OnCupboardDeauthorize",
      "HookParameters": {
        "instance": "BuildingPrivlidge",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BuildingPrivlidge",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "RemoveSelfAuthorize",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (!this.CanAdministrate(rpc.player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnCupboardDeauthorize\", this, rpc2.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.authorizedPlayers.RemoveAll((PlayerNameID x) => x.userid == rpc.player.userID);\r\n\tglobal::BasePlayer arg_AC_1 = rpc.player;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanNetworkTo",
      "HookName": "CanNetworkTo",
      "HookParameters": {
        "instance": "BaseNetworkable",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseNetworkable",
      "Category": "Network",
      "MethodData": {
        "MethodName": "ShouldNetworkTo",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public virtual bool ShouldNetworkTo(global::BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanNetworkTo\", this, player);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn this.net.group == null || player.net.subscriber.IsSubscribed(this.net.group);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTurretTarget",
      "HookName": "OnTurretTarget",
      "HookParameters": {
        "instance": "AutoTurret",
        "targ": "BaseCombatEntity"
      },
      "ReturnBehavior": 1,
      "TargetType": "AutoTurret",
      "Category": "Turret",
      "MethodData": {
        "MethodName": "SetTarget",
        "ReturnType": "void",
        "Arguments": {
          "targ": "BaseCombatEntity"
        }
      },
      "CodeAfterInjection": "public void SetTarget(global::BaseCombatEntity targ)\r\n{\r\n\tif (Interface.CallHook(\"OnTurretTarget\", this, targ) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (targ != this.target)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanBeTargeted [AutoTurret]",
      "HookName": "CanBeTargeted",
      "HookParameters": {
        "obj": "BaseCombatEntity",
        "instance": "AutoTurret"
      },
      "ReturnBehavior": 1,
      "TargetType": "AutoTurret",
      "Category": "Player",
      "MethodData": {
        "MethodName": "ObjectVisible",
        "ReturnType": "bool",
        "Arguments": {
          "obj": "BaseCombatEntity"
        }
      },
      "CodeAfterInjection": "public bool ObjectVisible(global::BaseCombatEntity obj)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanBeTargeted\", obj, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tSystem.Collections.Generic.List<RaycastHit> list = Pool.GetList<RaycastHit>();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnHelicopterTarget",
      "HookName": "OnHelicopterTarget",
      "HookParameters": {
        "instance": "HelicopterTurret",
        "newTarget": "BaseCombatEntity"
      },
      "ReturnBehavior": 1,
      "TargetType": "HelicopterTurret",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "SetTarget",
        "ReturnType": "void",
        "Arguments": {
          "newTarget": "BaseCombatEntity"
        }
      },
      "CodeAfterInjection": "public void SetTarget(global::BaseCombatEntity newTarget)\r\n{\r\n\tif (Interface.CallHook(\"OnHelicopterTarget\", this, newTarget) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis._target = newTarget;\r\n\tthis.UpdateTargetVisibility();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanBeTargeted [HelicopterTurret]",
      "HookName": "CanBeTargeted",
      "HookParameters": {
        "potentialtarget": "BaseCombatEntity",
        "instance": "HelicopterTurret"
      },
      "ReturnBehavior": 1,
      "TargetType": "HelicopterTurret",
      "Category": "Player",
      "MethodData": {
        "MethodName": "InFiringArc",
        "ReturnType": "bool",
        "Arguments": {
          "potentialtarget": "BaseCombatEntity"
        }
      },
      "CodeAfterInjection": "public bool InFiringArc(global::BaseCombatEntity potentialtarget)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanBeTargeted\", potentialtarget, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn this.AngleToTarget(potentialtarget) < 80f;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanBuild",
      "HookName": "CanBuild",
      "HookParameters": {
        "instance": "Planner",
        "construction": "Construction",
        "canBuildResult": "Target"
      },
      "ReturnBehavior": 1,
      "TargetType": "Planner",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "DoBuild",
        "ReturnType": "void",
        "Arguments": {
          "msg": "ProtoBuf.CreateBuilding"
        }
      },
      "CodeAfterInjection": "...\r\n\ttarget.position = msg.position;\r\n\ttarget.normal = msg.normal;\r\n\ttarget.rotation = msg.rotation;\r\n\ttarget.player = ownerPlayer;\r\n\ttarget.valid = true;\r\n\tif (Interface.CallHook(\"CanBuild\", this, construction, target) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (target.entity != null && deployable != null && deployable.setSocketParent)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanEquipItem",
      "HookName": "CanEquipItem",
      "HookParameters": {
        "instance": "PlayerInventory",
        "item": "Item",
        "targetSlot": "Int32"
      },
      "ReturnBehavior": 1,
      "TargetType": "PlayerInventory",
      "Category": "Item",
      "MethodData": {
        "MethodName": "CanEquipItem",
        "ReturnType": "bool",
        "Arguments": {
          "item": "Item",
          "targetSlot": "int"
        }
      },
      "CodeAfterInjection": "private bool CanEquipItem(global::Item item, int targetSlot)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanEquipItem\", this, item, targetSlot);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tglobal::ItemModContainerRestriction component = item.info.GetComponent<global::ItemModContainerRestriction>();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanWearItem",
      "HookName": "CanWearItem",
      "HookParameters": {
        "instance": "PlayerInventory",
        "item": "Item",
        "targetSlot": "Int32"
      },
      "ReturnBehavior": 1,
      "TargetType": "PlayerInventory",
      "Category": "Item",
      "MethodData": {
        "MethodName": "CanWearItem",
        "ReturnType": "bool",
        "Arguments": {
          "item": "Item",
          "targetSlot": "int"
        }
      },
      "CodeAfterInjection": "private bool CanWearItem(global::Item item, int targetSlot)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanWearItem\", this, item, targetSlot);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn this.CanWearItem(item, true);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanAcceptItem",
      "HookName": "CanAcceptItem",
      "HookParameters": {
        "instance": "ItemContainer",
        "item": "Item",
        "targetPos": "Int32"
      },
      "ReturnBehavior": 1,
      "TargetType": "ItemContainer",
      "Category": "Item",
      "MethodData": {
        "MethodName": "CanAcceptItem",
        "ReturnType": "ItemContainer/CanAcceptResult",
        "Arguments": {
          "item": "Item",
          "targetPos": "int"
        }
      },
      "CodeAfterInjection": "...\r\n\t\tif (!flag)\r\n\t\t{\r\n\t\t\treturn global::ItemContainer.CanAcceptResult.CannotAccept;\r\n\t\t}\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"CanAcceptItem\", this, item, targetPos);\r\n\tif (returnvar is global::ItemContainer.CanAcceptResult)\r\n\t{\r\n\t\treturn (global::ItemContainer.CanAcceptResult)returnvar;\r\n\t}\r\n\treturn global::ItemContainer.CanAcceptResult.CanAccept;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerLootEnd",
      "HookName": "OnPlayerLootEnd",
      "HookParameters": {
        "instance": "PlayerLoot"
      },
      "ReturnBehavior": 0,
      "TargetType": "PlayerLoot",
      "Category": "Player",
      "MethodData": {
        "MethodName": "Clear",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (!this.IsLooting())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tInterface.CallHook(\"OnPlayerLootEnd\", this);\r\n\tthis.MarkDirty();\r\n\tif (this.entitySource)\r\n\t{\r\n\t\tthis.entitySource.SendMessage(\"PlayerStoppedLooting\", base.baseEntity, SendMessageOptions.DontRequireReceiver);\r\n\t}\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemSplit",
      "HookName": "OnItemSplit",
      "HookParameters": {
        "instance": "Item",
        "split_Amount": "Int32"
      },
      "ReturnBehavior": 1,
      "TargetType": "Item",
      "Category": "Item",
      "MethodData": {
        "MethodName": "SplitItem",
        "ReturnType": "Item",
        "Arguments": {
          "split_Amount": "int"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (split_Amount >= this.amount)\r\n\t{\r\n\t\treturn null;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"OnItemSplit\", this, split_Amount);\r\n\tif (returnvar is global::Item)\r\n\t{\r\n\t\treturn (global::Item)returnvar;\r\n\t}\r\n\tthis.amount -= split_Amount;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCupboardClearList",
      "HookName": "OnCupboardClearList",
      "HookParameters": {
        "instance": "BuildingPrivlidge",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BuildingPrivlidge",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "ClearList",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (!this.CanAdministrate(rpc.player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnCupboardClearList\", this, rpc.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.authorizedPlayers.Clear();\r\n\tthis.UpdateMaxAuthCapacity();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnLootEntityEnd [LootableCorpse]",
      "HookName": "OnLootEntityEnd",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "LootableCorpse"
      },
      "ReturnBehavior": 0,
      "TargetType": "LootableCorpse",
      "Category": "Player",
      "MethodData": {
        "MethodName": "PlayerStoppedLooting",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public void PlayerStoppedLooting(global::BasePlayer player)\r\n{\r\n\tInterface.CallHook(\"OnLootEntityEnd\", player, this);\r\n\tbase.ResetRemovalTime();\r\n\tbase.SetFlag(global::BaseEntity.Flags.Open, false, false, true);\r\n\tbase.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnLootEntityEnd [StorageContainer]",
      "HookName": "OnLootEntityEnd",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "StorageContainer"
      },
      "ReturnBehavior": 0,
      "TargetType": "StorageContainer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "PlayerStoppedLooting",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public virtual void PlayerStoppedLooting(global::BasePlayer player)\r\n{\r\n\tInterface.CallHook(\"OnLootEntityEnd\", player, this);\r\n\tbase.SetFlag(global::BaseEntity.Flags.Open, false, false, true);\r\n\tbase.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnStructureDemolish [immediate = false]",
      "HookName": "OnStructureDemolish",
      "HookParameters": {
        "instance": "BuildingBlock",
        "player": "BasePlayer",
        "Unknown": "Unknown"
      },
      "ReturnBehavior": 1,
      "TargetType": "BuildingBlock",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "DoDemolish",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (!this.CanDemolish(msg.player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnStructureDemolish\", this, msg.player, false) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tFacepunch.Rust.Analytics.Azure.OnBuildingBlockDemolished(msg.player, this);\r\n\tbase.Kill(global::BaseNetworkable.DestroyMode.Gib);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanCreateWorldProjectile",
      "HookName": "CanCreateWorldProjectile",
      "HookParameters": {
        "info": "HitInfo",
        "itemDef": "ItemDefinition"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "CreateWorldProjectile",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo",
          "itemDef": "ItemDefinition",
          "itemMod": "ItemModProjectile",
          "projectilePrefab": "Projectile",
          "recycleItem": "Item"
        }
      },
      "CodeAfterInjection": "protected virtual void CreateWorldProjectile(global::HitInfo info, global::ItemDefinition itemDef, global::ItemModProjectile itemMod, global::Projectile projectilePrefab, global::Item recycleItem)\r\n{\r\n\tif (Interface.CallHook(\"CanCreateWorldProjectile\", info, itemDef) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tVector3 projectileVelocity = info.ProjectileVelocity;\r\n\tglobal::Item item = (recycleItem != null) ? recycleItem : global::ItemManager.Create(itemDef, 1, 0uL);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemPickup",
      "HookName": "OnItemPickup",
      "HookParameters": {
        "item": "Item",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "WorldItem",
      "Category": "Item",
      "MethodData": {
        "MethodName": "Pickup",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (!this.allowPickup)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnItemPickup\", this.item, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.ClientRPC(null, \"PickupSound\");\r\n\tglobal::Item item = this.item;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanBypassQueue",
      "HookName": "CanBypassQueue",
      "HookParameters": {
        "connection": "Connection"
      },
      "ReturnBehavior": 1,
      "TargetType": "ConnectionQueue",
      "Category": "Player",
      "MethodData": {
        "MethodName": "CanJumpQueue",
        "ReturnType": "bool",
        "Arguments": {
          "connection": "Network.Connection"
        }
      },
      "CodeAfterInjection": "private bool CanJumpQueue(Connection connection)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanBypassQueue\", connection);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif (global::DeveloperList.Contains(connection.userid))\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityKill",
      "HookName": "OnEntityKill",
      "HookDescription": "Called when an entity is destroyed",
      "HookParameters": {
        "instance": "BaseNetworkable"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseNetworkable",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "Kill",
        "ReturnType": "void",
        "Arguments": {
          "mode": "BaseNetworkable/DestroyMode"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (this.IsDestroyed)\r\n\t{\r\n\t\tDebug.LogWarning(\"Calling kill - but already IsDestroyed!? \" + this);\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnEntityKill\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.gameObject.BroadcastOnParentDestroying();\r\n\tthis.DoEntityDestroy();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerRespawned",
      "HookName": "OnPlayerRespawned",
      "HookParameters": {
        "instance": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RespawnAt",
        "ReturnType": "void",
        "Arguments": {
          "position": "UnityEngine.Vector3",
          "rotation": "UnityEngine.Quaternion",
          "spawnPointEntity": "BaseEntity"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (this.net != null)\r\n\t{\r\n\t\tglobal::EACServer.OnStartLoading(this.net.connection);\r\n\t}\r\n\tInterface.CallHook(\"OnPlayerRespawned\", this);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMessagePlayer",
      "HookName": "OnMessagePlayer",
      "HookParameters": {
        "msg": "string",
        "instance": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Server",
      "MethodData": {
        "MethodName": "ChatMessage",
        "ReturnType": "void",
        "Arguments": {
          "msg": "string"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (!base.isServer)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnMessagePlayer\", msg, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.SendConsoleCommand(\"chat.add\", new object[]\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnServerMessage",
      "HookName": "OnServerMessage",
      "HookParameters": {
        "message": "String",
        "username": "String",
        "color": "String",
        "userid": "UInt64"
      },
      "ReturnBehavior": 1,
      "TargetType": "ConVar.Chat",
      "Category": "Server",
      "MethodData": {
        "MethodName": "Broadcast",
        "ReturnType": "void",
        "Arguments": {
          "message": "string",
          "username": "string",
          "color": "string",
          "userid": "ulong"
        }
      },
      "CodeAfterInjection": "public static void Broadcast(string message, string username = \"SERVER\", string color = \"#eee\", ulong userid = 0uL)\r\n{\r\n\tif (Interface.CallHook(\"OnServerMessage\", message, username, color, userid) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tstring text = username.EscapeRichText();\r\n\tglobal::ConsoleNetwork.BroadcastToAllClients(\"chat.add\", new object[]\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRconConnection [exp]",
      "HookName": "OnRconConnection",
      "HookParameters": {
        "Address": "IPAddress"
      },
      "ReturnBehavior": 1,
      "TargetType": "Facepunch.RCon/RConListener",
      "Category": "Server",
      "MethodData": {
        "MethodName": "ProcessConnections",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tif (socket == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tIPEndPoint iPEndPoint = socket.RemoteEndPoint as IPEndPoint;\r\n\tif (Interface.CallHook(\"OnRconConnection\", iPEndPoint.Address) != null)\r\n\t{\r\n\t\tsocket.Close();\r\n\t\treturn;\r\n\t}\r\n\tif (Facepunch.RCon.IsBanned(iPEndPoint.Address))\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnRconConnection [exp, patch]",
      "HookName": "OnRconConnection [exp, patch]",
      "ReturnBehavior": 0,
      "TargetType": "Facepunch.RCon/RConListener",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "ProcessConnections",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tif (socket == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tIPEndPoint iPEndPoint = socket.RemoteEndPoint as IPEndPoint;\r\n\tif (Interface.CallHook(\"OnRconConnection\", iPEndPoint.Address) != null)\r\n\t{\r\n\t\tsocket.Close();\r\n\t\treturn;\r\n\t}\r\n\tif (Facepunch.RCon.IsBanned(iPEndPoint.Address))\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnClientAuth",
      "HookName": "OnClientAuth",
      "HookParameters": {
        "connection": "Connection"
      },
      "ReturnBehavior": 0,
      "TargetType": "ServerMgr",
      "Category": "Player",
      "MethodData": {
        "MethodName": "OnGiveUserInformation",
        "ReturnType": "void",
        "Arguments": {
          "packet": "Network.Message"
        }
      },
      "CodeAfterInjection": "...\r\n\tstring branch = ConVar.Server.branch;\r\n\tif (packet.read.Unread >= 4)\r\n\t{\r\n\t\ttext = packet.read.String(128);\r\n\t}\r\n\tInterface.CallHook(\"OnClientAuth\", packet.connection);\r\n\tif (branch != string.Empty && branch != text)\r\n\t{\r\n\t\tDebugEx.Log(string.Concat(new object[]\r\n\t\t{\r\n\t\t\t\"Kicking \",\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnNewSave",
      "HookName": "OnNewSave",
      "HookParameters": {
        "strFilename": "string"
      },
      "ReturnBehavior": 0,
      "TargetType": "SaveRestore",
      "Category": "Server",
      "MethodData": {
        "MethodName": "Load",
        "ReturnType": "bool",
        "Arguments": {
          "strFilename": "string",
          "allowOutOfDateSaves": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t{\r\n\t\t\tstrFilename = global::World.SaveFolderName + \"/\" + global::World.SaveFileName;\r\n\t\t}\r\n\t\tif (!System.IO.File.Exists(strFilename))\r\n\t\t{\r\n\t\t\tInterface.CallHook(\"OnNewSave\", strFilename);\r\n\t\t\tif (!System.IO.File.Exists(\"TestSaves/\" + strFilename))\r\n\t\t\t{\r\n\t\t\t\tUnityEngine.Debug.LogWarning(\"Couldn't load \" + strFilename + \" - file doesn't exist\");\r\n\t\t\t\tresult = false;\r\n\t\t\t\treturn result;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "IOnServerShutdown",
      "HookName": "IOnServerShutdown",
      "HookParameters": {},
      "ReturnBehavior": 0,
      "TargetType": "ServerMgr",
      "Category": "Server",
      "MethodData": {
        "MethodName": "Shutdown",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "internal void Shutdown()\r\n{\r\n\tInterface.CallHook(\"IOnServerShutdown\");\r\n\tglobal::BasePlayer[] array = global::BasePlayer.activePlayerList.ToArray<global::BasePlayer>();\r\n\tfor (int i = 0; i < array.Length; i++)\r\n\t{\r\n\t\tarray[i].Kick(\"Server Shutting Down\");\r\n\t}\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSaveLoad",
      "HookName": "OnSaveLoad",
      "HookParameters": {
        "result": "Dictionary`2"
      },
      "ReturnBehavior": 1,
      "TargetType": "SaveRestore",
      "Category": "Server",
      "MethodData": {
        "MethodName": "Load",
        "ReturnType": "bool",
        "Arguments": {
          "strFilename": "string",
          "allowOutOfDateSaves": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t{\r\n\t\t\tstrFilename = global::World.SaveFolderName + \"/\" + global::World.SaveFileName;\r\n\t\t}\r\n\t\tif (!System.IO.File.Exists(strFilename))\r\n\t\t{\r\n\t\t\tInterface.CallHook(\"OnNewSave\", strFilename);\r\n\t\t\tif (!System.IO.File.Exists(\"TestSaves/\" + strFilename))\r\n\t\t\t{\r\n\t\t\t\tUnityEngine.Debug.LogWarning(\"Couldn't load \" + strFilename + \" - file doesn't exist\");\r\n\t\t\t\tresult = false;\r\n\t\t\t\treturn result;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerSpectate",
      "HookName": "OnPlayerSpectate",
      "HookParameters": {
        "instance": "BasePlayer",
        "spectateFilter": "string"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "StartSpectating",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (this.IsSpectating())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnPlayerSpectate\", this, this.spectateFilter) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.SetPlayerFlag(global::BasePlayer.PlayerFlags.Spectating, true);\r\n\tbase.gameObject.SetLayerRecursive(10);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerSpectateEnd",
      "HookName": "OnPlayerSpectateEnd",
      "HookParameters": {
        "instance": "BasePlayer",
        "spectateFilter": "string"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "StopSpectating",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (!this.IsSpectating())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnPlayerSpectateEnd\", this, this.spectateFilter) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.SetParent(null, false, false);\r\n\tthis.SetPlayerFlag(global::BasePlayer.PlayerFlags.Spectating, false);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerHealthChange",
      "HookName": "OnPlayerHealthChange",
      "HookParameters": {
        "instance": "BasePlayer",
        "oldvalue": "float",
        "newvalue": "float"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "OnHealthChanged",
        "ReturnType": "void",
        "Arguments": {
          "oldvalue": "float",
          "newvalue": "float"
        }
      },
      "CodeAfterInjection": "public override void OnHealthChanged(float oldvalue, float newvalue)\r\n{\r\n\tif (Interface.CallHook(\"OnPlayerHealthChange\", this, oldvalue, newvalue) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.OnHealthChanged(oldvalue, newvalue);\r\n\tif (!base.isServer)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTurretStartup",
      "HookName": "OnTurretStartup",
      "HookParameters": {
        "instance": "AutoTurret"
      },
      "ReturnBehavior": 1,
      "TargetType": "AutoTurret",
      "Category": "Turret",
      "MethodData": {
        "MethodName": "InitiateStartup",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (this.IsOnline() || this.booting)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnTurretStartup\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::Effect.server.Run(this.onlineSound.resourcePath, this, 0u, Vector3.zero, Vector3.zero, null, false);\r\n\tbase.Invoke(new System.Action(this.SetOnline), 2f);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTurretShutdown",
      "HookName": "OnTurretShutdown",
      "HookParameters": {
        "instance": "AutoTurret"
      },
      "ReturnBehavior": 1,
      "TargetType": "AutoTurret",
      "Category": "Turret",
      "MethodData": {
        "MethodName": "InitiateShutdown",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (this.IsOffline() && !this.booting)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnTurretShutdown\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.CancelInvoke(new System.Action(this.SetOnline));\r\n\tthis.booting = false;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTurretToggle",
      "HookName": "OnTurretToggle",
      "HookParameters": {
        "instance": "AutoTurret"
      },
      "ReturnBehavior": 1,
      "TargetType": "AutoTurret",
      "Category": "Turret",
      "MethodData": {
        "MethodName": "SetIsOnline",
        "ReturnType": "void",
        "Arguments": {
          "online": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (online == base.HasFlag(global::BaseEntity.Flags.On))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnTurretToggle\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.SetFlag(global::BaseEntity.Flags.On, online, false, true);\r\n\tthis.booting = false;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerSleep",
      "HookName": "OnPlayerSleep",
      "HookParameters": {
        "instance": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "StartSleeping",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (this.IsSleeping())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tInterface.CallHook(\"OnPlayerSleep\", this);\r\n\tif (this.InSafeZone() && !base.IsInvoking(new System.Action(this.ScheduledDeath)))\r\n\t{\r\n\t\tbase.Invoke(new System.Action(this.ScheduledDeath), global::NPCAutoTurret.sleeperhostiledelay);\r\n\t}\r\n\tglobal::BaseMountable baseMountable = this.GetMounted();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerDeath",
      "HookName": "OnPlayerDeath",
      "HookParameters": {
        "instance": "BasePlayer",
        "info": "HitInfo"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "Die",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t\t\tVector3 vector = new Vector3(UnityEngine.Random.Range(-2f, 2f), 0.2f, UnityEngine.Random.Range(-2f, 2f));\r\n\t\t\t\tthis.Belt.DropActive(this.GetDropPosition(), this.GetInheritedDropVelocity() + vector.normalized * 3f);\r\n\t\t\t}\r\n\t\t\tif (!this.WoundInsteadOfDying(info))\r\n\t\t\t{\r\n\t\t\t\tif (Interface.CallHook(\"OnPlayerDeath\", this, info) != null)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tglobal::SleepingBag.OnPlayerDeath(this);\r\n\t\t\t\tbase.Die(info);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerRevive",
      "HookName": "OnPlayerRevive",
      "HookParameters": {
        "GetOwnerPlayer()": "BasePlayer",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "MedicalTool",
      "Category": "Player",
      "MethodData": {
        "MethodName": "GiveEffectsTo",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (!component)\r\n\t{\r\n\t\tDebug.LogWarning(\"No consumable for medicaltool :\" + base.name);\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnHealingItemUse\", this, player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::BasePlayer ownerPlayer = base.GetOwnerPlayer();\r\n\tFacepunch.Rust.Analytics.Azure.OnMedUsed(ownerItemDefinition.shortname, ownerPlayer, player);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnOvenToggle",
      "HookName": "OnOvenToggle",
      "HookDescription": "Called when an oven (Campfire, Furnace,...) is turned on or off",
      "HookParameters": {
        "instance": "BaseOven",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseOven",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "SVSwitch",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.MaxDistance(3f)]\r\nprotected virtual void SVSwitch(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tbool flag = msg.read.Bit();\r\n\tif (Interface.CallHook(\"OnOvenToggle\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (flag == base.IsOn())\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTrapTrigger [BearTrap]",
      "HookName": "OnTrapTrigger",
      "HookParameters": {
        "instance": "BearTrap",
        "obj": "GameObject"
      },
      "ReturnBehavior": 1,
      "TargetType": "BearTrap",
      "Category": "Traps",
      "MethodData": {
        "MethodName": "ObjectEntered",
        "ReturnType": "void",
        "Arguments": {
          "obj": "UnityEngine.GameObject"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (!this.Armed())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnTrapTrigger\", this, obj) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.hurtTarget = obj;\r\n\tbase.Invoke(new System.Action(this.DelayedFire), 0.05f);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTrapTrigger [Landmine]",
      "HookName": "OnTrapTrigger",
      "HookParameters": {
        "instance": "Landmine",
        "obj": "GameObject"
      },
      "ReturnBehavior": 1,
      "TargetType": "Landmine",
      "Category": "Traps",
      "MethodData": {
        "MethodName": "ObjectEntered",
        "ReturnType": "void",
        "Arguments": {
          "obj": "UnityEngine.GameObject"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\tbase.CancelInvoke(new System.Action(this.Arm));\r\n\t\tthis.blocked = true;\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnTrapTrigger\", this, obj) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::BasePlayer ply = obj.ToBaseEntity() as global::BasePlayer;\r\n\tthis.Trigger(ply);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTerrainInitialized",
      "HookName": "OnTerrainInitialized",
      "HookParameters": {},
      "ReturnBehavior": 0,
      "TargetType": "TerrainMeta",
      "Category": "World",
      "MethodData": {
        "MethodName": "PostSetupComponents",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tglobal::TerrainExtension[] components = base.GetComponents<global::TerrainExtension>();\r\n\tfor (int i = 0; i < components.Length; i++)\r\n\t{\r\n\t\tcomponents[i].PostSetup();\r\n\t}\r\n\tInterface.CallHook(\"OnTerrainInitialized\");\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "CanBeTargeted [FlameTurret]",
      "HookName": "CanBeTargeted",
      "HookParameters": {
        "component": "BasePlayer",
        "instance": "FlameTurret"
      },
      "ReturnBehavior": 1,
      "TargetType": "FlameTurret",
      "Category": "Player",
      "MethodData": {
        "MethodName": "CheckTrigger",
        "ReturnType": "bool",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\t\twhile (enumerator.MoveNext())\r\n\t\t\t{\r\n\t\t\t\tglobal::BasePlayer component = enumerator.Current.GetComponent<global::BasePlayer>();\r\n\t\t\t\tif (!component.IsSleeping() && component.IsAlive())\r\n\t\t\t\t{\r\n\t\t\t\t\tobject returnvar = Interface.CallHook(\"CanBeTargeted\", component, this);\r\n\t\t\t\t\tif (returnvar is bool)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tPool.FreeList<RaycastHit>(ref list);\r\n\t\t\t\t\t\treturn (bool)returnvar;\r\n\t\t\t\t\t}\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFindBurnable",
      "HookName": "OnFindBurnable",
      "HookParameters": {
        "instance": "BaseOven"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseOven",
      "Category": "Item",
      "MethodData": {
        "MethodName": "FindBurnable",
        "ReturnType": "Item",
        "Arguments": {}
      },
      "CodeAfterInjection": "public global::Item FindBurnable()\r\n{\r\n\tobject returnvar = Interface.CallHook(\"OnFindBurnable\", this);\r\n\tif (returnvar is global::Item)\r\n\t{\r\n\t\treturn (global::Item)returnvar;\r\n\t}\r\n\tif (base.inventory == null)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanStackItem",
      "HookName": "CanStackItem",
      "HookParameters": {
        "instance": "Item",
        "item": "Item"
      },
      "ReturnBehavior": 1,
      "TargetType": "Item",
      "Category": "Item",
      "MethodData": {
        "MethodName": "CanStack",
        "ReturnType": "bool",
        "Arguments": {
          "item": "Item"
        }
      },
      "CodeAfterInjection": "public bool CanStack(global::Item item)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanStackItem\", this, item);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif (item == this)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnExplosiveDropped",
      "HookName": "OnExplosiveDropped",
      "HookParameters": {
        "player": "BasePlayer",
        "baseEntity": "BaseEntity",
        "instance": "ThrownWeapon"
      },
      "ReturnBehavior": 0,
      "TargetType": "ThrownWeapon",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "DoDrop",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tbaseEntity.creatorEntity = msg.player;\r\n\tbaseEntity.skinID = this.skinID;\r\n\tbaseEntity.Spawn();\r\n\tthis.SetUpThrownWeapon(baseEntity);\r\n\tbase.StartAttackCooldown(this.repeatDelay);\r\n\tInterface.CallHook(\"OnExplosiveDropped\", msg.player, baseEntity, this);\r\n\tbase.UseItemAmount(1);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBuyVendingItem",
      "HookName": "OnBuyVendingItem",
      "HookParameters": {
        "instance": "VendingMachine",
        "player": "BasePlayer",
        "num": "int",
        "num2": "int"
      },
      "ReturnBehavior": 1,
      "TargetType": "VendingMachine",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "BuyItem",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (this.IsVending())\r\n\t{\r\n\t\trpc.player.ShowToast(global::GameTip.Styles.Red_Normal, global::VendingMachine.WaitForVendingMessage, System.Array.Empty<string>());\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnBuyVendingItem\", this, rpc.player, num, num2) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.SetPendingOrder(rpc.player, num, num2);\r\n\tbase.Invoke(new System.Action(this.CompletePendingOrder), this.GetBuyDuration());\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanUseVending",
      "HookName": "CanUseVending",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "VendingMachine"
      },
      "ReturnBehavior": 1,
      "TargetType": "VendingMachine",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "CanOpenLootPanel",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer",
          "panelName": "string"
        }
      },
      "CodeAfterInjection": "public override bool CanOpenLootPanel(global::BasePlayer player, string panelName)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanUseVending\", player, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn panelName == this.customerPanel || (base.CanOpenLootPanel(player, panelName) && this.CanPlayerAdmin(player));\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanAdministerVending",
      "HookName": "CanAdministerVending",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "VendingMachine"
      },
      "ReturnBehavior": 1,
      "TargetType": "VendingMachine",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "CanPlayerAdmin",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public virtual bool CanPlayerAdmin(global::BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanAdministerVending\", player, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn this.PlayerBehind(player) && base.OccupiedCheck(player);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRefreshVendingStock",
      "HookName": "OnRefreshVendingStock",
      "HookParameters": {
        "instance": "VendingMachine",
        "itemDef": "ItemDefinition"
      },
      "ReturnBehavior": 0,
      "TargetType": "VendingMachine",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "RefreshSellOrderStockLevel",
        "ReturnType": "void",
        "Arguments": {
          "itemDef": "ItemDefinition"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t\t\tSystem.Func<global::Item, int> arg_80_1;\r\n\t\t\t\tif ((arg_80_1 = global::VendingMachine.<>c.<>9__18_0) == null)\r\n\t\t\t\t{\r\n\t\t\t\t\targ_80_1 = (global::VendingMachine.<>c.<>9__18_0 = new System.Func<global::Item, int>(global::VendingMachine.<>c.<>9.<RefreshSellOrderStockLevel>b__18_0));\r\n\t\t\t\t}\r\n\t\t\t\tInterface.CallHook(\"OnRefreshVendingStock\", this, itemDef);\r\n\t\t\t\targ_8C_1 = arg_80_0.Sum(arg_80_1) / current.itemToSellAmount;\r\n\t\t\t}\r\n\t\t\targ_8C_0.inStock = arg_8C_1;\r\n\t\t\tfloat itemCondition = 0f;\r\n\t\t\tfloat itemConditionMax = 0f;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnToggleVendingBroadcast",
      "HookName": "OnToggleVendingBroadcast",
      "HookParameters": {
        "instance": "VendingMachine",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "VendingMachine",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "RPC_Broadcast",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tglobal::BasePlayer player = msg.player;\r\n\tbool b = msg.read.Bit();\r\n\tif (this.CanPlayerAdmin(player))\r\n\t{\r\n\t\tbase.SetFlag(global::BaseEntity.Flags.Reserved4, b, false, true);\r\n\t\tInterface.CallHook(\"OnToggleVendingBroadcast\", this, player);\r\n\t\tthis.UpdateMapMarker();\r\n\t}\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnDeleteVendingOffer",
      "HookName": "OnDeleteVendingOffer",
      "HookParameters": {
        "instance": "VendingMachine",
        "num": "int"
      },
      "ReturnBehavior": 0,
      "TargetType": "VendingMachine",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "RPC_DeleteSellOrder",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (!this.CanPlayerAdmin(player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tint num = msg.read.Int32();\r\n\tInterface.CallHook(\"OnDeleteVendingOffer\", this, num);\r\n\tif (num >= 0 && num < this.sellOrders.sellOrders.Count)\r\n\t{\r\n\t\tProtoBuf.VendingMachine.SellOrder sellOrder = this.sellOrders.sellOrders[num];\r\n\t\tFacepunch.Rust.Analytics.Azure.OnVendingMachineOrderChanged(msg.player, this, sellOrder.itemToSellID, sellOrder.itemToSellAmount, sellOrder.itemToSellIsBP, sellOrder.currencyID, sellOrder.currencyAmountPerItem, sellOrder.currencyIsBP, false);\r\n\t\tthis.sellOrders.sellOrders.RemoveAt(num);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnOpenVendingAdmin",
      "HookName": "OnOpenVendingAdmin",
      "HookParameters": {
        "instance": "VendingMachine",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "VendingMachine",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "RPC_OpenAdmin",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t\treturn;\r\n\t}\r\n\tthis.SendSellOrders(player);\r\n\tthis.PlayerOpenLoot(player, \"\", true);\r\n\tbase.ClientRPCPlayer(null, player, \"CLIENT_OpenAdminMenu\");\r\n\tInterface.CallHook(\"OnOpenVendingAdmin\", this, player);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnVendingShopOpen [VendingMachine]",
      "HookName": "OnVendingShopOpen",
      "HookParameters": {
        "instance": "VendingMachine",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "VendingMachine",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "RPC_OpenShop",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (!base.OccupiedCheck(msg.player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnVendingShopOpen\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.SendSellOrders(msg.player);\r\n\tthis.PlayerOpenLoot(msg.player, this.customerPanel, true);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRotateVendingMachine",
      "HookName": "OnRotateVendingMachine",
      "HookParameters": {
        "instance": "VendingMachine",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "VendingMachine",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "RPC_RotateVM",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void RPC_RotateVM(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tif (Interface.CallHook(\"OnRotateVendingMachine\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!this.CanRotate())\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanPickupEntity",
      "HookName": "CanPickupEntity",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "BaseCombatEntity"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseCombatEntity",
      "Category": "Player",
      "MethodData": {
        "MethodName": "CanPickup",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public virtual bool CanPickup(global::BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanPickupEntity\", player, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn this.pickup.enabled && (!this.pickup.requireBuildingPrivilege || player.CanBuild()) && (!this.pickup.requireHammer || player.IsHoldingEntity<global::Hammer>());\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnServerUserSet",
      "HookName": "OnServerUserSet",
      "HookParameters": {
        "uid": "UInt64",
        "group": "UserGroup",
        "username": "String",
        "notes": "String",
        "expiry": "Int64"
      },
      "ReturnBehavior": 0,
      "TargetType": "ServerUsers",
      "Category": "Server",
      "MethodData": {
        "MethodName": "Set",
        "ReturnType": "void",
        "Arguments": {
          "uid": "ulong",
          "group": "ServerUsers/UserGroup",
          "username": "string",
          "notes": "string",
          "expiry": "long"
        }
      },
      "CodeAfterInjection": "...\r\n\t\tgroup = group,\r\n\t\tusername = username,\r\n\t\tnotes = notes,\r\n\t\texpiry = expiry\r\n\t};\r\n\tInterface.CallHook(\"OnServerUserSet\", uid, group, username, notes, expiry);\r\n\tglobal::ServerUsers.users.Add(uid, value);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnServerSave",
      "HookName": "OnServerSave",
      "HookParameters": {},
      "ReturnBehavior": 0,
      "TargetType": "SaveRestore",
      "Category": "Server",
      "MethodData": {
        "MethodName": "DoAutomatedSave",
        "ReturnType": "System.Collections.IEnumerator",
        "Arguments": {
          "AndWait": "bool"
        }
      },
      "CodeAfterInjection": "[System.Runtime.CompilerServices.IteratorStateMachine(typeof(global::SaveRestore.<DoAutomatedSave>d__19))]\r\nprivate System.Collections.IEnumerator DoAutomatedSave(bool AndWait = false)\r\n{\r\n\tInterface.CallHook(\"OnServerSave\");\r\n\tglobal::SaveRestore.<DoAutomatedSave>d__19 expr_11 = new global::SaveRestore.<DoAutomatedSave>d__19(0);\r\n\texpr_11.<>4__this = this;\r\n\texpr_11.AndWait = AndWait;\r\n\treturn expr_11;\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemAction",
      "HookName": "OnItemAction",
      "HookParameters": {
        "item": "Item",
        "text": "string",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "PlayerInventory",
      "Category": "Item",
      "MethodData": {
        "MethodName": "ItemCmd",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tglobal::Item item = this.FindItemUID(id);\r\n\tif (item == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnItemAction\", item, text, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (item.IsLocked() || (item.parent != null && item.parent.IsLocked()))\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanAssignBed",
      "HookName": "CanAssignBed",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "SleepingBag",
        "num": "ulong"
      },
      "ReturnBehavior": 1,
      "TargetType": "SleepingBag",
      "Category": "Player",
      "MethodData": {
        "MethodName": "AssignToFriend",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tulong num = msg.read.UInt64();\r\n\tif (num == 0uL)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanAssignBed\", msg.player, this, num) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (ConVar.Server.max_sleeping_bags > 0)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCodeEntered",
      "HookName": "OnCodeEntered",
      "HookParameters": {
        "instance": "CodeLock",
        "player": "BasePlayer",
        "text": "string"
      },
      "ReturnBehavior": 1,
      "TargetType": "CodeLock",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "UnlockWithCode",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (this.IsCodeEntryBlocked())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tstring text = rpc.read.String(256);\r\n\tif (Interface.CallHook(\"OnCodeEntered\", this, rpc.player, text) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbool flag = text == this.guestCode;\r\n\tbool flag2 = text == this.code;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanUnlock [CodeLock]",
      "HookName": "CanUnlock",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "CodeLock"
      },
      "ReturnBehavior": 1,
      "TargetType": "CodeLock",
      "Category": "Player",
      "MethodData": {
        "MethodName": "TryUnlock",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (!base.IsLocked())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanUnlock\", rpc.player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.IsCodeEntryBlocked())\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanLock [code]",
      "HookName": "CanLock",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "CodeLock"
      },
      "ReturnBehavior": 1,
      "TargetType": "CodeLock",
      "Category": "Player",
      "MethodData": {
        "MethodName": "TryLock",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (this.code.Length != 4)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanLock\", rpc.player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!this.whitelistPlayers.Contains(rpc.player.userID))\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanChangeCode",
      "HookName": "CanChangeCode",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "CodeLock",
        "text": "string",
        "flag": "bool"
      },
      "ReturnBehavior": 1,
      "TargetType": "CodeLock",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RPC_ChangeCode",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (!this.hasCode & flag)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanChangeCode\", rpc.player, this, text, flag) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!this.hasCode && !flag)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanUnlock [KeyLock]",
      "HookName": "CanUnlock",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "KeyLock"
      },
      "ReturnBehavior": 1,
      "TargetType": "KeyLock",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RPC_Unlock",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (!base.IsLocked())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanUnlock\", rpc.player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!this.HasLockPermission(rpc.player))\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRecyclerToggle",
      "HookName": "OnRecyclerToggle",
      "HookDescription": "Called when a recycler is turned on or off",
      "HookParameters": {
        "instance": "Recycler",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "Recycler",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "SVSwitch",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (msg.player == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnRecyclerToggle\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (flag && !this.HasRecyclable())\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanRecycle",
      "HookName": "CanRecycle",
      "HookDescription": "Called when the recycler attempts to recycle an item",
      "HookParameters": {
        "instance": "Recycler",
        "slot": "Item"
      },
      "ReturnBehavior": 1,
      "TargetType": "Recycler",
      "Category": "Crafting",
      "MethodData": {
        "MethodName": "HasRecyclable",
        "ReturnType": "bool",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tfor (int i = 0; i < 6; i++)\r\n\t{\r\n\t\tglobal::Item slot = base.inventory.GetSlot(i);\r\n\t\tif (slot != null)\r\n\t\t{\r\n\t\t\tobject returnvar = Interface.CallHook(\"CanRecycle\", this, slot);\r\n\t\t\tif (returnvar is bool)\r\n\t\t\t{\r\n\t\t\t\treturn (bool)returnvar;\r\n\t\t\t}\r\n\t\t\tif (slot.info.Blueprint != null)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemRecycle",
      "HookName": "OnItemRecycle",
      "HookParameters": {
        "slot": "Item",
        "instance": "Recycler"
      },
      "ReturnBehavior": 1,
      "TargetType": "Recycler",
      "Category": "Item",
      "MethodData": {
        "MethodName": "RecycleThink",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tfor (int i = 0; i < 6; i++)\r\n\t{\r\n\t\tglobal::Item slot = base.inventory.GetSlot(i);\r\n\t\tif (this.CanBeRecycled(slot))\r\n\t\t{\r\n\t\t\tif (Interface.CallHook(\"OnItemRecycle\", slot, this) != null)\r\n\t\t\t{\r\n\t\t\t\tif (!base.HasRecyclable())\r\n\t\t\t\t{\r\n\t\t\t\t\tbase.StopRecycling();\r\n\t\t\t\t\treturn;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTurretDeauthorize",
      "HookName": "OnTurretDeauthorize",
      "HookParameters": {
        "instance": "AutoTurret",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "AutoTurret",
      "Category": "Turret",
      "MethodData": {
        "MethodName": "RemoveSelfAuthorize",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tglobal::BaseEntity.RPCMessage rpc = rpc2;\r\n\tif (this.booting || this.IsOnline() || !this.IsAuthed(rpc.player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnTurretDeauthorize\", this, rpc2.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.authorizedPlayers.RemoveAll((PlayerNameID x) => x.userid == rpc.player.userID);\r\n\tglobal::BasePlayer arg_A9_1 = rpc.player;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanSetBedPublic",
      "HookName": "CanSetBedPublic",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "SleepingBag"
      },
      "ReturnBehavior": 1,
      "TargetType": "SleepingBag",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RPC_MakePublic",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tbool flag = msg.read.Bit();\r\n\tif (flag == this.IsPublic())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanSetBedPublic\", msg.player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.SetPublic(flag);\r\n\tif (!this.IsPublic())\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanCraft [ItemCrafter]",
      "HookName": "CanCraft",
      "HookDescription": "Called when an ItemCrafter attempts to craft an item",
      "HookParameters": {
        "instance": "ItemCrafter",
        "bp": "ItemBlueprint",
        "amount": "Int32",
        "free": "Boolean"
      },
      "ReturnBehavior": 1,
      "TargetType": "ItemCrafter",
      "Category": "Crafting",
      "MethodData": {
        "MethodName": "CanCraft",
        "ReturnType": "bool",
        "Arguments": {
          "bp": "ItemBlueprint",
          "amount": "int",
          "free": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (amount < 1 || amount > bp.targetItem.craftingStackable)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"CanCraft\", this, bp, amount, free);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tforeach (global::ItemAmount current2 in bp.ingredients)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanHelicopterStrafeTarget",
      "HookName": "CanHelicopterStrafeTarget",
      "HookParameters": {
        "instance": "PatrolHelicopterAI",
        "ply": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "PatrolHelicopterAI",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "ValidStrafeTarget",
        "ReturnType": "bool",
        "Arguments": {
          "ply": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public bool ValidStrafeTarget(global::BasePlayer ply)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanHelicopterStrafeTarget\", this, ply);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn !ply.IsNearEnemyBase();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemDropped",
      "HookName": "OnItemDropped",
      "HookParameters": {
        "instance": "Item",
        "baseEntity": "BaseEntity"
      },
      "ReturnBehavior": 0,
      "TargetType": "Item",
      "Category": "Item",
      "MethodData": {
        "MethodName": "Drop",
        "ReturnType": "BaseEntity",
        "Arguments": {
          "vPos": "UnityEngine.Vector3",
          "vVelocity": "UnityEngine.Vector3",
          "rotation": "UnityEngine.Quaternion"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\telse\r\n\t{\r\n\t\tthis.Remove(0f);\r\n\t}\r\n\tInterface.CallHook(\"OnItemDropped\", this, baseEntity);\r\n\tthis.RemoveFromContainer();\r\n\treturn baseEntity;\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "CanMoveItem",
      "HookName": "CanMoveItem",
      "HookParameters": {
        "item": "Item",
        "instance": "PlayerInventory",
        "itemContainerId": "ItemContainerId",
        "num": "int",
        "num2": "int",
        "flag": "bool"
      },
      "ReturnBehavior": 1,
      "TargetType": "PlayerInventory",
      "Category": "Item",
      "MethodData": {
        "MethodName": "MoveItem",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (item == null)\r\n\t{\r\n\t\tmsg.player.ChatMessage(\"Invalid item (\" + itemId + \")\");\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanMoveItem\", item, this, itemContainerId, num, num2, flag) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::BaseEntity entityOwner = item.GetEntityOwner();\r\n\tif (!this.CanMoveItemsFrom(entityOwner, item))\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanHideStash",
      "HookName": "CanHideStash",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "StashContainer"
      },
      "ReturnBehavior": 1,
      "TargetType": "StashContainer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RPC_HideStash",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void RPC_HideStash(global::BaseEntity.RPCMessage rpc)\r\n{\r\n\tif (Interface.CallHook(\"CanHideStash\", rpc.player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tFacepunch.Rust.Analytics.Azure.OnStashHidden(rpc.player, this);\r\n\tthis.SetHidden(true);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanCombineDroppedItem",
      "HookName": "CanCombineDroppedItem",
      "HookParameters": {
        "instance": "DroppedItem",
        "di": "DroppedItem"
      },
      "ReturnBehavior": 1,
      "TargetType": "DroppedItem",
      "Category": "Item",
      "MethodData": {
        "MethodName": "OnDroppedOn",
        "ReturnType": "void",
        "Arguments": {
          "di": "DroppedItem"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (di.item == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanCombineDroppedItem\", this, di) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (di.item.info != this.item.info)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnItemRecycle [2]",
      "HookName": "OnItemRecycle",
      "ReturnBehavior": 0,
      "TargetType": "Recycler",
      "Category": "Item",
      "MethodData": {
        "MethodName": "RecycleThink",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tfor (int i = 0; i < 6; i++)\r\n\t{\r\n\t\tglobal::Item slot = base.inventory.GetSlot(i);\r\n\t\tif (this.CanBeRecycled(slot))\r\n\t\t{\r\n\t\t\tif (Interface.CallHook(\"OnItemRecycle\", slot, this) != null)\r\n\t\t\t{\r\n\t\t\t\tif (!base.HasRecyclable())\r\n\t\t\t\t{\r\n\t\t\t\t\tbase.StopRecycling();\r\n\t\t\t\t\treturn;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnContainerDropItems",
      "HookName": "OnContainerDropItems",
      "HookDescription": "Called when a container is destroyed and all items are about to be dropped",
      "HookParameters": {
        "container": "ItemContainer"
      },
      "ReturnBehavior": 1,
      "TargetType": "DropUtil",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "DropItems",
        "ReturnType": "void",
        "Arguments": {
          "container": "ItemContainer",
          "position": "UnityEngine.Vector3"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (container.itemList == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnContainerDropItems\", container) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat num = 0.25f;\r\n\tglobal::Item[] array = container.itemList.ToArray();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanNpcEat [BaseNpc]",
      "HookName": "CanNpcEat",
      "HookParameters": {
        "instance": "BaseNpc",
        "best": "BaseEntity"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseNpc",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "WantsToEat",
        "ReturnType": "bool",
        "Arguments": {
          "best": "BaseEntity"
        }
      },
      "CodeAfterInjection": "public virtual bool WantsToEat(global::BaseEntity best)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanNpcEat\", this, best);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn best.HasTrait(global::BaseEntity.TraitFlag.Food) && !best.HasTrait(global::BaseEntity.TraitFlag.Alive);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnNpcAttack [BaseNpc]",
      "HookName": "OnNpcAttack",
      "HookParameters": {
        "instance": "BaseNpc",
        "AttackTarget": "BaseEntity"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseNpc",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "StartAttack",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (!this.AttackReady())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnNpcAttack\", this, this.AttackTarget) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif ((this.AttackTarget.ServerPosition - this.ServerPosition).magnitude > this.AttackRange)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMeleeAttack",
      "HookName": "OnMeleeAttack",
      "HookParameters": {
        "player": "BasePlayer",
        "hitInfo": "HitInfo"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseMelee",
      "Category": "Player",
      "MethodData": {
        "MethodName": "PlayerAttack",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t\t\thitInfo.Initiator = player;\r\n\t\t\t\thitInfo.Weapon = this;\r\n\t\t\t\thitInfo.WeaponPrefab = this;\r\n\t\t\t\thitInfo.Predicted = msg.connection;\r\n\t\t\t\thitInfo.damageProperties = this.damageProperties;\r\n\t\t\t\tif (Interface.CallHook(\"OnMeleeAttack\", player, hitInfo) != null)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tif (hitInfo.IsNaNOrInfinity())\r\n\t\t\t\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerViolation",
      "HookName": "OnPlayerViolation",
      "HookParameters": {
        "ply": "BasePlayer",
        "type": "AntiHackType",
        "amount": "Single"
      },
      "ReturnBehavior": 1,
      "TargetType": "AntiHack",
      "Category": "Player",
      "MethodData": {
        "MethodName": "AddViolation",
        "ReturnType": "void",
        "Arguments": {
          "ply": "BasePlayer",
          "type": "AntiHackType",
          "amount": "float"
        }
      },
      "CodeAfterInjection": "public static void AddViolation(global::BasePlayer ply, global::AntiHackType type, float amount)\r\n{\r\n\tif (Interface.CallHook(\"OnPlayerViolation\", ply, type, amount) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tusing (TimeWarning.New(\"AntiHack.AddViolation\", 0))\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanChangeGrade",
      "HookName": "CanChangeGrade",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "BuildingBlock",
        "iGrade": "Enum",
        "iSkin": "ulong"
      },
      "ReturnBehavior": 1,
      "TargetType": "BuildingBlock",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "CanChangeToGrade",
        "ReturnType": "bool",
        "Arguments": {
          "iGrade": "BuildingGrade/Enum",
          "iSkin": "ulong",
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "private bool CanChangeToGrade(global::BuildingGrade.Enum iGrade, ulong iSkin, global::BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanChangeGrade\", player, this, iGrade, iSkin);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn this.HasUpgradePrivilege(iGrade, iSkin, player) && !this.IsUpgradeBlocked();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanAffordUpgrade",
      "HookName": "CanAffordUpgrade",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "BuildingBlock",
        "iGrade": "Enum",
        "iSkin": "ulong"
      },
      "ReturnBehavior": 1,
      "TargetType": "BuildingBlock",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "CanAffordUpgrade",
        "ReturnType": "bool",
        "Arguments": {
          "iGrade": "BuildingGrade/Enum",
          "iSkin": "ulong",
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "private bool CanAffordUpgrade(global::BuildingGrade.Enum iGrade, ulong iSkin, global::BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanAffordUpgrade\", player, this, iGrade, iSkin);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tforeach (global::ItemAmount current in this.blockDefinition.GetGrade(iGrade, iSkin).CostToBuild(this.grade))\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanDemolish",
      "HookName": "CanDemolish",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "BuildingBlock"
      },
      "ReturnBehavior": 1,
      "TargetType": "BuildingBlock",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "CanDemolish",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "private bool CanDemolish(global::BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanDemolish\", player, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn this.IsDemolishable() && this.HasDemolishPrivilege(player);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanUseMailbox",
      "HookName": "CanUseMailbox",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "Mailbox"
      },
      "ReturnBehavior": 1,
      "TargetType": "Mailbox",
      "Category": "Player",
      "MethodData": {
        "MethodName": "PlayerIsOwner",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public virtual bool PlayerIsOwner(global::BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanUseMailbox\", player, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn player.CanBuild();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSpinWheel",
      "HookName": "OnSpinWheel",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "SpinnerWheel"
      },
      "ReturnBehavior": 1,
      "TargetType": "SpinnerWheel",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RPC_Spin",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.AnyoneSpin() || rpc.player.CanBuild())\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnSpinWheel\", rpc.player, this) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (this.velocity > 15f)\r\n\t\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanBeTargeted [GunTrap]",
      "HookName": "CanBeTargeted",
      "HookParameters": {
        "component": "BasePlayer",
        "instance": "GunTrap"
      },
      "ReturnBehavior": 1,
      "TargetType": "GunTrap",
      "Category": "Player",
      "MethodData": {
        "MethodName": "CheckTrigger",
        "ReturnType": "bool",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\t\twhile (enumerator.MoveNext())\r\n\t\t\t{\r\n\t\t\t\tglobal::BasePlayer component = enumerator.Current.GetComponent<global::BasePlayer>();\r\n\t\t\t\tif (!component.IsSleeping() && component.IsAlive())\r\n\t\t\t\t{\r\n\t\t\t\t\tobject returnvar = Interface.CallHook(\"CanBeTargeted\", component, this);\r\n\t\t\t\t\tif (returnvar is bool)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tPool.FreeList<RaycastHit>(ref list);\r\n\t\t\t\t\t\treturn (bool)returnvar;\r\n\t\t\t\t\t}\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "IOnRconInitialize",
      "HookName": "IOnRconInitialize",
      "HookParameters": {},
      "ReturnBehavior": 1,
      "TargetType": "Facepunch.RCon",
      "Category": "Server",
      "MethodData": {
        "MethodName": "Initialize",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public static void Initialize()\r\n{\r\n\tif (Interface.CallHook(\"IOnRconInitialize\") != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (RCon.Port == 0)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMaxStackable",
      "HookName": "OnMaxStackable",
      "HookParameters": {
        "instance": "Item"
      },
      "ReturnBehavior": 1,
      "TargetType": "Item",
      "Category": "Item",
      "MethodData": {
        "MethodName": "MaxStackable",
        "ReturnType": "int",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tint num = this.info.stackable;\r\n\tif (this.parent != null && this.parent.maxStackSize > 0)\r\n\t{\r\n\t\tnum = Mathf.Min(this.parent.maxStackSize, num);\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"OnMaxStackable\", this);\r\n\tif (returnvar is int)\r\n\t{\r\n\t\treturn (int)returnvar;\r\n\t}\r\n\treturn num;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnWeaponReload",
      "HookName": "OnWeaponReload",
      "HookParameters": {
        "instance": "BaseProjectile",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseProjectile",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "StartReload",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t\tbase.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);\r\n\t\tthis.reloadStarted = false;\r\n\t\tthis.reloadFinished = false;\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnWeaponReload\", this, player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.reloadFinished = false;\r\n\tthis.reloadStarted = true;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMagazineReload",
      "HookName": "OnMagazineReload",
      "HookParameters": {
        "instance": "BaseProjectile",
        "desiredAmount": "int",
        "ownerPlayer": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseProjectile",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "ReloadMagazine",
        "ReturnType": "void",
        "Arguments": {
          "desiredAmount": "int"
        }
      },
      "CodeAfterInjection": "...\r\n\tglobal::BasePlayer ownerPlayer = base.GetOwnerPlayer();\r\n\tif (!ownerPlayer)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnMagazineReload\", this, desiredAmount, ownerPlayer) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.primaryMagazine.Reload(ownerPlayer, desiredAmount, true);\r\n\tbase.SendNetworkUpdateImmediate(false);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerRespawn",
      "HookName": "OnPlayerRespawn",
      "HookParameters": {
        "instance": "BasePlayer",
        "spawnPoint": "SpawnPoint"
      },
      "ReturnBehavior": 3,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "Respawn",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tglobal::BasePlayer.SpawnPoint spawnPoint = global::ServerMgr.FindSpawnPoint(this);\r\n\tif (ConVar.Server.respawnAtDeathPosition && this.ServerCurrentDeathNote != null)\r\n\t{\r\n\t\tspawnPoint.pos = this.ServerCurrentDeathNote.worldPosition;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"OnPlayerRespawn\", this, spawnPoint);\r\n\tif (returnvar is global::BasePlayer.SpawnPoint)\r\n\t{\r\n\t\tspawnPoint = (global::BasePlayer.SpawnPoint)returnvar;\r\n\t}\r\n\tthis.RespawnAt(spawnPoint.pos, spawnPoint.rot, null);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanPickupLock",
      "HookName": "CanPickupLock",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "BaseLock"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseLock",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RPC_TakeLock",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (base.IsLocked())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanPickupLock\", rpc.player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::Item item = global::ItemManager.Create(this.itemType, 1, this.skinID);\r\n\tif (item != null)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnDispenserBonus",
      "HookName": "OnDispenserBonus",
      "HookParameters": {
        "instance": "ResourceDispenser",
        "player": "BasePlayer",
        "item": "Item"
      },
      "ReturnBehavior": 3,
      "TargetType": "ResourceDispenser",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "AssignFinishBonus",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer",
          "fraction": "float",
          "weapon": "AttackEntity"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t\tint num = Mathf.CeilToInt((float)((int)current.amount) * Mathf.Clamp01(fraction));\r\n\t\t\tint num2 = this.CalculateGatherBonus(player, current, (float)num);\r\n\t\t\tglobal::Item item = global::ItemManager.Create(current.itemDef, num + num2, 0uL);\r\n\t\t\tif (item != null)\r\n\t\t\t{\r\n\t\t\t\tobject returnvar = Interface.CallHook(\"OnDispenserBonus\", this, player, item);\r\n\t\t\t\tif (returnvar is global::Item)\r\n\t\t\t\t{\r\n\t\t\t\t\titem = (global::Item)returnvar;\r\n\t\t\t\t}\r\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, base.baseEntity, player, weapon);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanVendingAcceptItem",
      "HookName": "CanVendingAcceptItem",
      "HookParameters": {
        "instance": "VendingMachine",
        "item": "Item",
        "targetSlot": "Int32"
      },
      "ReturnBehavior": 1,
      "TargetType": "VendingMachine",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "CanAcceptItem",
        "ReturnType": "bool",
        "Arguments": {
          "item": "Item",
          "targetSlot": "int"
        }
      },
      "CodeAfterInjection": "public bool CanAcceptItem(global::Item item, int targetSlot)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanVendingAcceptItem\", this, item, targetSlot);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tglobal::BasePlayer ownerPlayer = item.GetOwnerPlayer();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnLiftUse",
      "HookName": "OnLiftUse",
      "HookDescription": "Called when a player attempts to call a lift",
      "HookParameters": {
        "instance": "Lift",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "Lift",
      "Category": "Elevator",
      "MethodData": {
        "MethodName": "RPC_UseLift",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (!rpc.player.CanInteract())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnLiftUse\", this, rpc.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.MoveUp();\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnServerUserRemove",
      "HookName": "OnServerUserRemove",
      "HookParameters": {
        "uid": "UInt64"
      },
      "ReturnBehavior": 0,
      "TargetType": "ServerUsers",
      "Category": "Server",
      "MethodData": {
        "MethodName": "Remove",
        "ReturnType": "void",
        "Arguments": {
          "uid": "ulong"
        }
      },
      "CodeAfterInjection": "public static void Remove(ulong uid)\r\n{\r\n\tInterface.CallHook(\"OnServerUserRemove\", uid);\r\n\tglobal::ServerUsers.users.Remove(uid);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerKicked",
      "HookName": "OnPlayerKicked",
      "HookParameters": {
        "instance": "BasePlayer",
        "reason": "String"
      },
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "Kick",
        "ReturnType": "void",
        "Arguments": {
          "reason": "string"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (!this.IsConnected)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tNet.sv.Kick(this.net.connection, reason, false);\r\n\tInterface.CallHook(\"OnPlayerKicked\", this, reason);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "CanBradleyApcTarget",
      "HookName": "CanBradleyApcTarget",
      "HookParameters": {
        "instance": "BradleyAPC",
        "ent": "BaseEntity"
      },
      "ReturnBehavior": 1,
      "TargetType": "BradleyAPC",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "VisibilityTest",
        "ReturnType": "bool",
        "Arguments": {
          "ent": "BaseEntity"
        }
      },
      "CodeAfterInjection": "...\r\n\telse\r\n\t{\r\n\t\tDebug.LogWarning(\"Standard vis test!\");\r\n\t\tflag = base.IsVisible(ent.CenterPoint(), float.PositiveInfinity);\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"CanBradleyApcTarget\", this, ent);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn flag;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBradleyApcInitialize",
      "HookName": "OnBradleyApcInitialize",
      "HookParameters": {
        "instance": "BradleyAPC"
      },
      "ReturnBehavior": 1,
      "TargetType": "BradleyAPC",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "Initialize",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void Initialize()\r\n{\r\n\tif (Interface.CallHook(\"OnBradleyApcInitialize\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.myRigidBody.centerOfMass = this.centerOfMass.localPosition;\r\n\tthis.destination = base.transform.position;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBradleyApcHunt",
      "HookName": "OnBradleyApcHunt",
      "HookParameters": {
        "instance": "BradleyAPC"
      },
      "ReturnBehavior": 1,
      "TargetType": "BradleyAPC",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "UpdateMovement_Hunt",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void UpdateMovement_Hunt()\r\n{\r\n\tif (Interface.CallHook(\"OnBradleyApcHunt\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.patrolPath == null)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBradleyApcPatrol",
      "HookName": "OnBradleyApcPatrol",
      "HookParameters": {
        "instance": "BradleyAPC"
      },
      "ReturnBehavior": 1,
      "TargetType": "BradleyAPC",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "UpdateMovement_Patrol",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tthis.nextPatrolTime = Time.time + 20f;\r\n\tif (this.HasPath() && !this.IsAtFinalDestination())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnBradleyApcPatrol\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::IAIPathInterestNode randomInterestNodeAwayFrom = this.patrolPath.GetRandomInterestNodeAwayFrom(base.transform.position, 10f);\r\n\tglobal::IAIPathNode closestToPoint = this.patrolPath.GetClosestToPoint(randomInterestNodeAwayFrom.Position);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnShopCompleteTrade",
      "HookName": "OnShopCompleteTrade",
      "HookParameters": {
        "instance": "ShopFront"
      },
      "ReturnBehavior": 1,
      "TargetType": "ShopFront",
      "Category": "Shop",
      "MethodData": {
        "MethodName": "CompleteTrade",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void CompleteTrade()\r\n{\r\n\tif (this.vendorPlayer != null && this.customerPlayer != null && base.HasFlag(global::BaseEntity.Flags.Reserved1) && base.HasFlag(global::BaseEntity.Flags.Reserved2))\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnShopCompleteTrade\", this) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\ttry\r\n\t\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanHelicopterUseNapalm",
      "HookName": "CanHelicopterUseNapalm",
      "HookParameters": {
        "instance": "PatrolHelicopterAI"
      },
      "ReturnBehavior": 1,
      "TargetType": "PatrolHelicopterAI",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "CanUseNapalm",
        "ReturnType": "bool",
        "Arguments": {}
      },
      "CodeAfterInjection": "public bool CanUseNapalm()\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanHelicopterUseNapalm\", this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn Time.realtimeSinceStartup - this.lastNapalmTime >= 30f;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanHelicopterStrafe",
      "HookName": "CanHelicopterStrafe",
      "HookParameters": {
        "instance": "PatrolHelicopterAI"
      },
      "ReturnBehavior": 1,
      "TargetType": "PatrolHelicopterAI",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "CanStrafe",
        "ReturnType": "bool",
        "Arguments": {}
      },
      "CodeAfterInjection": "public bool CanStrafe()\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanHelicopterStrafe\", this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn Time.realtimeSinceStartup - this.lastStrafeTime >= 20f && this.CanInterruptState();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanHelicopterTarget",
      "HookName": "CanHelicopterTarget",
      "HookParameters": {
        "instance": "PatrolHelicopterAI",
        "ply": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "PatrolHelicopterAI",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "PlayerVisible",
        "ReturnType": "bool",
        "Arguments": {
          "ply": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public bool PlayerVisible(global::BasePlayer ply)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanHelicopterTarget\", this, ply);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tVector3 position = ply.eyes.position;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanDismountEntity",
      "HookName": "CanDismountEntity",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "BaseMountable"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseMountable",
      "Category": "Player",
      "MethodData": {
        "MethodName": "DismountPlayer",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer",
          "lite": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (this._mounted != player)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanDismountEntity\", player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::BaseVehicle baseVehicle = this.VehicleParent();\r\n\tif (lite)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityDismounted",
      "HookName": "OnEntityDismounted",
      "HookDescription": "Called when an entity is dismounted by a player",
      "HookParameters": {
        "instance": "BaseMountable",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseMountable",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "DismountPlayer",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer",
          "lite": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (this._mounted != player)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanDismountEntity\", player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::BaseVehicle baseVehicle = this.VehicleParent();\r\n\tif (lite)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityDismounted [lite]",
      "HookName": "OnEntityDismounted",
      "HookDescription": "Called when an entity is dismounted by a player",
      "HookParameters": {
        "instance": "BaseMountable",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseMountable",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "DismountPlayer",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer",
          "lite": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (this._mounted != player)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanDismountEntity\", player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::BaseVehicle baseVehicle = this.VehicleParent();\r\n\tif (lite)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanMountEntity",
      "HookName": "CanMountEntity",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "BaseMountable"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseMountable",
      "Category": "Player",
      "MethodData": {
        "MethodName": "MountPlayer",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (this.mountAnchor == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanMountEntity\", player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tplayer.EnsureDismounted();\r\n\tthis._mounted = player;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityMounted",
      "HookName": "OnEntityMounted",
      "HookParameters": {
        "instance": "BaseMountable",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseMountable",
      "Category": "Player",
      "MethodData": {
        "MethodName": "MountPlayer",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (this.mountAnchor == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanMountEntity\", player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tplayer.EnsureDismounted();\r\n\tthis._mounted = player;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanCraft [PlayerBlueprints]",
      "HookName": "CanCraft",
      "HookDescription": "Called when the player attempts to craft an item",
      "HookParameters": {
        "instance": "PlayerBlueprints",
        "itemDefinition": "ItemDefinition",
        "skinItemId": "int"
      },
      "ReturnBehavior": 1,
      "TargetType": "PlayerBlueprints",
      "Category": "Crafting",
      "MethodData": {
        "MethodName": "CanCraft",
        "ReturnType": "bool",
        "Arguments": {
          "itemid": "int",
          "skinItemId": "int",
          "playerId": "ulong"
        }
      },
      "CodeAfterInjection": "...\r\n\tglobal::ItemDefinition itemDefinition = global::ItemManager.FindItemDefinition(itemid);\r\n\tif (itemDefinition == null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"CanCraft\", this, itemDefinition, skinItemId);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn (skinItemId == 0 || base.baseEntity.UnlockAllSkins || this.CheckSkinOwnership(skinItemId, playerId)) && base.baseEntity.currentCraftLevel >= (float)itemDefinition.Blueprint.workbenchLevelRequired && this.HasUnlocked(itemDefinition);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnResearchCostDetermine [Item]",
      "HookName": "OnResearchCostDetermine",
      "HookParameters": {
        "item": "Item",
        "instance": "ResearchTable"
      },
      "ReturnBehavior": 1,
      "TargetType": "ResearchTable",
      "Category": "Item",
      "MethodData": {
        "MethodName": "ScrapForResearch",
        "ReturnType": "int",
        "Arguments": {
          "item": "Item"
        }
      },
      "CodeAfterInjection": "public int ScrapForResearch(global::Item item)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"OnResearchCostDetermine\", item, this);\r\n\tif (returnvar is int)\r\n\t{\r\n\t\treturn (int)returnvar;\r\n\t}\r\n\treturn this.ScrapForResearch(item.info);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnLootSpawn [LootContainer]",
      "HookName": "OnLootSpawn",
      "HookParameters": {
        "instance": "LootContainer"
      },
      "ReturnBehavior": 1,
      "TargetType": "LootContainer",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "SpawnLoot",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\tDebug.Log(\"CONTACT DEVELOPERS! LootContainer::PopulateLoot has null inventory!!!\");\r\n\t\treturn;\r\n\t}\r\n\tbase.inventory.Clear();\r\n\tglobal::ItemManager.DoRemoves();\r\n\tif (Interface.CallHook(\"OnLootSpawn\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.PopulateLoot();\r\n\tif (this.shouldRefreshContents)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanDropActiveItem",
      "HookName": "CanDropActiveItem",
      "HookParameters": {
        "instance": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "ShouldDropActiveItem",
        "ReturnType": "bool",
        "Arguments": {}
      },
      "CodeAfterInjection": "public virtual bool ShouldDropActiveItem()\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanDropActiveItem\", this);\r\n\treturn !(returnvar is bool) || (bool)returnvar;\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerDropActiveItem",
      "HookName": "OnPlayerDropActiveItem",
      "HookParameters": {
        "player": "BasePlayer",
        "activeItem": "Item"
      },
      "ReturnBehavior": 1,
      "TargetType": "PlayerBelt",
      "Category": "Player",
      "MethodData": {
        "MethodName": "DropActive",
        "ReturnType": "void",
        "Arguments": {
          "position": "UnityEngine.Vector3",
          "velocity": "UnityEngine.Vector3"
        }
      },
      "CodeAfterInjection": "...\r\n\tglobal::Item activeItem = this.player.GetActiveItem();\r\n\tif (activeItem == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnPlayerDropActiveItem\", this.player, activeItem) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tusing (TimeWarning.New(\"PlayerBelt.DropActive\", 0))\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTurretClearList",
      "HookName": "OnTurretClearList",
      "HookParameters": {
        "instance": "AutoTurret",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "AutoTurret",
      "Category": "Turret",
      "MethodData": {
        "MethodName": "ClearList",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (this.booting || this.IsOnline() || !this.IsAuthed(rpc.player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnTurretClearList\", this, rpc.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.authorizedPlayers.Clear();\r\n\tglobal::BasePlayer arg_80_1 = rpc.player;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTurretModeToggle",
      "HookName": "OnTurretModeToggle",
      "HookParameters": {
        "instance": "AutoTurret"
      },
      "ReturnBehavior": 0,
      "TargetType": "AutoTurret",
      "Category": "Turret",
      "MethodData": {
        "MethodName": "SetPeacekeepermode",
        "ReturnType": "void",
        "Arguments": {
          "isOn": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.SetFlag(global::BaseEntity.Flags.Reserved1, isOn, false, true);\r\n\tglobal::Effect.server.Run(this.peacekeeperToggleSound.resourcePath, this, 0u, Vector3.zero, Vector3.zero, null, false);\r\n\tInterface.CallHook(\"OnTurretModeToggle\", this);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnWorldProjectileCreate",
      "HookName": "OnWorldProjectileCreate",
      "HookParameters": {
        "info": "HitInfo",
        "item": "Item"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "CreateWorldProjectile",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo",
          "itemDef": "ItemDefinition",
          "itemMod": "ItemModProjectile",
          "projectilePrefab": "Projectile",
          "recycleItem": "Item"
        }
      },
      "CodeAfterInjection": "protected virtual void CreateWorldProjectile(global::HitInfo info, global::ItemDefinition itemDef, global::ItemModProjectile itemMod, global::Projectile projectilePrefab, global::Item recycleItem)\r\n{\r\n\tif (Interface.CallHook(\"CanCreateWorldProjectile\", info, itemDef) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tVector3 projectileVelocity = info.ProjectileVelocity;\r\n\tglobal::Item item = (recycleItem != null) ? recycleItem : global::ItemManager.Create(itemDef, 1, 0uL);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnActiveItemChange",
      "HookName": "OnActiveItemChange",
      "HookParameters": {
        "instance": "BasePlayer",
        "activeItem": "Item",
        "itemID": "ItemId"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "UpdateActiveItem",
        "ReturnType": "void",
        "Arguments": {
          "itemID": "ItemId"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (this.IsItemHoldRestricted(item))\r\n\t{\r\n\t\titemID = default(ItemId);\r\n\t}\r\n\tglobal::Item activeItem = this.GetActiveItem();\r\n\tif (Interface.CallHook(\"OnActiveItemChange\", this, activeItem, itemID) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.svActiveItemID = default(ItemId);\r\n\tif (activeItem != null)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnAmmoSwitch",
      "HookName": "OnAmmoSwitch",
      "HookParameters": {
        "instance": "BaseProjectile",
        "ownerPlayer": "BasePlayer",
        "itemDefinition": "ItemDefinition"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseProjectile",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "SwitchAmmoTo",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tglobal::ItemModProjectile component = itemDefinition.GetComponent<global::ItemModProjectile>();\r\n\tif (!component || !component.IsAmmo(this.primaryMagazine.definition.ammoTypes))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnAmmoSwitch\", this, ownerPlayer, itemDefinition) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.primaryMagazine.contents > 0)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerVoice",
      "HookName": "OnPlayerVoice",
      "HookParameters": {
        "instance": "BasePlayer",
        "data": "Byte[]"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "OnReceivedVoice",
        "ReturnType": "void",
        "Arguments": {
          "data": "System.Byte[]"
        }
      },
      "CodeAfterInjection": "public void OnReceivedVoice(byte[] data)\r\n{\r\n\tif (Interface.CallHook(\"OnPlayerVoice\", this, data) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tNetWrite expr_1A = Network.Net.sv.StartWrite();\r\n\texpr_1A.PacketID(Message.Type.VoiceData);\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "CanBeTargeted [FlameTurret] [cleanup]",
      "HookName": "CanBeTargeted [patch]",
      "ReturnBehavior": 0,
      "TargetType": "FlameTurret",
      "Category": "Player",
      "MethodData": {
        "MethodName": "CheckTrigger",
        "ReturnType": "bool",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\t\twhile (enumerator.MoveNext())\r\n\t\t\t{\r\n\t\t\t\tglobal::BasePlayer component = enumerator.Current.GetComponent<global::BasePlayer>();\r\n\t\t\t\tif (!component.IsSleeping() && component.IsAlive())\r\n\t\t\t\t{\r\n\t\t\t\t\tobject returnvar = Interface.CallHook(\"CanBeTargeted\", component, this);\r\n\t\t\t\t\tif (returnvar is bool)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tPool.FreeList<RaycastHit>(ref list);\r\n\t\t\t\t\t\treturn (bool)returnvar;\r\n\t\t\t\t\t}\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "CanBeTargeted [GunTrap] [cleanup]",
      "HookName": "CanBeTargeted [patch]",
      "ReturnBehavior": 0,
      "TargetType": "GunTrap",
      "Category": "Player",
      "MethodData": {
        "MethodName": "CheckTrigger",
        "ReturnType": "bool",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\t\twhile (enumerator.MoveNext())\r\n\t\t\t{\r\n\t\t\t\tglobal::BasePlayer component = enumerator.Current.GetComponent<global::BasePlayer>();\r\n\t\t\t\tif (!component.IsSleeping() && component.IsAlive())\r\n\t\t\t\t{\r\n\t\t\t\t\tobject returnvar = Interface.CallHook(\"CanBeTargeted\", component, this);\r\n\t\t\t\t\tif (returnvar is bool)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tPool.FreeList<RaycastHit>(ref list);\r\n\t\t\t\t\t\treturn (bool)returnvar;\r\n\t\t\t\t\t}\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnLiftUse [ProceduralLift]",
      "HookName": "OnLiftUse",
      "HookDescription": "Called when a player attempts to call a procedural lift",
      "HookParameters": {
        "instance": "ProceduralLift",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "ProceduralLift",
      "Category": "Elevator",
      "MethodData": {
        "MethodName": "RPC_UseLift",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (!rpc.player.CanInteract())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnLiftUse\", this, rpc.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (base.IsBusy())\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanLootEntity [LootableCorpse]",
      "HookName": "CanLootEntity",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "LootableCorpse"
      },
      "ReturnBehavior": 1,
      "TargetType": "LootableCorpse",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RPC_LootCorpse",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (this.containers == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanLootEntity\", player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (player.inventory.loot.StartLootingEntity(this, true))\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanLootEntity [ResourceContainer]",
      "HookName": "CanLootEntity",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "ResourceContainer"
      },
      "ReturnBehavior": 1,
      "TargetType": "ResourceContainer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "StartLootingContainer",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (!this.lootable)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanLootEntity\", player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (player.inventory.loot.StartLootingEntity(base.baseEntity, true))\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanLootEntity [DroppedItemContainer]",
      "HookName": "CanLootEntity",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "DroppedItemContainer"
      },
      "ReturnBehavior": 1,
      "TargetType": "DroppedItemContainer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RPC_OpenLoot",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tglobal::BasePlayer player = rpc.player;\r\n\tif (!player || !player.CanInteract())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanLootEntity\", player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (player.inventory.loot.StartLootingEntity(this, true))\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityBuilt",
      "HookName": "OnEntityBuilt",
      "HookParameters": {
        "instance": "Planner",
        "arg_247_0": "GameObject"
      },
      "ReturnBehavior": 0,
      "TargetType": "Planner",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "DoBuild",
        "ReturnType": "void",
        "Arguments": {
          "target": "Construction/Target",
          "component": "Construction"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\townerPlayer.ChatMessage(\"Can't place: \" + global::Construction.lastPlacementError);\r\n\t}\r\n\tif (gameObject != null)\r\n\t{\r\n\t\tInterface.CallHook(\"OnEntityBuilt\", this, gameObject);\r\n\t\tglobal::Deployable deployable = this.GetDeployable();\r\n\t\tglobal::BaseEntity baseEntity = gameObject.ToBaseEntity();\r\n\t\tif (deployable != null)\r\n\t\t{\r\n\t\t\tif (deployable.setSocketParent && target.entity != null && target.entity.SupportsChildDeployables() && baseEntity)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnDoorKnocked [Door]",
      "HookName": "OnDoorKnocked",
      "HookParameters": {
        "instance": "Door",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "Door",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "RPC_KnockDoor",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t\tcomponent.Knock(rpc.player);\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\tglobal::Effect.server.Run(this.knockEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero, null, false);\r\n\tInterface.CallHook(\"OnDoorKnocked\", this, rpc.player);\r\n}\r\n\r\n"
    },
    {
      "Type": 1,
      "Name": "OnLootEntity [patch]",
      "HookName": "OnLootEntity [patch]",
      "ReturnBehavior": 0,
      "TargetType": "PlayerLoot",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "StartLootingEntity",
        "ReturnType": "bool",
        "Arguments": {
          "targetEntity": "BaseEntity",
          "doPositionChecks": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tAssert.IsTrue(targetEntity.isServer, \"Assure is server\");\r\n\tthis.PositionChecks = doPositionChecks;\r\n\tthis.entitySource = targetEntity;\r\n\tthis.itemSource = null;\r\n\tInterface.CallHook(\"OnLootEntity\", this.GetComponent<global::BasePlayer>(), targetEntity);\r\n\tthis.MarkDirty();\r\n\tglobal::ILootableEntity lootableEntity;\r\n\tif ((lootableEntity = (targetEntity as global::ILootableEntity)) != null)\r\n\t{\r\n\t\tlootableEntity.LastLootedBy = base.baseEntity.userID;\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnLootItem [patch]",
      "HookName": "OnLootItem [patch]",
      "ReturnBehavior": 0,
      "TargetType": "PlayerLoot",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "StartLootingItem",
        "ReturnType": "void",
        "Arguments": {
          "item": "Item"
        }
      },
      "CodeAfterInjection": "...\r\n\tthis.PositionChecks = true;\r\n\tthis.containers.Add(item.contents);\r\n\titem.contents.onDirty += new System.Action(this.MarkDirty);\r\n\tthis.itemSource = item;\r\n\tthis.entitySource = item.GetWorldEntity();\r\n\tInterface.CallHook(\"OnLootItem\", this.GetComponent<global::BasePlayer>(), item);\r\n\tthis.MarkDirty();\r\n}\r\n\r\n"
    },
    {
      "Type": 1,
      "Name": "OnPlayerAttack [melee, patch]",
      "HookName": "OnPlayerAttack [melee, patch]",
      "ReturnBehavior": 0,
      "TargetType": "BaseMelee",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "DoAttackShared",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "public virtual void DoAttackShared(global::HitInfo info)\r\n{\r\n\tif (Interface.CallHook(\"OnPlayerAttack\", this.GetOwnerPlayer(), info) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.GetAttackStats(info);\r\n\tif (info.HitEntity != null)\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnStructureDemolish [false, patch]",
      "HookName": "OnStructureDemolish [false, patch]",
      "ReturnBehavior": 0,
      "TargetType": "BuildingBlock",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "DoDemolish",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (!this.CanDemolish(msg.player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnStructureDemolish\", this, msg.player, false) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tFacepunch.Rust.Analytics.Azure.OnBuildingBlockDemolished(msg.player, this);\r\n\tbase.Kill(global::BaseNetworkable.DestroyMode.Gib);\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnStructureDemolish [true, patch]",
      "HookName": "OnStructureDemolish [true, patch]",
      "ReturnBehavior": 0,
      "TargetType": "BuildingBlock",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "DoImmediateDemolish",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (!msg.player.IsAdmin)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnStructureDemolish\", this, msg.player, true) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tFacepunch.Rust.Analytics.Azure.OnBuildingBlockDemolished(msg.player, this);\r\n\tbase.Kill(global::BaseNetworkable.DestroyMode.Gib);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerInput",
      "HookName": "OnPlayerInput",
      "HookParameters": {
        "instance": "BasePlayer",
        "serverInput": "InputState"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "OnReceiveTick",
        "ReturnType": "void",
        "Arguments": {
          "msg": "PlayerTick",
          "wasPlayerStalled": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (msg.inputState != null)\r\n\t{\r\n\t\tthis.serverInput.Flip(msg.inputState);\r\n\t}\r\n\tif (Interface.CallHook(\"OnPlayerTick\", this, msg, wasPlayerStalled) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.serverInput.current.buttons != this.serverInput.previous.buttons)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "IOnNpcTarget [BaseNpc]",
      "HookName": "IOnNpcTarget",
      "HookParameters": {
        "instance": "BaseNpc",
        "target": "BaseEntity"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseNpc",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "GetWantsToAttack",
        "ReturnType": "float",
        "Arguments": {
          "target": "BaseEntity"
        }
      },
      "CodeAfterInjection": "public float GetWantsToAttack(global::BaseEntity target)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"IOnNpcTarget\", this, target);\r\n\tif (returnvar is float)\r\n\t{\r\n\t\treturn (float)returnvar;\r\n\t}\r\n\treturn this.WantsToAttack(target);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanHackCrate",
      "HookName": "CanHackCrate",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "HackableLockedCrate"
      },
      "ReturnBehavior": 1,
      "TargetType": "HackableLockedCrate",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RPC_Hack",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (this.IsBeingHacked())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanHackCrate\", msg.player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tFacepunch.Rust.Analytics.Azure.OnLockedCrateStarted(msg.player, this);\r\n\tthis.OriginalHackerPlayer = msg.player.userID;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCrateHack",
      "HookName": "OnCrateHack",
      "HookDescription": "Called when a player starts hacking a locked crate",
      "HookParameters": {
        "instance": "HackableLockedCrate"
      },
      "ReturnBehavior": 0,
      "TargetType": "HackableLockedCrate",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "StartHacking",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void StartHacking()\r\n{\r\n\tInterface.CallHook(\"OnCrateHack\", this);\r\n\tbase.BroadcastEntityMessage(\"HackingStarted\", 20f, 256);\r\n\tbase.SetFlag(global::BaseEntity.Flags.Reserved1, true, false, true);\r\n\tbase.InvokeRepeating(new System.Action(this.HackProgress), 1f, 1f);\r\n\tbase.ClientRPC<int, int>(null, \"UpdateHackProgress\", 0, (int)global::HackableLockedCrate.requiredHackSeconds);\r\n\tthis.RefreshDecay();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCrateHackEnd",
      "HookName": "OnCrateHackEnd",
      "HookParameters": {
        "instance": "HackableLockedCrate"
      },
      "ReturnBehavior": 0,
      "TargetType": "HackableLockedCrate",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "HackProgress",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void HackProgress()\r\n{\r\n\tthis.hackSeconds += 1f;\r\n\tif (this.hackSeconds > global::HackableLockedCrate.requiredHackSeconds)\r\n\t{\r\n\t\tInterface.CallHook(\"OnCrateHackEnd\", this);\r\n\t\tFacepunch.Rust.Analytics.Azure.OnLockedCrateFinished(this.OriginalHackerPlayer, this);\r\n\t\tthis.RefreshDecay();\r\n\t\tbase.SetFlag(global::BaseEntity.Flags.Reserved2, true, false, true);\r\n\t\tthis.isLootable = true;\r\n\t\tbase.CancelInvoke(new System.Action(this.HackProgress));\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCrateLanded",
      "HookName": "OnCrateLanded",
      "HookDescription": "Called when a locked crate from the CH47 (Chinook) has landed",
      "HookParameters": {
        "instance": "HackableLockedCrate"
      },
      "ReturnBehavior": 0,
      "TargetType": "HackableLockedCrate",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "LandCheck",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void LandCheck()\r\n{\r\n\tif (this.hasLanded)\r\n\t{\r\n\t\tInterface.CallHook(\"OnCrateLanded\", this);\r\n\t\treturn;\r\n\t}\r\n\tRaycastHit raycastHit;\r\n\tif (Physics.Raycast(new Ray(base.transform.position + Vector3.up * 0.5f, Vector3.down), out raycastHit, 1f, 1218511105))\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCrateDropped",
      "HookName": "OnCrateDropped",
      "HookDescription": "Called when a locked crate from the CH47 (Chinook) has dropped",
      "HookParameters": {
        "instance": "HackableLockedCrate"
      },
      "ReturnBehavior": 0,
      "TargetType": "HackableLockedCrate",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "SetWasDropped",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void SetWasDropped()\r\n{\r\n\tthis.wasDropped = true;\r\n\tInterface.CallHook(\"OnCrateDropped\", this);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnExperimentStart",
      "HookName": "OnExperimentStart",
      "HookParameters": {
        "instance": "Workbench",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "Workbench",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RPC_BeginExperiment",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (this.pendingBlueprint == null)\r\n\t{\r\n\t\tplayer.ChatMessage(\"You have already unlocked everything for this workbench tier.\");\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnExperimentStart\", this, player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::Item slot = base.inventory.GetSlot(0);\r\n\tif (slot != null)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanHelicopterDropCrate",
      "HookName": "CanHelicopterDropCrate",
      "HookParameters": {
        "instance": "CH47HelicopterAIController"
      },
      "ReturnBehavior": 1,
      "TargetType": "CH47HelicopterAIController",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "CanDropCrate",
        "ReturnType": "bool",
        "Arguments": {}
      },
      "CodeAfterInjection": "public bool CanDropCrate()\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanHelicopterDropCrate\", this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn this.numCrates > 0;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnHelicopterDropCrate",
      "HookName": "OnHelicopterDropCrate",
      "HookParameters": {
        "instance": "CH47HelicopterAIController"
      },
      "ReturnBehavior": 0,
      "TargetType": "CH47HelicopterAIController",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "DropCrate",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tVector3 pos = base.transform.position + Vector3.down * 5f;\r\n\tQuaternion rot = Quaternion.Euler(0f, UnityEngine.Random.Range(0f, 360f), 0f);\r\n\tglobal::BaseEntity baseEntity = global::GameManager.server.CreateEntity(this.lockedCratePrefab.resourcePath, pos, rot, true);\r\n\tif (baseEntity)\r\n\t{\r\n\t\tInterface.CallHook(\"OnHelicopterDropCrate\", this);\r\n\t\tbaseEntity.SendMessage(\"SetWasDropped\");\r\n\t\tbaseEntity.Spawn();\r\n\t}\r\n\tthis.numCrates--;\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnHelicopterAttack",
      "HookName": "OnHelicopterAttack",
      "HookParameters": {
        "instance": "CH47HelicopterAIController",
        "info": "HitInfo"
      },
      "ReturnBehavior": 1,
      "TargetType": "CH47HelicopterAIController",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "OnAttacked",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "public override void OnAttacked(global::HitInfo info)\r\n{\r\n\tif (Interface.CallHook(\"OnHelicopterAttack\", this, info) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.OnAttacked(info);\r\n\tthis.InitiateAnger();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityDestroy [CH47Helicopter]",
      "HookName": "OnEntityDestroy",
      "HookDescription": "Called right before a CH47Helicopter is destroyed",
      "HookParameters": {
        "instance": "CH47HelicopterAIController"
      },
      "ReturnBehavior": 1,
      "TargetType": "CH47HelicopterAIController",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "OnKilled",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "public override void OnKilled(global::HitInfo info)\r\n{\r\n\tif (Interface.CallHook(\"OnEntityDestroy\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!this.OutOfCrates())\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnHelicopterOutOfCrates",
      "HookName": "OnHelicopterOutOfCrates",
      "HookParameters": {
        "instance": "CH47HelicopterAIController"
      },
      "ReturnBehavior": 1,
      "TargetType": "CH47HelicopterAIController",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "OutOfCrates",
        "ReturnType": "bool",
        "Arguments": {}
      },
      "CodeAfterInjection": "public bool OutOfCrates()\r\n{\r\n\tobject returnvar = Interface.CallHook(\"OnHelicopterOutOfCrates\", this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn this.numCrates <= 0;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnHelicopterDropDoorOpen",
      "HookName": "OnHelicopterDropDoorOpen",
      "HookParameters": {
        "instance": "CH47HelicopterAIController"
      },
      "ReturnBehavior": 1,
      "TargetType": "CH47HelicopterAIController",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "SetDropDoorOpen",
        "ReturnType": "void",
        "Arguments": {
          "open": "bool"
        }
      },
      "CodeAfterInjection": "public void SetDropDoorOpen(bool open)\r\n{\r\n\tif (Interface.CallHook(\"OnHelicopterDropDoorOpen\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.SetFlag(global::BaseEntity.Flags.Reserved8, open, false, true);\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "CanRenameBed",
      "HookName": "CanRenameBed",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "SleepingBag",
        "text": "string"
      },
      "ReturnBehavior": 1,
      "TargetType": "SleepingBag",
      "Category": "Player",
      "MethodData": {
        "MethodName": "Rename",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (!msg.player.CanInteract())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tstring text = msg.read.String(256);\r\n\tif (Interface.CallHook(\"CanRenameBed\", msg.player, this, text) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\ttext = global::WordFilter.Filter(text);\r\n\tif (string.IsNullOrEmpty(text))\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnAddVendingOffer",
      "HookName": "OnAddVendingOffer",
      "HookParameters": {
        "instance": "VendingMachine",
        "sellOrder": "SellOrder"
      },
      "ReturnBehavior": 0,
      "TargetType": "VendingMachine",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "AddSellOrder",
        "ReturnType": "void",
        "Arguments": {
          "itemToSellID": "int",
          "itemToSellAmount": "int",
          "currencyToUseID": "int",
          "currencyAmount": "int",
          "bpState": "byte"
        }
      },
      "CodeAfterInjection": "...\r\n\tsellOrder.itemToSellAmount = itemToSellAmount;\r\n\tsellOrder.currencyID = currencyToUseID;\r\n\tsellOrder.currencyAmountPerItem = currencyAmount;\r\n\tsellOrder.currencyIsBP = (bpState == 3 || bpState == 2);\r\n\tsellOrder.itemToSellIsBP = (bpState == 3 || bpState == 1);\r\n\tInterface.CallHook(\"OnAddVendingOffer\", this, sellOrder);\r\n\tthis.sellOrders.sellOrders.Add(sellOrder);\r\n\tthis.RefreshSellOrderStockLevel(itemDefinition);\r\n\tthis.UpdateMapMarker();\r\n\tbase.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnLootPlayer",
      "HookName": "OnLootPlayer",
      "HookParameters": {
        "instance": "BasePlayer",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RPC_LootPlayer",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (player.inventory.loot.StartLootingEntity(this, true))\r\n\t{\r\n\t\tplayer.inventory.loot.AddContainer(this.inventory.containerMain);\r\n\t\tplayer.inventory.loot.AddContainer(this.inventory.containerWear);\r\n\t\tplayer.inventory.loot.AddContainer(this.inventory.containerBelt);\r\n\t\tInterface.CallHook(\"OnLootPlayer\", this, player);\r\n\t\tplayer.inventory.loot.SendImmediate();\r\n\t\tplayer.ClientRPCPlayer<string>(null, player, \"RPC_OpenLootPanel\", \"player_corpse\");\r\n\t}\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFlameThrowerBurn",
      "HookName": "OnFlameThrowerBurn",
      "HookParameters": {
        "instance": "FlameThrower",
        "baseEntity": "BaseEntity"
      },
      "ReturnBehavior": 0,
      "TargetType": "FlameThrower",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "FlameTick",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\tthis.nextFlameTime = Time.realtimeSinceStartup + 0.45f;\r\n\t\tVector3 point = raycastHit.point;\r\n\t\tglobal::BaseEntity baseEntity = global::GameManager.server.CreateEntity(this.fireballPrefab.resourcePath, point - ray.direction * 0.25f, default(Quaternion), true);\r\n\t\tif (baseEntity)\r\n\t\t{\r\n\t\t\tInterface.CallHook(\"OnFlameThrowerBurn\", this, baseEntity);\r\n\t\t\tbaseEntity.creatorEntity = ownerPlayer;\r\n\t\t\tbaseEntity.Spawn();\r\n\t\t}\r\n\t}\r\n\tif (this.ammo == 0)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFireBallDamage",
      "HookName": "OnFireBallDamage",
      "HookParameters": {
        "instance": "FireBall",
        "baseCombatEntity": "BaseCombatEntity",
        "hitInfo": "HitInfo"
      },
      "ReturnBehavior": 0,
      "TargetType": "FireBall",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "DoRadialDamage",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\t\t\t\tglobal::Effect.server.Run(\"assets/bundled/prefabs/fx/impacts/additive/fire.prefab\", baseCombatEntity, 0u, new Vector3(0f, 1f, 0f), Vector3.up, null, false);\r\n\t\t\t\t}\r\n\t\t\t\thitInfo.PointEnd = baseCombatEntity.transform.position;\r\n\t\t\t\thitInfo.HitPositionWorld = baseCombatEntity.transform.position;\r\n\t\t\t\thitInfo.damageTypes.Set(Rust.DamageType.Heat, this.damagePerSecond * this.tickRate);\r\n\t\t\t\tInterface.CallHook(\"OnFireBallDamage\", this, baseCombatEntity, hitInfo);\r\n\t\t\t\tbaseCombatEntity.OnAttacked(hitInfo);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tPool.FreeList<Collider>(ref list);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFireBallSpread",
      "HookName": "OnFireBallSpread",
      "HookParameters": {
        "instance": "FireBall",
        "baseEntity": "BaseEntity"
      },
      "ReturnBehavior": 0,
      "TargetType": "FireBall",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "TryToSpread",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\t{\r\n\t\t\tbaseEntity.transform.position = base.transform.position + Vector3.up * 0.25f;\r\n\t\t\tbaseEntity.Spawn();\r\n\t\t\tVector3 modifiedAimConeDirection = global::AimConeUtil.GetModifiedAimConeDirection(45f, Vector3.up, true);\r\n\t\t\tbaseEntity.creatorEntity = ((this.creatorEntity == null) ? baseEntity : this.creatorEntity);\r\n\t\t\tInterface.CallHook(\"OnFireBallSpread\", this, baseEntity);\r\n\t\t\tbaseEntity.SetVelocity(modifiedAimConeDirection * UnityEngine.Random.Range(5f, 8f));\r\n\t\t\tbaseEntity.SendMessage(\"SetGeneration\", this.generation + 1f);\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerMetabolize",
      "HookName": "OnPlayerMetabolize",
      "HookParameters": {
        "instance": "PlayerMetabolism",
        "ownerEntity": "BaseCombatEntity",
        "delta": "float"
      },
      "ReturnBehavior": 0,
      "TargetType": "PlayerMetabolism",
      "Category": "Player",
      "MethodData": {
        "MethodName": "ServerUpdate",
        "ReturnType": "void",
        "Arguments": {
          "ownerEntity": "BaseCombatEntity",
          "delta": "float"
        }
      },
      "CodeAfterInjection": "public override void ServerUpdate(global::BaseCombatEntity ownerEntity, float delta)\r\n{\r\n\tbase.ServerUpdate(ownerEntity, delta);\r\n\tInterface.CallHook(\"OnPlayerMetabolize\", this, ownerEntity, delta);\r\n\tthis.SendChangesToClient();\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityMarkHostile",
      "HookName": "OnEntityMarkHostile",
      "HookDescription": "Called when an entity attempts to become hostile\r\nUseful for denying marking the entity hostile",
      "HookParameters": {
        "instance": "BaseCombatEntity",
        "duration": "Single"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseCombatEntity",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "MarkHostileFor",
        "ReturnType": "void",
        "Arguments": {
          "duration": "float"
        }
      },
      "CodeAfterInjection": "public virtual void MarkHostileFor(float duration = 60f)\r\n{\r\n\tif (Interface.CallHook(\"OnEntityMarkHostile\", this, duration) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat b = Time.realtimeSinceStartup + duration;\r\n\tthis.unHostileTime = Mathf.Max(this.unHostileTime, b);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanEntityBeHostile",
      "HookName": "CanEntityBeHostile",
      "HookDescription": "Useful for overriding hostility of an entity",
      "HookParameters": {
        "instance": "BaseCombatEntity"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseCombatEntity",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "IsHostile",
        "ReturnType": "bool",
        "Arguments": {}
      },
      "CodeAfterInjection": "public virtual bool IsHostile()\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanEntityBeHostile\", this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn this.unHostileTime > Time.realtimeSinceStartup;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanEntityBeHostile [BasePlayer]",
      "HookName": "CanEntityBeHostile",
      "HookDescription": "Useful for overriding hostility of an entity",
      "HookParameters": {
        "instance": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "IsHostile",
        "ReturnType": "bool",
        "Arguments": {}
      },
      "CodeAfterInjection": "public override bool IsHostile()\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanEntityBeHostile\", this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn this.State.unHostileTimestamp > TimeEx.currentTimestamp;\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "SetMaxHealthBasePlayer [patch]",
      "HookName": "SetMaxHealthBasePlayer [patch]",
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "MaxHealth",
        "ReturnType": "float",
        "Arguments": {}
      }
    },
    {
      "Type": 0,
      "Name": "OnItemRemove",
      "HookName": "OnItemRemove",
      "HookParameters": {
        "instance": "Item"
      },
      "ReturnBehavior": 1,
      "TargetType": "Item",
      "Category": "Item",
      "MethodData": {
        "MethodName": "Remove",
        "ReturnType": "void",
        "Arguments": {
          "fTime": "float"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (this.removeTime > 0f)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnItemRemove\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.isServer)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "ICanPickupEntity [DoorCloser]",
      "HookName": "ICanPickupEntity",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "DoorCloser"
      },
      "ReturnBehavior": 1,
      "TargetType": "DoorCloser",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RPC_Take",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.MaxDistance(3f)]\r\npublic void RPC_Take(global::BaseEntity.RPCMessage rpc)\r\n{\r\n\tif (Interface.CallHook(\"ICanPickupEntity\", rpc.player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!rpc.player.CanInteract())\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTeamCreate",
      "HookName": "OnTeamCreate",
      "HookParameters": {
        "basePlayer": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "RelationshipManager",
      "Category": "Team",
      "MethodData": {
        "MethodName": "trycreateteam",
        "ReturnType": "void",
        "Arguments": {
          "arg": "ConsoleSystem/Arg"
        }
      },
      "CodeAfterInjection": "...\r\n\tglobal::BasePlayer basePlayer = arg.Player();\r\n\tif (basePlayer.currentTeam != 0uL)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnTeamCreate\", basePlayer) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::RelationshipManager.PlayerTeam OxideGen_2 = global::RelationshipManager.ServerInstance.CreateTeam();\r\n\tglobal::RelationshipManager.PlayerTeam playerTeam = OxideGen_2;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTeamInvite",
      "HookName": "OnTeamInvite",
      "HookParameters": {
        "basePlayer": "BasePlayer",
        "component": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "RelationshipManager",
      "Category": "Team",
      "MethodData": {
        "MethodName": "sendinvite",
        "ReturnType": "void",
        "Arguments": {
          "arg": "ConsoleSystem/Arg"
        }
      },
      "CodeAfterInjection": "...\r\n\t\tif (entity)\r\n\t\t{\r\n\t\t\tglobal::BasePlayer component = entity.GetComponent<global::BasePlayer>();\r\n\t\t\tif (component && component != basePlayer && !component.IsNpc && component.currentTeam == 0uL)\r\n\t\t\t{\r\n\t\t\t\tif (Interface.CallHook(\"OnTeamInvite\", basePlayer, component) != null)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tplayerTeam.SendInvite(component);\r\n\t\t\t}\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTeamRejectInvite",
      "HookName": "OnTeamRejectInvite",
      "HookParameters": {
        "basePlayer": "BasePlayer",
        "playerTeam": "PlayerTeam"
      },
      "ReturnBehavior": 1,
      "TargetType": "RelationshipManager",
      "Category": "Team",
      "MethodData": {
        "MethodName": "rejectinvite",
        "ReturnType": "void",
        "Arguments": {
          "arg": "ConsoleSystem/Arg"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (playerTeam == null)\r\n\t{\r\n\t\tbasePlayer.ClearPendingInvite();\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnTeamRejectInvite\", basePlayer, playerTeam) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tplayerTeam.RejectInvite(basePlayer);\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTeamPromote",
      "HookName": "OnTeamPromote",
      "HookParameters": {
        "playerTeam": "PlayerTeam",
        "lookingAtPlayer": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "RelationshipManager",
      "Category": "Team",
      "MethodData": {
        "MethodName": "promote",
        "ReturnType": "void",
        "Arguments": {
          "arg": "ConsoleSystem/Arg"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (lookingAtPlayer.currentTeam == basePlayer.currentTeam)\r\n\t{\r\n\t\tglobal::RelationshipManager.PlayerTeam playerTeam = global::RelationshipManager.ServerInstance.teams[basePlayer.currentTeam];\r\n\t\tif (playerTeam != null && playerTeam.teamLeader == basePlayer.userID)\r\n\t\t{\r\n\t\t\tif (Interface.CallHook(\"OnTeamPromote\", playerTeam, lookingAtPlayer) != null)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tplayerTeam.SetTeamLeader(lookingAtPlayer.userID);\r\n\t\t}\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTeamLeave",
      "HookName": "OnTeamLeave",
      "HookParameters": {
        "playerTeam": "PlayerTeam",
        "basePlayer": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "RelationshipManager",
      "Category": "Team",
      "MethodData": {
        "MethodName": "leaveteam",
        "ReturnType": "void",
        "Arguments": {
          "arg": "ConsoleSystem/Arg"
        }
      },
      "CodeAfterInjection": "...\r\n\t\treturn;\r\n\t}\r\n\tglobal::RelationshipManager.PlayerTeam playerTeam = global::RelationshipManager.ServerInstance.FindTeam(basePlayer.currentTeam);\r\n\tif (playerTeam != null)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnTeamLeave\", playerTeam, basePlayer) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tplayerTeam.RemovePlayer(basePlayer.userID);\r\n\t\tbasePlayer.ClearTeam();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTeamKick",
      "HookName": "OnTeamKick",
      "HookParameters": {
        "playerTeam": "PlayerTeam",
        "basePlayer": "BasePlayer",
        "uLong": "ulong"
      },
      "ReturnBehavior": 1,
      "TargetType": "RelationshipManager",
      "Category": "Team",
      "MethodData": {
        "MethodName": "kickmember",
        "ReturnType": "void",
        "Arguments": {
          "arg": "ConsoleSystem/Arg"
        }
      },
      "CodeAfterInjection": "...\r\n\tulong uLong = arg.GetULong(0, 0uL);\r\n\tif (basePlayer.userID == uLong)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnTeamKick\", playerTeam, basePlayer, uLong) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tplayerTeam.RemovePlayer(uLong);\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTeamAcceptInvite",
      "HookName": "OnTeamAcceptInvite",
      "HookParameters": {
        "playerTeam": "PlayerTeam",
        "basePlayer": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "RelationshipManager",
      "Category": "Team",
      "MethodData": {
        "MethodName": "acceptinvite",
        "ReturnType": "void",
        "Arguments": {
          "arg": "ConsoleSystem/Arg"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (playerTeam == null)\r\n\t{\r\n\t\tbasePlayer.ClearPendingInvite();\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnTeamAcceptInvite\", playerTeam, basePlayer) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tplayerTeam.AcceptInvite(basePlayer);\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTeamDisband",
      "HookName": "OnTeamDisband",
      "HookParameters": {
        "teamToDisband": "PlayerTeam"
      },
      "ReturnBehavior": 1,
      "TargetType": "RelationshipManager",
      "Category": "Team",
      "MethodData": {
        "MethodName": "DisbandTeam",
        "ReturnType": "void",
        "Arguments": {
          "teamToDisband": "RelationshipManager/PlayerTeam"
        }
      },
      "CodeAfterInjection": "public void DisbandTeam(global::RelationshipManager.PlayerTeam teamToDisband)\r\n{\r\n\tif (Interface.CallHook(\"OnTeamDisband\", teamToDisband) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.teams.Remove(teamToDisband.teamID);\r\n\tInterface.CallHook(\"OnTeamDisbanded\", teamToDisband);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTeamCreated",
      "HookName": "OnTeamCreated",
      "HookParameters": {
        "basePlayer": "BasePlayer",
        "relationshipManager": "RelationshipManager"
      },
      "ReturnBehavior": 0,
      "TargetType": "RelationshipManager",
      "Category": "Team",
      "MethodData": {
        "MethodName": "trycreateteam",
        "ReturnType": "void",
        "Arguments": {
          "arg": "ConsoleSystem/Arg"
        }
      },
      "CodeAfterInjection": "...\r\n\tglobal::BasePlayer basePlayer = arg.Player();\r\n\tif (basePlayer.currentTeam != 0uL)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnTeamCreate\", basePlayer) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::RelationshipManager.PlayerTeam OxideGen_2 = global::RelationshipManager.ServerInstance.CreateTeam();\r\n\tglobal::RelationshipManager.PlayerTeam playerTeam = OxideGen_2;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTeamDisbanded",
      "HookName": "OnTeamDisbanded",
      "HookParameters": {
        "teamToDisband": "PlayerTeam"
      },
      "ReturnBehavior": 0,
      "TargetType": "RelationshipManager",
      "Category": "Team",
      "MethodData": {
        "MethodName": "DisbandTeam",
        "ReturnType": "void",
        "Arguments": {
          "teamToDisband": "RelationshipManager/PlayerTeam"
        }
      },
      "CodeAfterInjection": "public void DisbandTeam(global::RelationshipManager.PlayerTeam teamToDisband)\r\n{\r\n\tif (Interface.CallHook(\"OnTeamDisband\", teamToDisband) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.teams.Remove(teamToDisband.teamID);\r\n\tInterface.CallHook(\"OnTeamDisbanded\", teamToDisband);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerLand",
      "HookName": "OnPlayerLand",
      "HookParameters": {
        "instance": "BasePlayer",
        "num": "float"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "ApplyFallDamageFromVelocity",
        "ReturnType": "void",
        "Arguments": {
          "velocity": "float"
        }
      },
      "CodeAfterInjection": "...\r\n\tfloat num = Mathf.InverseLerp(-15f, -100f, velocity);\r\n\tif (num == 0f)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnPlayerLand\", this, num) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.metabolism.bleeding.Add(num * 0.5f);\r\n\tfloat num2 = num * 500f;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerLanded",
      "HookName": "OnPlayerLanded",
      "HookParameters": {
        "instance": "BasePlayer",
        "num": "float"
      },
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "ApplyFallDamageFromVelocity",
        "ReturnType": "void",
        "Arguments": {
          "velocity": "float"
        }
      },
      "CodeAfterInjection": "...\r\n\tfloat num = Mathf.InverseLerp(-15f, -100f, velocity);\r\n\tif (num == 0f)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnPlayerLand\", this, num) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.metabolism.bleeding.Add(num * 0.5f);\r\n\tfloat num2 = num * 500f;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanDeployItem",
      "HookName": "CanDeployItem",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "Deployer",
        "networkableId": "NetworkableId"
      },
      "ReturnBehavior": 1,
      "TargetType": "Deployer",
      "Category": "Item",
      "MethodData": {
        "MethodName": "DoDeploy",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tRay ray = msg.read.Ray();\r\n\tNetworkableId networkableId = msg.read.EntityID();\r\n\tif (Interface.CallHook(\"CanDeployItem\", msg.player, this, networkableId) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (deployable.toSlot)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanSamSiteShoot",
      "HookName": "CanSamSiteShoot",
      "HookDescription": "Called when a SamSite attempts to shoot",
      "HookParameters": {
        "instance": "SamSite"
      },
      "ReturnBehavior": 1,
      "TargetType": "SamSite",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "WeaponTick",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\tthis.nextBurstTime = Time.time + timeBetweenBursts;\r\n\t\tthis.firedCount = 0;\r\n\t\treturn;\r\n\t}\r\n\tthis.EnsureReloaded();\r\n\tif (Interface.CallHook(\"CanSamSiteShoot\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!this.HasAmmo())\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnWorldPrefabSpawned",
      "HookName": "OnWorldPrefabSpawned",
      "HookParameters": {
        "gameObject": "GameObject",
        "category": "string"
      },
      "ReturnBehavior": 0,
      "TargetType": "World",
      "Category": "World",
      "MethodData": {
        "MethodName": "Spawn",
        "ReturnType": "void",
        "Arguments": {
          "category": "string",
          "prefab": "Prefab",
          "position": "UnityEngine.Vector3",
          "rotation": "UnityEngine.Quaternion",
          "scale": "UnityEngine.Vector3"
        }
      },
      "CodeAfterInjection": "...\r\n\t\tprefab.ApplyTerrainModifiers(position, rotation, scale);\r\n\t}\r\n\tGameObject gameObject = prefab.Spawn(position, rotation, scale, true);\r\n\tif (gameObject)\r\n\t{\r\n\t\tInterface.CallHook(\"OnWorldPrefabSpawned\", gameObject, category);\r\n\t\tgameObject.SetHierarchyGroup(category, true, false);\r\n\t}\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBoatPathGenerate",
      "HookName": "OnBoatPathGenerate",
      "HookParameters": {
        "instance": "BaseBoat"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseBoat",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "GenerateOceanPatrolPath",
        "ReturnType": "System.Collections.Generic.List`1<UnityEngine.Vector3>",
        "Arguments": {
          "minDistanceFromShore": "float",
          "minWaterDepth": "float"
        }
      },
      "CodeAfterInjection": "public static System.Collections.Generic.List<Vector3> GenerateOceanPatrolPath(float minDistanceFromShore = 50f, float minWaterDepth = 8f)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"OnBoatPathGenerate\");\r\n\tif (returnvar is System.Collections.Generic.List<Vector3>)\r\n\t{\r\n\t\treturn (System.Collections.Generic.List<Vector3>)returnvar;\r\n\t}\r\n\tfloat expr_28 = global::TerrainMeta.Size.x;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCollectiblePickup",
      "HookName": "OnCollectiblePickup",
      "HookParameters": {
        "instance": "CollectibleEntity",
        "reciever": "BasePlayer",
        "eat": "bool"
      },
      "ReturnBehavior": 1,
      "TargetType": "CollectibleEntity",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "DoPickup",
        "ReturnType": "void",
        "Arguments": {
          "reciever": "BasePlayer",
          "eat": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (this.itemList == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnCollectiblePickup\", this, reciever, eat) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::ItemAmount[] array = this.itemList;\r\n\tfor (int i = 0; i < array.Length; i++)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnProjectileRicochet",
      "HookName": "OnProjectileRicochet",
      "HookParameters": {
        "instance": "BasePlayer",
        "playerProjectileRicochet": "PlayerProjectileRicochet"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "OnProjectileRicochet",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\tglobal::AntiHack.Log(this, global::AntiHackType.ProjectileHack, \"Lifetime is zero (\" + playerProjectileRicochet.projectileID + \")\");\r\n\t\tplayerProjectileRicochet.ResetToPool();\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnProjectileRicochet\", this, playerProjectileRicochet) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfiredProjectile.ricochets++;\r\n\tthis.firedProjectiles[playerProjectileRicochet.projectileID] = firedProjectile;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanAffordToPlace",
      "HookName": "CanAffordToPlace",
      "HookParameters": {
        "ownerPlayer": "BasePlayer",
        "instance": "Planner",
        "component": "Construction"
      },
      "ReturnBehavior": 1,
      "TargetType": "Planner",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "CanAffordToPlace",
        "ReturnType": "bool",
        "Arguments": {
          "component": "Construction"
        }
      },
      "CodeAfterInjection": "...\r\n\tglobal::BasePlayer ownerPlayer = base.GetOwnerPlayer();\r\n\tif (!ownerPlayer)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"CanAffordToPlace\", ownerPlayer, this, component);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tforeach (global::ItemAmount current in component.defaultGrade.CostToBuild(global::BuildingGrade.Enum.None))\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanSpectateTarget",
      "HookName": "CanSpectateTarget",
      "HookParameters": {
        "instance": "BasePlayer",
        "strName": "string"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "UpdateSpectateTarget",
        "ReturnType": "void",
        "Arguments": {
          "strName": "string"
        }
      },
      "CodeAfterInjection": "public void UpdateSpectateTarget(string strName)\r\n{\r\n\tif (Interface.CallHook(\"CanSpectateTarget\", this, strName) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.spectateFilter = strName;\r\n\tSystem.Collections.Generic.IEnumerable<global::BaseEntity> source;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSwitchToggle [ElectricSwitch]",
      "HookName": "OnSwitchToggle",
      "HookDescription": "Called when a player attempts to switch on or of a Entity",
      "HookParameters": {
        "instance": "ElectricSwitch",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "ElectricSwitch",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "SVSwitch",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void SVSwitch(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tif (Interface.CallHook(\"OnSwitchToggle\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.SetSwitch(!base.IsOn());\r\n\tInterface.CallHook(\"OnSwitchToggled\", this, msg.player);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnShopAcceptClick",
      "HookName": "OnShopAcceptClick",
      "HookParameters": {
        "instance": "ShopFront",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "ShopFront",
      "Category": "Shop",
      "MethodData": {
        "MethodName": "AcceptClicked",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (this.vendorPlayer == null || this.customerPlayer == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnShopAcceptClick\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.IsPlayerVendor(msg.player))\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnShopCancelClick",
      "HookName": "OnShopCancelClick",
      "HookParameters": {
        "instance": "ShopFront",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "ShopFront",
      "Category": "Shop",
      "MethodData": {
        "MethodName": "CancelClicked",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (!this.IsTradingPlayer(msg.player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnShopCancelClick\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.vendorPlayer;\r\n\tthis.customerPlayer;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanAdministerVending [NPC]",
      "HookName": "CanAdministerVending",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "NPCVendingMachine"
      },
      "ReturnBehavior": 1,
      "TargetType": "NPCVendingMachine",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "CanPlayerAdmin",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public override bool CanPlayerAdmin(global::BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanAdministerVending\", player, this);\r\n\treturn returnvar is bool && (bool)returnvar;\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnGiveSoldItem",
      "HookName": "OnGiveSoldItem",
      "HookParameters": {
        "instance": "VendingMachine",
        "soldItem": "Item",
        "buyer": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "VendingMachine",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "GiveSoldItem",
        "ReturnType": "void",
        "Arguments": {
          "soldItem": "Item",
          "buyer": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public virtual void GiveSoldItem(global::Item soldItem, global::BasePlayer buyer)\r\n{\r\n\tif (Interface.CallHook(\"OnGiveSoldItem\", this, soldItem, buyer) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\twhile (soldItem.amount > soldItem.MaxStackable())\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanTakeCutting",
      "HookName": "CanTakeCutting",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "GrowableEntity"
      },
      "ReturnBehavior": 1,
      "TargetType": "GrowableEntity",
      "Category": "Player",
      "MethodData": {
        "MethodName": "TakeClones",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (!this.CanClone())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanTakeCutting\", player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tint num = this.Properties.BaseCloneCount + this.Genes.GetGeneTypeCount(global::GrowableGenetics.GeneType.Yield) / 2;\r\n\tif (num <= 0)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSendCommand",
      "HookName": "OnSendCommand",
      "HookParameters": {
        "cn": "Connection",
        "strCommand": "string",
        "args": "Object[]"
      },
      "ReturnBehavior": 1,
      "TargetType": "ConsoleNetwork",
      "Category": "Server",
      "MethodData": {
        "MethodName": "SendClientCommand",
        "ReturnType": "void",
        "Arguments": {
          "cn": "Network.Connection",
          "strCommand": "string",
          "args": "System.Object[]"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (!Net.sv.IsConnected())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnSendCommand\", cn, strCommand, args) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tNetWrite expr_28 = Net.sv.StartWrite();\r\n\texpr_28.PacketID(Message.Type.ConsoleCommand);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSendCommand [list]",
      "HookName": "OnSendCommand",
      "HookParameters": {
        "cn": "List`1",
        "strCommand": "string",
        "args": "Object[]"
      },
      "ReturnBehavior": 1,
      "TargetType": "ConsoleNetwork",
      "Category": "Server",
      "MethodData": {
        "MethodName": "SendClientCommand",
        "ReturnType": "void",
        "Arguments": {
          "cn": "System.Collections.Generic.List`1<Network.Connection>",
          "strCommand": "string",
          "args": "System.Object[]"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (!Net.sv.IsConnected())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnSendCommand\", cn, strCommand, args) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tNetWrite expr_28 = Net.sv.StartWrite();\r\n\texpr_28.PacketID(Message.Type.ConsoleCommand);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBroadcastCommand",
      "HookName": "OnBroadcastCommand",
      "HookParameters": {
        "strCommand": "string",
        "args": "Object[]"
      },
      "ReturnBehavior": 1,
      "TargetType": "ConsoleNetwork",
      "Category": "Server",
      "MethodData": {
        "MethodName": "BroadcastToAllClients",
        "ReturnType": "void",
        "Arguments": {
          "strCommand": "string",
          "args": "System.Object[]"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (!Net.sv.IsConnected())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnBroadcastCommand\", strCommand, args) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tNetWrite expr_27 = Net.sv.StartWrite();\r\n\texpr_27.PacketID(Message.Type.ConsoleCommand);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnVendingShopRename",
      "HookName": "OnVendingShopRename",
      "HookParameters": {
        "instance": "VendingMachine",
        "obj": "string",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "VendingMachine",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "RPC_UpdateShopName",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tglobal::BasePlayer player = msg.player;\r\n\tstring obj = msg.read.String(32);\r\n\tif (this.CanPlayerAdmin(player))\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnVendingShopRename\", this, obj, player) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis.shopName = obj;\r\n\t\tthis.UpdateMapMarker();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnNpcGiveSoldItem",
      "HookName": "OnNpcGiveSoldItem",
      "HookParameters": {
        "instance": "NPCVendingMachine",
        "soldItem": "Item",
        "buyer": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "NPCVendingMachine",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "GiveSoldItem",
        "ReturnType": "void",
        "Arguments": {
          "soldItem": "Item",
          "buyer": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public override void GiveSoldItem(global::Item soldItem, global::BasePlayer buyer)\r\n{\r\n\tif (Interface.CallHook(\"OnNpcGiveSoldItem\", this, soldItem, buyer) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.GiveSoldItem(soldItem, buyer);\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnExcavatorGather",
      "HookName": "OnExcavatorGather",
      "HookParameters": {
        "instance": "ExcavatorArm",
        "item": "Item"
      },
      "ReturnBehavior": 1,
      "TargetType": "ExcavatorArm",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "ProduceResources",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\t\tint num3 = Mathf.FloorToInt(itemAmount.amount / (float)this.outputPiles.Count);\r\n\t\t\titemAmount.amount -= (float)(num3 * 2);\r\n\t\t\tforeach (global::ExcavatorOutputPile current in this.outputPiles)\r\n\t\t\t{\r\n\t\t\t\tglobal::Item item = global::ItemManager.Create(this.resourcesToMine[this.resourceMiningIndex].itemDef, num3, 0uL);\r\n\t\t\t\tif (Interface.CallHook(\"OnExcavatorGather\", this, item) != null)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnExcavatorProduceItem(item, this);\r\n\t\t\t\tif (!item.MoveToContainer(current.inventory, -1, true, false, null, true))\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityTakeDamage [ResourceEntity]",
      "HookName": "OnEntityTakeDamage",
      "HookDescription": "Called when a entity takes damage\r\nDamage can be cancelled or modified by changing the HitInfo object but if you don't return non-null, the player's client will receive a damage indicator (if entity is a BasePlayer)",
      "HookParameters": {
        "instance": "ResourceEntity",
        "info": "HitInfo"
      },
      "ReturnBehavior": 1,
      "TargetType": "ResourceEntity",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "OnAttacked",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "public override void OnAttacked(global::HitInfo info)\r\n{\r\n\tif (base.isServer && !this.isKilled)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnEntityTakeDamage\", this, info) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (this.resourceDispenser != null)\r\n\t\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSupplyDropLanded",
      "HookName": "OnSupplyDropLanded",
      "HookDescription": "Called after Supply Drop has landed",
      "HookParameters": {
        "instance": "SupplyDrop"
      },
      "ReturnBehavior": 0,
      "TargetType": "SupplyDrop",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "OnCollisionEnter",
        "ReturnType": "void",
        "Arguments": {
          "collision": "UnityEngine.Collision"
        }
      },
      "CodeAfterInjection": "...\r\n\tif ((1 << collision.collider.gameObject.layer & 1084293393) > 0)\r\n\t{\r\n\t\tthis.RemoveParachute();\r\n\t\tthis.MakeLootable();\r\n\t}\r\n\tInterface.CallHook(\"OnSupplyDropLanded\", this);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityEnter [TriggerComfort]",
      "HookName": "OnEntityEnter",
      "HookDescription": "Called when an entity enters a trigger (water area, radiation zone, hurt zone, etc.)",
      "HookParameters": {
        "instance": "TriggerComfort",
        "ent": "BaseEntity"
      },
      "ReturnBehavior": 1,
      "TargetType": "TriggerComfort",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "OnEntityEnter",
        "ReturnType": "void",
        "Arguments": {
          "ent": "BaseEntity"
        }
      },
      "CodeAfterInjection": "...\r\n\tglobal::BasePlayer basePlayer = ent as global::BasePlayer;\r\n\tif (!basePlayer)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnEntityEnter\", this, ent) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis._players.Add(basePlayer);\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityLeave [TriggerComfort]",
      "HookName": "OnEntityLeave",
      "HookDescription": "Called when an entity leaves a trigger (water area, radiation zone, hurt zone, etc.)",
      "HookParameters": {
        "instance": "TriggerComfort",
        "ent": "BaseEntity"
      },
      "ReturnBehavior": 1,
      "TargetType": "TriggerComfort",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "OnEntityLeave",
        "ReturnType": "void",
        "Arguments": {
          "ent": "BaseEntity"
        }
      },
      "CodeAfterInjection": "...\r\n\tglobal::BasePlayer basePlayer = ent as global::BasePlayer;\r\n\tif (!basePlayer)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnEntityLeave\", this, ent) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis._players.Remove(basePlayer);\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnHelicopterStrafeEnter",
      "HookName": "OnHelicopterStrafeEnter",
      "HookParameters": {
        "instance": "PatrolHelicopterAI",
        "strafePos": "Vector3"
      },
      "ReturnBehavior": 1,
      "TargetType": "PatrolHelicopterAI",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "State_Strafe_Enter",
        "ReturnType": "void",
        "Arguments": {
          "strafePos": "UnityEngine.Vector3",
          "shouldUseNapalm": "bool"
        }
      },
      "CodeAfterInjection": "public void State_Strafe_Enter(Vector3 strafePos, bool shouldUseNapalm = false)\r\n{\r\n\tif (Interface.CallHook(\"OnHelicopterStrafeEnter\", this, strafePos) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.CanUseNapalm() & shouldUseNapalm)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerSetInfo [server]",
      "HookName": "OnPlayerSetInfo",
      "HookParameters": {
        "connection": "Connection",
        "name": "string",
        "value": "string"
      },
      "ReturnBehavior": 0,
      "TargetType": "ServerMgr",
      "Category": "Player",
      "MethodData": {
        "MethodName": "ClientReady",
        "ReturnType": "void",
        "Arguments": {
          "packet": "Network.Message"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tusing (ClientReady clientReady = ClientReady.Deserialize(packet.read))\r\n\t{\r\n\t\tforeach (ClientReady.ClientInfo current in clientReady.clientInfo)\r\n\t\t{\r\n\t\t\tInterface.CallHook(\"OnPlayerSetInfo\", packet.connection, current.name, current.value);\r\n\t\t\tpacket.connection.info.Set(current.name, current.value);\r\n\t\t}\r\n\t\tthis.connectionQueue.JoinedGame(packet.connection);\r\n\t\tFacepunch.Rust.Analytics.Azure.OnPlayerConnected(packet.connection);\r\n\t\tusing (TimeWarning.New(\"ClientReady\", 0))\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerSetInfo",
      "HookName": "OnPlayerSetInfo",
      "HookParameters": {
        "connection": "Connection",
        "key": "string",
        "val": "string"
      },
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "SetInfo",
        "ReturnType": "void",
        "Arguments": {
          "key": "string",
          "val": "string"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (!this.IsConnected)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tInterface.CallHook(\"OnPlayerSetInfo\", this.net.connection, key, val);\r\n\tthis.net.connection.info.Set(key, val);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTakeCurrencyItem",
      "HookName": "OnTakeCurrencyItem",
      "HookParameters": {
        "instance": "VendingMachine",
        "takenCurrencyItem": "Item"
      },
      "ReturnBehavior": 1,
      "TargetType": "VendingMachine",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "TakeCurrencyItem",
        "ReturnType": "void",
        "Arguments": {
          "takenCurrencyItem": "Item"
        }
      },
      "CodeAfterInjection": "public virtual void TakeCurrencyItem(global::Item takenCurrencyItem)\r\n{\r\n\tif (Interface.CallHook(\"OnTakeCurrencyItem\", this, takenCurrencyItem) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!takenCurrencyItem.MoveToContainer(base.inventory, -1, true, false, null, true))\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTakeCurrencyItem [NPC]",
      "HookName": "OnTakeCurrencyItem",
      "HookParameters": {
        "instance": "NPCVendingMachine",
        "takenCurrencyItem": "Item"
      },
      "ReturnBehavior": 1,
      "TargetType": "NPCVendingMachine",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "TakeCurrencyItem",
        "ReturnType": "void",
        "Arguments": {
          "takenCurrencyItem": "Item"
        }
      },
      "CodeAfterInjection": "public override void TakeCurrencyItem(global::Item takenCurrencyItem)\r\n{\r\n\tif (Interface.CallHook(\"OnTakeCurrencyItem\", this, takenCurrencyItem) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\ttakenCurrencyItem.MoveToContainer(base.inventory, -1, true, false, null, true);\r\n\ttakenCurrencyItem.RemoveFromContainer();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityStabilityCheck",
      "HookName": "OnEntityStabilityCheck",
      "HookDescription": "Called when stability of an entity is checked",
      "HookParameters": {
        "instance": "StabilityEntity"
      },
      "ReturnBehavior": 1,
      "TargetType": "StabilityEntity",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "StabilityCheck",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (base.IsDestroyed)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnEntityStabilityCheck\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.supports == null)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPayForUpgrade",
      "HookName": "OnPayForUpgrade",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "BuildingBlock",
        "g": "ConstructionGrade"
      },
      "ReturnBehavior": 1,
      "TargetType": "BuildingBlock",
      "Category": "Player",
      "MethodData": {
        "MethodName": "PayForUpgrade",
        "ReturnType": "void",
        "Arguments": {
          "g": "ConstructionGrade",
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "private void PayForUpgrade(global::ConstructionGrade g, global::BasePlayer player)\r\n{\r\n\tif (Interface.CallHook(\"OnPayForUpgrade\", player, this, g) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tSystem.Collections.Generic.List<global::Item> list = new System.Collections.Generic.List<global::Item>();\r\n\tforeach (global::ItemAmount current in g.CostToBuild(this.grade))\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPayForPlacement",
      "HookName": "OnPayForPlacement",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "Planner",
        "component": "Construction"
      },
      "ReturnBehavior": 1,
      "TargetType": "Planner",
      "Category": "Player",
      "MethodData": {
        "MethodName": "PayForPlacement",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer",
          "component": "Construction"
        }
      },
      "CodeAfterInjection": "public void PayForPlacement(global::BasePlayer player, global::Construction component)\r\n{\r\n\tif (Interface.CallHook(\"OnPayForPlacement\", player, this, component) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.isTypeDeployable)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityDeath [ResourceEntity]",
      "HookName": "OnEntityDeath",
      "HookDescription": "Called when an entity dies\r\nHitInfo might be null, check it before use\r\nEditing hitInfo has no effect because the death has already happened",
      "HookParameters": {
        "instance": "ResourceEntity",
        "info": "HitInfo"
      },
      "ReturnBehavior": 0,
      "TargetType": "ResourceEntity",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "OnKilled",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "public virtual void OnKilled(global::HitInfo info)\r\n{\r\n\tthis.isKilled = true;\r\n\tInterface.CallHook(\"OnEntityDeath\", this, info);\r\n\tbase.Kill(global::BaseNetworkable.DestroyMode.None);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTeamUpdate",
      "HookName": "OnTeamUpdate",
      "HookParameters": {
        "currentTeam": "ulong",
        "newTeam": "ulong",
        "instance": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Team",
      "MethodData": {
        "MethodName": "UpdateTeam",
        "ReturnType": "void",
        "Arguments": {
          "newTeam": "ulong"
        }
      },
      "CodeAfterInjection": "public void UpdateTeam(ulong newTeam)\r\n{\r\n\tif (Interface.CallHook(\"OnTeamUpdate\", this.currentTeam, newTeam, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.currentTeam = newTeam;\r\n\tbase.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTeamUpdated",
      "HookName": "OnTeamUpdated",
      "HookParameters": {
        "currentTeam": "ulong",
        "playerTeam2": "PlayerTeam",
        "instance": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Team",
      "MethodData": {
        "MethodName": "TeamUpdate",
        "ReturnType": "void",
        "Arguments": {
          "fullTeamUpdate": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t\t\tforeach (MapNote current2 in playerState.pointsOfInterest)\r\n\t\t\t\t{\r\n\t\t\t\t\tplayerTeam2.leaderMapNotes.Add(current2);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (Interface.CallHook(\"OnTeamUpdated\", this.currentTeam, playerTeam2, this) != null)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tbase.ClientRPCPlayerAndSpectators<PlayerTeam>(null, this, \"CLIENT_ReceiveTeamInfo\", playerTeam2);\r\n\t\t\tif (playerTeam2.leaderMapNotes != null)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnExplosiveFuseSet",
      "HookName": "OnExplosiveFuseSet",
      "HookParameters": {
        "instance": "TimedExplosive",
        "fuseLength": "float"
      },
      "ReturnBehavior": 3,
      "TargetType": "TimedExplosive",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "SetFuse",
        "ReturnType": "void",
        "Arguments": {
          "fuseLength": "float"
        }
      },
      "CodeAfterInjection": "public virtual void SetFuse(float fuseLength)\r\n{\r\n\tif (base.isServer)\r\n\t{\r\n\t\tobject returnvar = Interface.CallHook(\"OnExplosiveFuseSet\", this, fuseLength);\r\n\t\tif (returnvar is float)\r\n\t\t{\r\n\t\t\tfuseLength = (float)returnvar;\r\n\t\t}\r\n\t\tbase.Invoke(new System.Action(this.Explode), fuseLength);\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnExplosiveDud",
      "HookName": "OnExplosiveDud",
      "ReturnBehavior": 0,
      "TargetType": "DudTimedExplosive",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "Explode",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tif (this.creatorEntity != null && this.creatorEntity.IsNpc)\r\n\t{\r\n\t\tbase.Explode();\r\n\t\treturn;\r\n\t}\r\n\tif (UnityEngine.Random.Range(0f, 1f) < this.dudChance && Interface.CallHook(\"OnExplosiveDud\", this) == null)\r\n\t{\r\n\t\tthis.BecomeDud();\r\n\t\treturn;\r\n\t}\r\n\tbase.Explode();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerAssist",
      "HookName": "OnPlayerAssist",
      "HookParameters": {
        "instance": "BasePlayer",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RPC_Assist",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (!this.IsWounded())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnPlayerAssist\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.StopWounded(msg.player);\r\n\tmsg.player.stats.Add(\"wounded_assisted\", 1, (global::Stats)5);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerKeepAlive",
      "HookName": "OnPlayerKeepAlive",
      "HookParameters": {
        "instance": "BasePlayer",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RPC_KeepAlive",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (!this.IsWounded())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnPlayerKeepAlive\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.ProlongWounding(10f);\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnExcavatorMiningToggled [start]",
      "HookName": "OnExcavatorMiningToggled",
      "HookParameters": {
        "instance": "ExcavatorArm"
      },
      "ReturnBehavior": 0,
      "TargetType": "ExcavatorArm",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "BeginMining",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\tthis.nextNotificationTime = Time.time + 60f;\r\n\t}\r\n\tglobal::ExcavatorServerEffects.SetMining(true, false);\r\n\tFacepunch.Rust.Analytics.Server.ExcavatorStarted();\r\n\tthis.excavatorStartTime = this.GetNetworkTime();\r\n\tInterface.CallHook(\"OnExcavatorMiningToggled\", this);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnExcavatorMiningToggled [stop]",
      "HookName": "OnExcavatorMiningToggled",
      "HookParameters": {
        "instance": "ExcavatorArm"
      },
      "ReturnBehavior": 0,
      "TargetType": "ExcavatorArm",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "StopMining",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tif (base.HasFlag(global::BaseEntity.Flags.On))\r\n\t{\r\n\t\tFacepunch.Rust.Analytics.Server.ExcavatorStopped(this.GetNetworkTime() - this.excavatorStartTime);\r\n\t}\r\n\tbase.SetFlag(global::BaseEntity.Flags.On, false, false, true);\r\n\tInterface.CallHook(\"OnExcavatorMiningToggled\", this);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnExcavatorResourceSet",
      "HookName": "OnExcavatorResourceSet",
      "HookParameters": {
        "instance": "ExcavatorArm",
        "text": "string",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "ExcavatorArm",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "RPC_SetResourceTarget",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.MaxDistance(3f)]\r\npublic void RPC_SetResourceTarget(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tstring text = msg.read.String(256);\r\n\tif (Interface.CallHook(\"OnExcavatorResourceSet\", this, text, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (text == \"HQM\")\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnDieselEngineToggled [off]",
      "HookName": "OnDieselEngineToggled",
      "HookDescription": "Called when diesel engine is toggled",
      "HookParameters": {
        "instance": "DieselEngine"
      },
      "ReturnBehavior": 0,
      "TargetType": "DieselEngine",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "EngineOff",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void EngineOff()\r\n{\r\n\tbase.SetFlag(global::BaseEntity.Flags.On, false, false, true);\r\n\tbase.BroadcastEntityMessage(\"DieselEngineOff\", 20f, 1218652417);\r\n\tInterface.CallHook(\"OnDieselEngineToggled\", this);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnDieselEngineToggled [on]",
      "HookName": "OnDieselEngineToggled",
      "HookDescription": "Called when diesel engine is toggled",
      "HookParameters": {
        "instance": "DieselEngine"
      },
      "ReturnBehavior": 0,
      "TargetType": "DieselEngine",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "EngineOn",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void EngineOn()\r\n{\r\n\tbase.SetFlag(global::BaseEntity.Flags.On, true, false, true);\r\n\tbase.BroadcastEntityMessage(\"DieselEngineOn\", 20f, 1218652417);\r\n\tInterface.CallHook(\"OnDieselEngineToggled\", this);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnDieselEngineToggle",
      "HookName": "OnDieselEngineToggle",
      "HookDescription": "Called when a player is trying to toggle diesel engine",
      "HookParameters": {
        "instance": "DieselEngine",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "DieselEngine",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "EngineSwitch",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.IsVisible(6f)]\r\npublic void EngineSwitch(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tif (Interface.CallHook(\"OnDieselEngineToggle\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (msg.read.Bit())\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnActiveItemChanged",
      "HookName": "OnActiveItemChanged",
      "HookParameters": {
        "instance": "BasePlayer",
        "activeItem": "Item",
        "heldEntity": "Item"
      },
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "UpdateActiveItem",
        "ReturnType": "void",
        "Arguments": {
          "itemID": "ItemId"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (this.IsItemHoldRestricted(item))\r\n\t{\r\n\t\titemID = default(ItemId);\r\n\t}\r\n\tglobal::Item activeItem = this.GetActiveItem();\r\n\tif (Interface.CallHook(\"OnActiveItemChange\", this, activeItem, itemID) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.svActiveItemID = default(ItemId);\r\n\tif (activeItem != null)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnAmmoUnload",
      "HookName": "OnAmmoUnload",
      "HookParameters": {
        "component": "BaseProjectile",
        "item": "Item",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseProjectile",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "UnloadAmmo",
        "ReturnType": "void",
        "Arguments": {
          "item": "Item",
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "...\r\n\tglobal::BaseProjectile component = item.GetHeldEntity().GetComponent<global::BaseProjectile>();\r\n\tif (!component.canUnloadAmmo)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnAmmoUnload\", component, item, player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (component)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnOutputUpdate",
      "HookName": "OnOutputUpdate",
      "HookDescription": "Called when outputs of IOEntity are updated",
      "HookParameters": {
        "instance": "IOEntity"
      },
      "ReturnBehavior": 1,
      "TargetType": "IOEntity",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "UpdateOutputs",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public virtual void UpdateOutputs()\r\n{\r\n\tif (Interface.CallHook(\"OnOutputUpdate\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!this.ShouldUpdateOutputs())\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnInputUpdate",
      "HookName": "OnInputUpdate",
      "HookDescription": "Called when an input of IOEntity is updated",
      "HookParameters": {
        "instance": "IOEntity",
        "inputAmount": "Int32",
        "inputSlot": "Int32"
      },
      "ReturnBehavior": 1,
      "TargetType": "IOEntity",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "UpdateFromInput",
        "ReturnType": "void",
        "Arguments": {
          "inputAmount": "int",
          "inputSlot": "int"
        }
      },
      "CodeAfterInjection": "public virtual void UpdateFromInput(int inputAmount, int inputSlot)\r\n{\r\n\tif (Interface.CallHook(\"OnInputUpdate\", this, inputAmount, inputSlot) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.inputs[inputSlot].type != this.ioType || this.inputs[inputSlot].type == global::IOEntity.IOType.Industrial)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCardSwipe",
      "HookName": "OnCardSwipe",
      "HookDescription": "Called when a player is trying to swipe a card",
      "HookParameters": {
        "instance": "CardReader",
        "keycard": "Keycard",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "CardReader",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "ServerCardSwiped",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tNetworkableId uid = msg.read.EntityID();\r\n\tglobal::Keycard keycard = global::BaseNetworkable.serverEntities.Find(uid) as global::Keycard;\r\n\tglobal::Effect.server.Run(this.swipeEffect.resourcePath, this.audioPosition.position, Vector3.up, msg.player.net.connection, false);\r\n\tif (keycard != null)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnCardSwipe\", this, keycard, msg.player) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tglobal::Item item = keycard.GetItem();\r\n\t\tif (item != null && keycard.accessLevel == this.accessLevel && item.conditionNormalized > 0f)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnButtonPress",
      "HookName": "OnButtonPress",
      "HookDescription": "Called when a player is trying to press a button",
      "HookParameters": {
        "instance": "PressButton",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "PressButton",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "Press",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (base.IsOn())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnButtonPress\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.SetFlag(global::BaseEntity.Flags.On, true, false, true);\r\n\tbase.Invoke(new System.Action(this.UnpowerTime), this.pressPowerTime);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMapMarkersClear",
      "HookName": "OnMapMarkersClear",
      "HookParameters": {
        "instance": "BasePlayer",
        "pointsOfInterest": "List`1"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "Server_ClearMapMarkers",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.CallsPerSecond(1uL), global::BaseEntity.RPC_Server.FromOwner]\r\npublic void Server_ClearMapMarkers(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tif (Interface.CallHook(\"OnMapMarkersClear\", this, this.State.pointsOfInterest) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tMapNote expr_20 = this.ServerCurrentDeathNote;\r\n\tif (expr_20 != null)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMapMarkersCleared",
      "HookName": "OnMapMarkersCleared",
      "HookParameters": {
        "instance": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "Server_ClearMapMarkers",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.CallsPerSecond(1uL), global::BaseEntity.RPC_Server.FromOwner]\r\npublic void Server_ClearMapMarkers(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tif (Interface.CallHook(\"OnMapMarkersClear\", this, this.State.pointsOfInterest) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tMapNote expr_20 = this.ServerCurrentDeathNote;\r\n\tif (expr_20 != null)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerReported",
      "HookName": "OnPlayerReported",
      "HookParameters": {
        "instance": "BasePlayer",
        "text5": "string",
        "text4": "string",
        "text": "string",
        "text2": "string",
        "text3": "string"
      },
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "OnPlayerReported",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t\tTargetName = text5,\r\n\t\tSubject = text,\r\n\t\tMessage = text2,\r\n\t\tType = text3\r\n\t});\r\n\tInterface.CallHook(\"OnPlayerReported\", this, text5, text4, text, text2, text3);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "CanNetworkTo [BaseEntity]",
      "HookName": "CanNetworkTo",
      "HookParameters": {
        "instance": "BaseEntity",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseEntity",
      "Category": "Network",
      "MethodData": {
        "MethodName": "ShouldNetworkTo",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (!(parentEntity != null))\r\n\t{\r\n\t\treturn base.ShouldNetworkTo(player);\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"CanNetworkTo\", this, player);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn parentEntity.ShouldNetworkTo(player);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanNetworkTo [BasePlayer]",
      "HookName": "CanNetworkTo",
      "HookParameters": {
        "instance": "BasePlayer",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "ShouldNetworkTo",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public override bool ShouldNetworkTo(global::BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanNetworkTo\", this, player);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn (!this.IsSpectating() || !(player != this) || player.net.connection.info.GetBool(\"global.specnet\", false)) && base.ShouldNetworkTo(player);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "IOnPlayerCommand",
      "HookName": "IOnPlayerCommand",
      "HookParameters": {
        "player": "BasePlayer",
        "message": "string"
      },
      "ReturnBehavior": 0,
      "TargetType": "ConVar.Chat",
      "Category": "Player",
      "MethodData": {
        "MethodName": "sayAs",
        "ReturnType": "bool",
        "Arguments": {
          "targetChannel": "ConVar.Chat/ChatChannel",
          "userId": "ulong",
          "username": "string",
          "message": "string",
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (text.StartsWith(\"/\") || text.StartsWith(\"\\\\\"))\r\n\t{\r\n\t\tInterface.CallHook(\"IOnPlayerCommand\", player, message);\r\n\t\treturn false;\r\n\t}\r\n\ttext = text.EscapeRichText();\r\n\tobject returnvar = Interface.CallHook(\"IOnPlayerChat\", userId, username, text, targetChannel, player);\r\n\tif (returnvar is bool)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "IOnPlayerChat",
      "HookName": "IOnPlayerChat",
      "HookParameters": {
        "userId": "ulong",
        "username": "string",
        "userGroup": "string",
        "targetChannel": "ChatChannel",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "ConVar.Chat",
      "Category": "Player",
      "MethodData": {
        "MethodName": "sayAs",
        "ReturnType": "bool",
        "Arguments": {
          "targetChannel": "ConVar.Chat/ChatChannel",
          "userId": "ulong",
          "username": "string",
          "message": "string",
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (text.StartsWith(\"/\") || text.StartsWith(\"\\\\\"))\r\n\t{\r\n\t\tInterface.CallHook(\"IOnPlayerCommand\", player, message);\r\n\t\treturn false;\r\n\t}\r\n\ttext = text.EscapeRichText();\r\n\tobject returnvar = Interface.CallHook(\"IOnPlayerChat\", userId, username, text, targetChannel, player);\r\n\tif (returnvar is bool)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnWireConnect",
      "HookName": "OnWireConnect",
      "HookParameters": {
        "player": "BasePlayer",
        "num3": "BaseNetworkable",
        "item": "int",
        "baseNetworkable": "BaseNetworkable",
        "num2": "int",
        "list": "List`1"
      },
      "ReturnBehavior": 1,
      "TargetType": "WireTool",
      "Category": "Player",
      "MethodData": {
        "MethodName": "MakeConnection",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (!global::WireTool.CanModifyEntity(player, iOEntity2))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnWireConnect\", player, baseNetworkable, num2, baseNetworkable2, num3, list) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tiOEntity.inputs[num2].connectedTo.Set(iOEntity2);\r\n\tiOEntity.inputs[num2].connectedToSlot = num3;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnWireClear",
      "HookName": "OnWireClear",
      "HookParameters": {
        "ply": "BasePlayer",
        "iOEntity": "IOEntity",
        "clearIndex": "int",
        "iOEntity2": "IOEntity",
        "isInput": "bool"
      },
      "ReturnBehavior": 1,
      "TargetType": "WireTool",
      "Category": "Player",
      "MethodData": {
        "MethodName": "AttemptClearSlot",
        "ReturnType": "void",
        "Arguments": {
          "clearEnt": "BaseNetworkable",
          "ply": "BasePlayer",
          "clearIndex": "int",
          "isInput": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (iOSlot.connectedTo.Get(true) == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::IOEntity iOEntity2 = iOSlot.connectedTo.Get(true);\r\n\tif (Interface.CallHook(\"OnWireClear\", ply, iOEntity, clearIndex, iOEntity2, isInput) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::IOEntity.IOSlot arg_E5_0 = isInput ? iOEntity2.outputs[iOSlot.connectedToSlot] : iOEntity2.inputs[iOSlot.connectedToSlot];\r\n\tif (isInput)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanUseWires",
      "HookName": "CanUseWires",
      "HookParameters": {
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "WireTool",
      "Category": "Player",
      "MethodData": {
        "MethodName": "CanPlayerUseWires",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public static bool CanPlayerUseWires(global::BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanUseWires\", player);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif (!player.CanBuild())\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnHorseLead",
      "HookName": "OnHorseLead",
      "HookDescription": "Called when a player attempts to lead a horse",
      "HookParameters": {
        "instance": "BaseRidableAnimal",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseRidableAnimal",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "RPC_Lead",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tbool flag = msg.read.Bit();\r\n\tif (arg_36_0 == flag)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnHorseLead\", this, player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.SetLeading(flag ? player : null);\r\n\tthis.LeadingChanged();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerRespawn [SleepingBag]",
      "HookName": "OnPlayerRespawn",
      "HookParameters": {
        "player": "BasePlayer",
        "sleepingBag2": "SleepingBag"
      },
      "ReturnBehavior": 3,
      "TargetType": "SleepingBag",
      "Category": "Player",
      "MethodData": {
        "MethodName": "SpawnPlayer",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer",
          "sleepingBag": "NetworkableId"
        }
      },
      "CodeAfterInjection": "...\r\n\tglobal::SleepingBag sleepingBag2 = array.FirstOrDefault((global::SleepingBag x) => x.ValidForPlayer(player.userID, false) && x.net.ID == sleepingBag && x.unlockTime < Time.realtimeSinceStartup);\r\n\tif (sleepingBag2 == null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"OnPlayerRespawn\", player2, sleepingBag2);\r\n\tif (returnvar is global::SleepingBag)\r\n\t{\r\n\t\tsleepingBag2 = (global::SleepingBag)returnvar;\r\n\t}\r\n\tif (sleepingBag2.IsOccupied())\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPhoneNameUpdate",
      "HookName": "OnPhoneNameUpdate",
      "HookDescription": "Called when a player attempts to update a phones name",
      "HookParameters": {
        "instance": "PhoneController",
        "text": "string",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "PhoneController",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "UpdatePhoneName",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tstring text = msg.read.String(256);\r\n\tif (text.Length > 20)\r\n\t{\r\n\t\ttext = text.Substring(0, 20);\r\n\t}\r\n\tif (Interface.CallHook(\"OnPhoneNameUpdate\", this, text, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.PhoneName = text;\r\n\tbase.baseEntity.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnQuarryToggled [on]",
      "HookName": "OnQuarryToggled",
      "ReturnBehavior": 0,
      "TargetType": "EngineSwitch",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "StartEngine",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tglobal::MiningQuarry miningQuarry = base.GetParentEntity() as global::MiningQuarry;\r\n\tif (miningQuarry)\r\n\t{\r\n\t\tminingQuarry.EngineSwitch(true);\r\n\t\tInterface.CallHook(\"OnQuarryToggled\", miningQuarry, msg.player);\r\n\t}\r\n}\r\n\r\n"
    },
    {
      "Type": 1,
      "Name": "OnQuarryToggled [off]",
      "HookName": "OnQuarryToggled",
      "ReturnBehavior": 0,
      "TargetType": "EngineSwitch",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "StopEngine",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tglobal::MiningQuarry miningQuarry = base.GetParentEntity() as global::MiningQuarry;\r\n\tif (miningQuarry)\r\n\t{\r\n\t\tminingQuarry.EngineSwitch(false);\r\n\t\tInterface.CallHook(\"OnQuarryToggled\", miningQuarry, msg.player);\r\n\t}\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBuildingPrivilege",
      "HookName": "OnBuildingPrivilege",
      "HookDescription": "Useful for overriding a building privilege on specific entities and etc",
      "HookParameters": {
        "instance": "BaseEntity",
        "obb": "OBB"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseEntity",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "GetBuildingPrivilege",
        "ReturnType": "BuildingPrivlidge",
        "Arguments": {
          "obb": "OBB"
        }
      },
      "CodeAfterInjection": "public global::BuildingPrivlidge GetBuildingPrivilege(OBB obb)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"OnBuildingPrivilege\", this, obb);\r\n\tif (returnvar is global::BuildingPrivlidge)\r\n\t{\r\n\t\treturn (global::BuildingPrivlidge)returnvar;\r\n\t}\r\n\tglobal::BuildingBlock other = null;\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnSignalBroadcast",
      "HookName": "OnSignalBroadcast",
      "ReturnBehavior": 0,
      "TargetType": "BaseEntity",
      "Category": "Network",
      "MethodData": {
        "MethodName": "SignalBroadcast",
        "ReturnType": "void",
        "Arguments": {
          "signal": "BaseEntity/Signal",
          "sourceConnection": "Network.Connection"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (this.net.group == null || base.limitNetworking)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnSignalBroadcast\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.ClientRPCEx<int>(new SendInfo(this.net.group.subscribers)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnSignalBroadcast",
      "HookName": "OnSignalBroadcast",
      "ReturnBehavior": 0,
      "TargetType": "BaseEntity",
      "Category": "Player",
      "MethodData": {
        "MethodName": "SignalBroadcast",
        "ReturnType": "void",
        "Arguments": {
          "signal": "BaseEntity/Signal",
          "arg": "string",
          "sourceConnection": "Network.Connection"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (this.net.group == null || base.limitNetworking)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnSignalBroadcast\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.ClientRPCEx<int, string>(new SendInfo(this.net.group.subscribers)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnHelicopterRetire",
      "HookName": "OnHelicopterRetire",
      "HookParameters": {
        "instance": "PatrolHelicopterAI"
      },
      "ReturnBehavior": 1,
      "TargetType": "PatrolHelicopterAI",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "Retire",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (this.isRetiring)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnHelicopterRetire\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.isRetiring = true;\r\n\tbase.Invoke(new System.Action(this.DestroyMe), 240f);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCupboardProtectionCalculated",
      "HookName": "OnCupboardProtectionCalculated",
      "HookParameters": {
        "instance": "BuildingPrivlidge",
        "cachedProtectedMinutes": "float"
      },
      "ReturnBehavior": 0,
      "TargetType": "BuildingPrivlidge",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "GetProtectedMinutes",
        "ReturnType": "float",
        "Arguments": {
          "force": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t\tnum2 = 0f;\r\n\t\t}\r\n\t}\r\n\tPool.FreeList<global::ItemAmount>(ref list);\r\n\tthis.cachedProtectedMinutes = num2;\r\n\tInterface.CallHook(\"OnCupboardProtectionCalculated\", this, this.cachedProtectedMinutes);\r\n\treturn this.cachedProtectedMinutes;\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCargoShipEgress",
      "HookName": "OnCargoShipEgress",
      "HookDescription": "Called when a CargoShip attempts to leave the map",
      "HookParameters": {
        "instance": "CargoShip"
      },
      "ReturnBehavior": 1,
      "TargetType": "CargoShip",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "StartEgress",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (this.egressing)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnCargoShipEgress\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.egressing = true;\r\n\tbase.CancelInvoke(new System.Action(this.PlayHorn));\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCargoShipSpawnCrate",
      "HookName": "OnCargoShipSpawnCrate",
      "HookDescription": "Called when loot on a CargoShip is about to respawn",
      "HookParameters": {
        "instance": "CargoShip"
      },
      "ReturnBehavior": 1,
      "TargetType": "CargoShip",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "RespawnLoot",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void RespawnLoot()\r\n{\r\n\tif (Interface.CallHook(\"OnCargoShipSpawnCrate\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.InvokeRepeating(new System.Action(this.PlayHorn), 0f, 8f);\r\n\tthis.SpawnCrate(this.lockedCratePrefab.resourcePath);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnNpcRadioChatter [ScientistNPC]",
      "HookName": "OnNpcRadioChatter",
      "HookParameters": {
        "instance": "ScientistNPC"
      },
      "ReturnBehavior": 1,
      "TargetType": "ScientistNPC",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "PlayRadioChatter",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tif (base.IsDestroyed || base.transform == null)\r\n\t{\r\n\t\tbase.CancelInvoke(new System.Action(this.PlayRadioChatter));\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnNpcRadioChatter\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::Effect.server.Run(this.RadioChatterEffects[UnityEngine.Random.Range(0, this.RadioChatterEffects.Length)].resourcePath, this, global::StringPool.Get(\"head\"), Vector3.zero, Vector3.zero, null, false);\r\n\tthis.QueueRadioChatter();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnNpcAlert [ScientistNPC]",
      "HookName": "OnNpcAlert",
      "HookParameters": {
        "instance": "ScientistNPC"
      },
      "ReturnBehavior": 1,
      "TargetType": "ScientistNPC",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "Alert",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void Alert()\r\n{\r\n\tif (Interface.CallHook(\"OnNpcAlert\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.lastAlertedTime = Time.time;\r\n\tthis.SetChatterType(global::ScientistNPC.RadioChatterType.Alert);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityDestroy [BradleyAPC]",
      "HookName": "OnEntityDestroy",
      "HookDescription": "Called right before a BradleyAPC is destroyed",
      "HookParameters": {
        "instance": "BradleyAPC"
      },
      "ReturnBehavior": 1,
      "TargetType": "BradleyAPC",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "OnKilled",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (base.isClient)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnEntityDestroy\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.CreateExplosionMarker(10f);\r\n\tglobal::Effect.server.Run(this.explosionEffect.resourcePath, this.mainTurretEyePos.transform.position, Vector3.up, null, true);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnNpcEquipWeapon [NPCPlayer]",
      "HookName": "OnNpcEquipWeapon",
      "HookParameters": {
        "instance": "NPCPlayer",
        "slot": "Item"
      },
      "ReturnBehavior": 1,
      "TargetType": "NPCPlayer",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "EquipWeapon",
        "ReturnType": "void",
        "Arguments": {
          "skipDeployDelay": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (this.inventory == null || this.inventory.containerBelt == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::Item slot = this.inventory.containerBelt.GetSlot(0);\r\n\tif (Interface.CallHook(\"OnNpcEquipWeapon\", this, slot) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (slot != null)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnNpcEquipWeapon [ScientistNPC]",
      "HookName": "OnNpcEquipWeapon",
      "HookParameters": {
        "instance": "ScientistNPC",
        "item": "Item"
      },
      "ReturnBehavior": 1,
      "TargetType": "ScientistNPC",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "EquipWeapon",
        "ReturnType": "void",
        "Arguments": {
          "skipDeployDelay": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (heldEntity != null)\r\n\t{\r\n\t\tglobal::Item item = heldEntity.GetItem();\r\n\t\tif (item != null && item.contents != null)\r\n\t\t{\r\n\t\t\tif (Interface.CallHook(\"OnNpcEquipWeapon\", this, item) != null)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tif (UnityEngine.Random.Range(0, 3) == 0)\r\n\t\t\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnNpcDuck [HumanNPC]",
      "HookName": "OnNpcDuck",
      "HookParameters": {
        "instance": "HumanNPC"
      },
      "ReturnBehavior": 1,
      "TargetType": "HumanNPC",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "SetDucked",
        "ReturnType": "void",
        "Arguments": {
          "flag": "bool"
        }
      },
      "CodeAfterInjection": "public void SetDucked(bool flag)\r\n{\r\n\tif (Interface.CallHook(\"OnNpcDuck\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.modelState.ducked = flag;\r\n\tbase.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityDeath [BaseCombatEntity]",
      "HookName": "OnEntityDeath",
      "HookDescription": "Called when an entity dies\r\nHitInfo might be null, check it before use\r\nEditing hitInfo has no effect because the death has already happened",
      "HookParameters": {
        "instance": "BaseCombatEntity",
        "info": "HitInfo"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseCombatEntity",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "Die",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\tDebug.Log(\"[Combat]\".PadRight(10) + base.gameObject.name + \" died\");\r\n\t}\r\n\tthis.health = 0f;\r\n\tthis.lifestate = global::BaseCombatEntity.LifeState.Dead;\r\n\tInterface.CallHook(\"OnEntityDeath\", this, info);\r\n\tif (info != null && info.InitiatorPlayer)\r\n\t{\r\n\t\tglobal::BasePlayer initiatorPlayer = info.InitiatorPlayer;\r\n\t\tif (initiatorPlayer != null && initiatorPlayer.GetActiveMission() != -1 && !initiatorPlayer.IsNpc)\r\n\t\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSwitchToggle [FuelGenerator]",
      "HookName": "OnSwitchToggle",
      "HookDescription": "Called when a player attempts to switch on or of a Entity",
      "HookParameters": {
        "instance": "FuelGenerator",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "FuelGenerator",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "RPC_EngineSwitch",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void RPC_EngineSwitch(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tif (Interface.CallHook(\"OnSwitchToggle\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbool generatorState = msg.read.Bit();\r\n\tthis.SetGeneratorState(generatorState);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerWantsDismount",
      "HookName": "OnPlayerWantsDismount",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "BaseMountable"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseMountable",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RPC_WantsDismount",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\npublic void RPC_WantsDismount(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tglobal::BasePlayer player = msg.player;\r\n\tif (!this.HasValidDismountPosition(player))\r\n\t{\r\n\t\tInterface.CallHook(\"OnPlayerDismountFailed\", player, this);\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnPlayerWantsDismount\", player, this) != null)\r\n\t{\r\n\t\treturn;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerWantsMount",
      "HookName": "OnPlayerWantsMount",
      "HookParameters": {
        "baseVehicle": "BaseVehicle",
        "instance": "BaseMountable"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseMountable",
      "Category": "Player",
      "MethodData": {
        "MethodName": "WantsMount",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t{\r\n\t\t\tbaseVehicle.WantsMount(player);\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\tif (Interface.CallHook(\"OnPlayerWantsMount\", baseVehicle, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.AttemptMount(player, true);\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerStudyBlueprint",
      "HookName": "OnPlayerStudyBlueprint",
      "HookParameters": {
        "player": "BasePlayer",
        "item": "Item"
      },
      "ReturnBehavior": 1,
      "TargetType": "ItemModStudyBlueprint",
      "Category": "Player",
      "MethodData": {
        "MethodName": "ServerCommand",
        "ReturnType": "void",
        "Arguments": {
          "item": "Item",
          "command": "string",
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t}\r\n\t\tif (flag2)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (Interface.CallHook(\"OnPlayerStudyBlueprint\", player, item) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tglobal::Item item2 = item;\r\n\t\tif (item.amount > 1)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "IOnPlayerConnected",
      "HookName": "IOnPlayerConnected",
      "HookParameters": {
        "instance": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "PlayerInit",
        "ReturnType": "void",
        "Arguments": {
          "c": "Network.Connection"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t}\r\n\t\tif (this.net != null)\r\n\t\t{\r\n\t\t\tglobal::EACServer.OnStartLoading(this.net.connection);\r\n\t\t}\r\n\t\tInterface.CallHook(\"IOnPlayerConnected\", this);\r\n\t\tif (this.IsAdmin)\r\n\t\t{\r\n\t\t\tif (ConVar.AntiHack.noclip_protection <= 0)\r\n\t\t\t{\r\n\t\t\t\tthis.ChatMessage(\"antihack.noclip_protection is disabled!\");\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityMarkHostile [BasePlayer]",
      "HookName": "OnEntityMarkHostile",
      "HookDescription": "Called when an entity attempts to become hostile\r\nUseful for denying marking the entity hostile",
      "HookParameters": {
        "instance": "BasePlayer",
        "duration": "Single"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "MarkHostileFor",
        "ReturnType": "void",
        "Arguments": {
          "duration": "float"
        }
      },
      "CodeAfterInjection": "public override void MarkHostileFor(float duration = 60f)\r\n{\r\n\tif (Interface.CallHook(\"OnEntityMarkHostile\", this, duration) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tdouble currentTimestamp = TimeEx.currentTimestamp;\r\n\tdouble val = currentTimestamp + (double)duration;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBuildingSplit",
      "HookName": "OnBuildingSplit",
      "HookParameters": {
        "building": "Building",
        "newID": "uint"
      },
      "ReturnBehavior": 0,
      "TargetType": "ServerBuildingManager",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "Split",
        "ReturnType": "void",
        "Arguments": {
          "building": "BuildingManager/Building"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\twhile (building.HasBuildingBlocks())\r\n\t{\r\n\t\tglobal::BaseEntity arg_47_0 = building.buildingBlocks[0];\r\n\t\tuint newID = global::BuildingManager.server.NewBuildingID();\r\n\t\tInterface.CallHook(\"OnBuildingSplit\", building, newID);\r\n\t\targ_47_0.EntityLinkBroadcast<global::BuildingBlock>(delegate(global::BuildingBlock b)\r\n\t\t{\r\n\t\t\tb.AttachToBuilding(newID);\r\n\t\t});\r\n\t}\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMapMarkerRemove",
      "HookName": "OnMapMarkerRemove",
      "HookParameters": {
        "instance": "BasePlayer",
        "pointsOfInterest": "List`1",
        "num": "int"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "Server_RemovePointOfInterest",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\npublic void Server_RemovePointOfInterest(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tint num = msg.read.Int32();\r\n\tif (this.State.pointsOfInterest != null && this.State.pointsOfInterest.Count > num && num >= 0)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnMapMarkerRemove\", this, this.State.pointsOfInterest, num) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis.State.pointsOfInterest[num].Dispose();\r\n\t\tthis.State.pointsOfInterest.RemoveAt(num);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnGrowableGathered",
      "HookName": "OnGrowableGathered",
      "HookParameters": {
        "instance": "GrowableEntity",
        "item": "Item",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "GrowableEntity",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "GiveFruit",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer",
          "amount": "int",
          "applyCondition": "bool",
          "eat": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\tif (player != null)\r\n\t{\r\n\t\tInterface.CallHook(\"OnGrowableGathered\", this, item, player);\r\n\t\tFacepunch.Rust.Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, this, player, null);\r\n\t\tplayer.GiveItem(item, global::BaseEntity.GiveItemReason.ResourceHarvested);\r\n\t\treturn;\r\n\t}\r\n\titem.Drop(base.transform.position + Vector3.up * 0.5f, Vector3.up * 1f, default(Quaternion));\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnQuarryConsumeFuel",
      "HookName": "OnQuarryConsumeFuel",
      "HookParameters": {
        "instance": "MiningQuarry",
        "item": "Item"
      },
      "ReturnBehavior": 3,
      "TargetType": "MiningQuarry",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "FuelCheck",
        "ReturnType": "bool",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tif (this.pendingWork > 0f)\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\tglobal::Item item = this.fuelStoragePrefab.instance.GetComponent<global::StorageContainer>().inventory.FindItemsByItemName(\"diesel_barrel\");\r\n\tobject returnvar = Interface.CallHook(\"OnQuarryConsumeFuel\", this, item);\r\n\tif (returnvar is global::Item)\r\n\t{\r\n\t\titem = (global::Item)returnvar;\r\n\t}\r\n\tif (item != null && item.amount >= 1)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityActiveCheck",
      "HookName": "OnEntityActiveCheck",
      "HookParameters": {
        "ent": "BaseEntity",
        "player": "BasePlayer",
        "id": "uint",
        "debugName": "string"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseEntity/RPC_Server/IsActiveItem",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "Test",
        "ReturnType": "bool",
        "Arguments": {
          "id": "uint",
          "debugName": "string",
          "ent": "BaseEntity",
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (ent.net == null || player.net == null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"OnEntityActiveCheck\", ent, player, id, debugName);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif (ent.net.ID == player.net.ID)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityFromOwnerCheck",
      "HookName": "OnEntityFromOwnerCheck",
      "HookParameters": {
        "ent": "BaseEntity",
        "player": "BasePlayer",
        "id": "uint",
        "debugName": "string"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseEntity/RPC_Server/FromOwner",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "Test",
        "ReturnType": "bool",
        "Arguments": {
          "id": "uint",
          "debugName": "string",
          "ent": "BaseEntity",
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (ent.net == null || player.net == null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"OnEntityFromOwnerCheck\", ent, player, id, debugName);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn ent.net.ID == player.net.ID || !(ent.parentEntity.uid != player.net.ID);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanLootEntity [BaseRidableAnimal]",
      "HookName": "CanLootEntity",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "BaseRidableAnimal"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseRidableAnimal",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RPC_OpenLoot",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (this.needsBuildingPrivilegeToUse && !player.CanBuild())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanLootEntity\", player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (player.inventory.loot.StartLootingEntity(this, true))\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnSamSiteTarget",
      "HookName": "OnSamSiteTarget",
      "HookDescription": "Called before last target visible time is updated",
      "ReturnBehavior": 0,
      "TargetType": "SamSite",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "TargetScan",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tif (this.IsDead())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tSystem.Collections.Generic.List<global::SamSite.ISamSiteTarget> list = Pool.GetList<global::SamSite.ISamSiteTarget>();\r\n\tif (Interface.CallHook(\"OnSamSiteTargetScan\", this, list) == null)\r\n\t{\r\n\t\tif (!this.IsInDefenderMode())\r\n\t\t{\r\n\t\t\tthis.<TargetScan>g__AddTargetSet|55_0(list, 32768, global::SamSite.targetTypeVehicle.scanRadius);\r\n\t\t}\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "CanLootEntity [StorageContainer]",
      "HookName": "CanLootEntity",
      "ReturnBehavior": 0,
      "TargetType": "StorageContainer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "PlayerOpenLoot",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer",
          "panelToOpen": "string",
          "doPositionChecks": "bool"
        }
      },
      "CodeAfterInjection": "public virtual bool PlayerOpenLoot(global::BasePlayer player, string panelToOpen = \"\", bool doPositionChecks = true)\r\n{\r\n\tif (Interface.CallHook(\"CanLootEntity\", player, this) != null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (base.IsLocked())\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityVisibilityCheck",
      "HookName": "OnEntityVisibilityCheck",
      "HookParameters": {
        "ent": "BaseEntity",
        "player": "BasePlayer",
        "id": "uint",
        "debugName": "string",
        "maximumDistance": "float"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseEntity/RPC_Server/IsVisible",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "Test",
        "ReturnType": "bool",
        "Arguments": {
          "id": "uint",
          "debugName": "string",
          "ent": "BaseEntity",
          "player": "BasePlayer",
          "maximumDistance": "float"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (ent == null || player == null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"OnEntityVisibilityCheck\", ent, player, id, debugName, maximumDistance);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn global::GamePhysics.LineOfSight(player.eyes.center, player.eyes.position, 2162688, null) && (ent.IsVisible(player.eyes.HeadRay(), 1218519041, maximumDistance) || ent.IsVisible(player.eyes.position, maximumDistance));\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityDistanceCheck",
      "HookName": "OnEntityDistanceCheck",
      "HookParameters": {
        "ent": "BaseEntity",
        "player": "BasePlayer",
        "id": "uint",
        "debugName": "string",
        "maximumDistance": "float"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseEntity/RPC_Server/MaxDistance",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "Test",
        "ReturnType": "bool",
        "Arguments": {
          "id": "uint",
          "debugName": "string",
          "ent": "BaseEntity",
          "player": "BasePlayer",
          "maximumDistance": "float"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (ent == null || player == null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"OnEntityDistanceCheck\", ent, player, id, debugName, maximumDistance);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn ent.Distance(player.eyes.position) <= maximumDistance;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnGrowableGather",
      "HookName": "OnGrowableGather",
      "HookParameters": {
        "instance": "GrowableEntity",
        "player": "BasePlayer",
        "eat": "Boolean"
      },
      "ReturnBehavior": 1,
      "TargetType": "GrowableEntity",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "PickFruit",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer",
          "eat": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (!this.CanPick())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnGrowableGather\", this, player, eat) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.harvests++;\r\n\tthis.GiveFruit(player, this.CurrentPickAmount, eat);\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnQuarryGather",
      "HookName": "OnQuarryGather",
      "ReturnBehavior": 0,
      "TargetType": "MiningQuarry",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "ProcessResources",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\t\tif (num2 != num3)\r\n\t\t\t{\r\n\t\t\t\tint iAmount = num3 - num2;\r\n\t\t\t\tglobal::Item item = global::ItemManager.Create(current.type, iAmount, 0uL);\r\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnQuarryItem(Facepunch.Rust.Analytics.Azure.ResourceMode.Produced, item.info.shortname, item.amount, this);\r\n\t\t\t\tif (Interface.CallHook(\"OnQuarryGather\", this, item) != null)\r\n\t\t\t\t{\r\n\t\t\t\t\titem.Remove(0f);\r\n\t\t\t\t}\r\n\t\t\t\telse if (!item.MoveToContainer(this.hopperPrefab.instance.GetComponent<global::StorageContainer>().inventory, -1, true, false, null, true))\r\n\t\t\t\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCorpsePopulate [HumanNPC]",
      "HookName": "OnCorpsePopulate",
      "HookParameters": {
        "instance": "HumanNPC",
        "nPCPlayerCorpse": "NPCPlayerCorpse"
      },
      "ReturnBehavior": 1,
      "TargetType": "HumanNPC",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "CreateCorpse",
        "ReturnType": "BaseCorpse",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\t\t\t\titemContainer.Clear();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (this.LootSpawnSlots.Length != 0)\r\n\t\t\t{\r\n\t\t\t\tobject returnvar = Interface.CallHook(\"OnCorpsePopulate\", this, nPCPlayerCorpse);\r\n\t\t\t\tif (returnvar is global::BaseCorpse)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn (global::BaseCorpse)returnvar;\r\n\t\t\t\t}\r\n\t\t\t\tglobal::LootContainer.LootSpawnSlot[] lootSpawnSlots = this.LootSpawnSlots;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemSkinChange",
      "HookName": "OnItemSkinChange",
      "HookParameters": {
        "num": "int",
        "slot": "Item",
        "instance": "RepairBench",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "RepairBench",
      "Category": "Item",
      "MethodData": {
        "MethodName": "ChangeSkin",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tglobal::Item slot = base.inventory.GetSlot(0);\r\n\tif (slot == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnItemSkinChange\", num, slot, this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbool flag = false;\r\n\tif (msg.player.UnlockAllSkins)\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "NoLimboGroupForPlayers [patch]",
      "HookName": "NoLimboGroupForPlayers [patch]",
      "ReturnBehavior": 0,
      "TargetType": "BaseEntity",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "UpdateNetworkGroup",
        "ReturnType": "void",
        "Arguments": {}
      }
    },
    {
      "Type": 1,
      "Name": "OnMapMarkerAdd",
      "HookName": "OnMapMarkerAdd",
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "Server_AddMarker",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.CallsPerSecond(8uL), global::BaseEntity.RPC_Server.FromOwner]\r\npublic void Server_AddMarker(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tif (Interface.CallHook(\"OnMapMarkerAdd\", this, MapNote.Deserialize(msg.read)) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tmsg.read.Position = 13L;\r\n\tif (this.State.pointsOfInterest == null)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMapMarkerAdded",
      "HookName": "OnMapMarkerAdded",
      "HookParameters": {
        "instance": "BasePlayer",
        "mapNote": "MapNote"
      },
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "Server_AddMarker",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.CallsPerSecond(8uL), global::BaseEntity.RPC_Server.FromOwner]\r\npublic void Server_AddMarker(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tif (Interface.CallHook(\"OnMapMarkerAdd\", this, MapNote.Deserialize(msg.read)) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tmsg.read.Position = 13L;\r\n\tif (this.State.pointsOfInterest == null)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnClothingItemChanged",
      "HookName": "OnClothingItemChanged",
      "HookParameters": {
        "instance": "PlayerInventory",
        "item": "Item",
        "bAdded": "bool"
      },
      "ReturnBehavior": 0,
      "TargetType": "PlayerInventory",
      "Category": "Player",
      "MethodData": {
        "MethodName": "OnClothingChanged",
        "ReturnType": "void",
        "Arguments": {
          "item": "Item",
          "bAdded": "bool"
        }
      },
      "CodeAfterInjection": "private void OnClothingChanged(global::Item item, bool bAdded)\r\n{\r\n\tbase.baseEntity.SV_ClothingChanged();\r\n\tglobal::ItemManager.DoRemoves();\r\n\tthis.ServerUpdate(0f);\r\n\tInterface.CallHook(\"OnClothingItemChanged\", this, item, bAdded);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnHorseHitch",
      "HookName": "OnHorseHitch",
      "HookDescription": "Called just before setting the hitch",
      "HookParameters": {
        "horse": "RidableHorse",
        "hitch": "HitchSpot"
      },
      "ReturnBehavior": 1,
      "TargetType": "HitchTrough",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "AttemptToHitch",
        "ReturnType": "bool",
        "Arguments": {
          "horse": "RidableHorse",
          "hitch": "HitchTrough/HitchSpot"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (hitch == null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"OnHorseHitch\", horse, hitch);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\thitch.SetOccupiedBy(horse);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnHorseUnhitch",
      "HookName": "OnHorseUnhitch",
      "HookDescription": "Called just before removing the hitch",
      "HookParameters": {
        "horse": "RidableHorse",
        "hitchSpot": "HitchSpot"
      },
      "ReturnBehavior": 1,
      "TargetType": "HitchTrough",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "Unhitch",
        "ReturnType": "void",
        "Arguments": {
          "horse": "RidableHorse"
        }
      },
      "CodeAfterInjection": "...\r\n\tfor (int i = 0; i < array.Length; i++)\r\n\t{\r\n\t\tglobal::HitchTrough.HitchSpot hitchSpot = array[i];\r\n\t\tif (hitchSpot.GetHorse(base.isServer) == horse)\r\n\t\t{\r\n\t\t\tif (Interface.CallHook(\"OnHorseUnhitch\", horse, hitchSpot) != null)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\thitchSpot.SetOccupiedBy(null);\r\n\t\t\thorse.SetHitch(null);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEventTrigger",
      "HookName": "OnEventTrigger",
      "HookParameters": {
        "instance": "TriggeredEventPrefab"
      },
      "ReturnBehavior": 1,
      "TargetType": "TriggeredEventPrefab",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "RunEvent",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "private void RunEvent()\r\n{\r\n\tif (Interface.CallHook(\"OnEventTrigger\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tDebug.Log(\"[event] \" + this.targetPrefab.resourcePath);\r\n\tglobal::BaseEntity baseEntity = global::GameManager.server.CreateEntity(this.targetPrefab.resourcePath, default(Vector3), default(Quaternion), true);\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnSensorDetect",
      "HookName": "OnSensorDetect",
      "HookDescription": "Called when a heartbeat sensor detects a player",
      "ReturnBehavior": 0,
      "TargetType": "HBHFSensor",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "UpdatePassthroughAmount",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\tforeach (global::BaseEntity current in this.myTrigger.entityContents)\r\n\t\t{\r\n\t\t\tif (!(current == null) && current.IsVisible(base.transform.position + base.transform.forward * 0.1f, 10f))\r\n\t\t\t{\r\n\t\t\t\tglobal::BasePlayer component = current.GetComponent<global::BasePlayer>();\r\n\t\t\t\tif (Interface.CallHook(\"OnSensorDetect\", this, component) == null)\r\n\t\t\t\t{\r\n\t\t\t\t\tbool flag = component.CanBuild();\r\n\t\t\t\t\tif ((!flag || this.ShouldIncludeAuthorized()) && (flag || this.ShouldIncludeOthers()) && component != null && component.IsAlive() && !component.IsSleeping() && component.isServer)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthis.detectedPlayers++;\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "FixItemKeyId [patch]",
      "HookName": "FixItemKeyId [patch]",
      "ReturnBehavior": 0,
      "TargetType": "ItemCrafter",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "CraftItem",
        "ReturnType": "bool",
        "Arguments": {
          "bp": "ItemBlueprint",
          "owner": "BasePlayer",
          "instanceData": "ProtoBuf.Item/InstanceData",
          "amount": "int",
          "skinID": "int",
          "fromTempBlueprint": "Item",
          "free": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\tfromTempBlueprint.RemoveFromContainer();\r\n\t\titemCraftTask.takenItems.Add(fromTempBlueprint);\r\n\t\titemCraftTask.conditionScale = 0.5f;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"OnItemCraft\", itemCraftTask, owner, fromTempBlueprint);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\tif (fromTempBlueprint != null && itemCraftTask.instanceData != null)\r\n\t\t{\r\n\t\t\tfromTempBlueprint.instanceData = itemCraftTask.instanceData;\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "CanLootEntity [ContainerIOEntity]",
      "HookName": "CanLootEntity",
      "ReturnBehavior": 0,
      "TargetType": "ContainerIOEntity",
      "Category": "Player",
      "MethodData": {
        "MethodName": "PlayerOpenLoot",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer",
          "panelToOpen": "string",
          "doPositionChecks": "bool"
        }
      },
      "CodeAfterInjection": "public virtual bool PlayerOpenLoot(global::BasePlayer player, string panelToOpen = \"\", bool doPositionChecks = true)\r\n{\r\n\tif (Interface.CallHook(\"CanLootEntity\", player, this) != null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (this.needsBuildingPrivilegeToUse && !player.CanBuild())\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnVehiclePush",
      "HookName": "OnVehiclePush",
      "HookParameters": {
        "instance": "BaseVehicle",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseVehicle",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "RPC_WantsPush",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (this.OnlyOwnerAccessible() && player != this.creatorEntity)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnVehiclePush\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tplayer.metabolism.calories.Subtract(3f);\r\n\tplayer.metabolism.SendChangesToClient();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnStashHidden",
      "HookName": "OnStashHidden",
      "HookDescription": "Called when a player hides a stash",
      "HookParameters": {
        "instance": "StashContainer",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "StashContainer",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "RPC_HideStash",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void RPC_HideStash(global::BaseEntity.RPCMessage rpc)\r\n{\r\n\tif (Interface.CallHook(\"CanHideStash\", rpc.player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tFacepunch.Rust.Analytics.Azure.OnStashHidden(rpc.player, this);\r\n\tthis.SetHidden(true);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanUpdateSign [PhotoFrame]",
      "HookName": "CanUpdateSign",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "PhotoFrame"
      },
      "ReturnBehavior": 1,
      "TargetType": "PhotoFrame",
      "Category": "Player",
      "MethodData": {
        "MethodName": "CanUpdateSign",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public bool CanUpdateSign(global::BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanUpdateSign\", player, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn player.IsAdmin || player.IsDeveloper || (player.CanBuild() && (!base.IsLocked() || player.userID == base.OwnerID));\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSignLocked [PhotoFrame]",
      "HookName": "OnSignLocked",
      "HookParameters": {
        "instance": "PhotoFrame",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "PhotoFrame",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "LockSign",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t\treturn;\r\n\t}\r\n\tbase.SetFlag(global::BaseEntity.Flags.Locked, true, false, true);\r\n\tbase.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);\r\n\tbase.OwnerID = msg.player.userID;\r\n\tInterface.CallHook(\"OnSignLocked\", this, msg.player);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSignUpdated [PhotoFrame]",
      "HookName": "OnSignUpdated",
      "HookParameters": {
        "instance": "PhotoFrame",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "PhotoFrame",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "UpdateSign",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tglobal::FileStorage.server.RemoveAllByEntity(this.net.ID);\r\n\tthis._overlayTextureCrc = global::FileStorage.server.Store(array, global::FileStorage.Type.png, this.net.ID, 0u);\r\n\tthis.LogEdit(msg.player);\r\n\tbase.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);\r\n\tInterface.CallHook(\"OnSignUpdated\", this, msg.player);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMixingTableToggle",
      "HookName": "OnMixingTableToggle",
      "HookDescription": "Called when a player attemts to turn on or off MixingTable",
      "HookParameters": {
        "instance": "MixingTable",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "MixingTable",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "SVSwitch",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.MaxDistance(3f)]\r\nprivate void SVSwitch(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tif (Interface.CallHook(\"OnMixingTableToggle\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbool flag = msg.read.Bit();\r\n\tif (flag == base.IsOn())\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBookmarkControl",
      "HookName": "OnBookmarkControl",
      "HookDescription": "Called when a player tries to select a bookmark at a computer station",
      "HookParameters": {
        "instance": "ComputerStation",
        "player": "BasePlayer",
        "text": "string",
        "remoteControllable": "IRemoteControllable"
      },
      "ReturnBehavior": 1,
      "TargetType": "ComputerStation",
      "Category": "Bookmark",
      "MethodData": {
        "MethodName": "BeginControllingBookmark",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (Vector3.Distance(base.transform.position, ent.transform.position) >= remoteControllable.MaxRange)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnBookmarkControl\", this, player, text, remoteControllable) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::BaseEntity baseEntity = this.currentlyControllingEnt.Get(true);\r\n\tif (baseEntity)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBookmarkDelete",
      "HookName": "OnBookmarkDelete",
      "HookDescription": "Called when a player tries to delete a bookmark at a computer station",
      "HookParameters": {
        "instance": "ComputerStation",
        "player": "BasePlayer",
        "text": "string"
      },
      "ReturnBehavior": 1,
      "TargetType": "ComputerStation",
      "Category": "Bookmark",
      "MethodData": {
        "MethodName": "DeleteBookmark",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.controlBookmarks.Contains(text))\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnBookmarkDelete\", this, player, text) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis.controlBookmarks.Remove(text);\r\n\t\tthis.SendControlBookmarks(player);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBookmarkAdd",
      "HookName": "OnBookmarkAdd",
      "HookDescription": "Called when a player tries to add a bookmark at a computer station",
      "HookParameters": {
        "instance": "ComputerStation",
        "player": "BasePlayer",
        "text": "string"
      },
      "ReturnBehavior": 1,
      "TargetType": "ComputerStation",
      "Category": "Bookmark",
      "MethodData": {
        "MethodName": "AddBookmark",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t\tplayer.ChatMessage(\"Too many bookmarks, delete some\");\r\n\t\treturn;\r\n\t}\r\n\tthis.nextAddTime = Time.realtimeSinceStartup + 1f;\r\n\tstring text = msg.read.String(256);\r\n\tif (Interface.CallHook(\"OnBookmarkAdd\", this, player, text) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.ForceAddBookmark(text);\r\n\tthis.SendControlBookmarks(player);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBookmarksSendControl",
      "HookName": "OnBookmarksSendControl",
      "HookDescription": "Called when a player is being sent a list of bookmarks for a computer station",
      "HookParameters": {
        "instance": "ComputerStation",
        "player": "BasePlayer",
        "text": "string"
      },
      "ReturnBehavior": 1,
      "TargetType": "ComputerStation",
      "Category": "Bookmark",
      "MethodData": {
        "MethodName": "SendControlBookmarks",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (player == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tstring text = this.GenerateControlBookmarkString();\r\n\tif (Interface.CallHook(\"OnBookmarksSendControl\", this, player, text) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.ClientRPCPlayer<string>(null, player, \"ReceiveBookmarks\", text);\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBookmarkControlEnd",
      "HookName": "OnBookmarkControlEnd",
      "HookDescription": "Called when a player tries to stop viewing/controlling an entity at a computer station",
      "HookParameters": {
        "instance": "ComputerStation",
        "ply": "BasePlayer",
        "baseEntity": "BaseEntity"
      },
      "ReturnBehavior": 1,
      "TargetType": "ComputerStation",
      "Category": "Bookmark",
      "MethodData": {
        "MethodName": "StopControl",
        "ReturnType": "void",
        "Arguments": {
          "ply": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public void StopControl(global::BasePlayer ply)\r\n{\r\n\tglobal::BaseEntity baseEntity = this.currentlyControllingEnt.Get(true);\r\n\tif (baseEntity)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnBookmarkControlEnd\", this, ply, baseEntity) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tbaseEntity.GetComponent<global::IRemoteControllable>().StopControl(new global::CameraViewerId(this.currentPlayerID, 0L));\r\n\t}\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSolarPanelSunUpdate",
      "HookName": "OnSolarPanelSunUpdate",
      "HookDescription": "Called when a solar panel updates the amount of energy it is getting from the sun",
      "HookParameters": {
        "instance": "SolarPanel",
        "num": "int"
      },
      "ReturnBehavior": 1,
      "TargetType": "SolarPanel",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "SunUpdate",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tbool arg_B3_0 = this.currentEnergy != num;\r\n\tthis.currentEnergy = num;\r\n\tif (arg_B3_0)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnSolarPanelSunUpdate\", this, num) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis.MarkDirty();\r\n\t}\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnServerInitialize",
      "HookName": "OnServerInitialize",
      "HookParameters": {},
      "ReturnBehavior": 0,
      "TargetType": "ServerMgr",
      "Category": "Server",
      "MethodData": {
        "MethodName": "Initialize",
        "ReturnType": "void",
        "Arguments": {
          "loadSave": "bool",
          "saveFile": "string",
          "allowOutOfDateSaves": "bool",
          "skipInitialSpawn": "bool"
        }
      },
      "CodeAfterInjection": "public void Initialize(bool loadSave = true, string saveFile = \"\", bool allowOutOfDateSaves = false, bool skipInitialSpawn = false)\r\n{\r\n\tInterface.CallHook(\"OnServerInitialize\");\r\n\tthis.persistance = new global::UserPersistance(ConVar.Server.rootFolder);\r\n\tthis.playerStateManager = new global::PlayerStateManager(this.persistance);\r\n\tthis.SpawnMapEntities();\r\n\tif (SingletonComponent<global::SpawnHandler>.Instance)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnDefaultItemsReceive",
      "HookName": "OnDefaultItemsReceive",
      "HookParameters": {
        "instance": "PlayerInventory"
      },
      "ReturnBehavior": 1,
      "TargetType": "PlayerInventory",
      "Category": "Player",
      "MethodData": {
        "MethodName": "GiveDefaultItems",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void GiveDefaultItems()\r\n{\r\n\tif (Interface.CallHook(\"OnDefaultItemsReceive\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.Strip();\r\n\tglobal::BaseGameMode activeGameMode = global::BaseGameMode.GetActiveGameMode(true);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnDefaultItemsReceived",
      "HookName": "OnDefaultItemsReceived",
      "HookParameters": {
        "instance": "PlayerInventory"
      },
      "ReturnBehavior": 0,
      "TargetType": "PlayerInventory",
      "Category": "Player",
      "MethodData": {
        "MethodName": "GiveDefaultItems",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void GiveDefaultItems()\r\n{\r\n\tif (Interface.CallHook(\"OnDefaultItemsReceive\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.Strip();\r\n\tglobal::BaseGameMode activeGameMode = global::BaseGameMode.GetActiveGameMode(true);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "IOnPlayerBanned [Publisher/VAC]",
      "HookName": "IOnPlayerBanned",
      "HookParameters": {
        "connection": "Connection",
        "Status": "AuthResponse"
      },
      "ReturnBehavior": 0,
      "TargetType": "ServerMgr",
      "Category": "Player",
      "MethodData": {
        "MethodName": "OnValidateAuthTicketResponse",
        "ReturnType": "void",
        "Arguments": {
          "SteamId": "ulong",
          "OwnerId": "ulong",
          "Status": "AuthResponse"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif ((Status == AuthResponse.PublisherBanned || Status == AuthResponse.VACBanned) && !this.bannedPlayerNotices.Contains(SteamId))\r\n\t{\r\n\t\tInterface.CallHook(\"IOnPlayerBanned\", connection, Status);\r\n\t\tglobal::ConsoleNetwork.BroadcastToAllClients(\"chat.add\", new object[]\r\n\t\t{\r\n\t\t\t2,\r\n\t\t\t0,\r\n\t\t\t\"<color=#fff>SERVER</color> Kicking \" + connection.username.EscapeRichText() + \" (banned by anticheat)\"\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnPlayerSpawn",
      "HookName": "OnPlayerSpawn",
      "ReturnBehavior": 0,
      "TargetType": "ServerMgr",
      "Category": "Player",
      "MethodData": {
        "MethodName": "SpawnNewPlayer",
        "ReturnType": "BasePlayer",
        "Arguments": {
          "connection": "Network.Connection"
        }
      },
      "CodeAfterInjection": "private global::BasePlayer SpawnNewPlayer(Connection connection)\r\n{\r\n\tglobal::BasePlayer.SpawnPoint spawnPoint = global::ServerMgr.FindSpawnPoint(null);\r\n\tglobal::BasePlayer basePlayer = global::GameManager.server.CreateEntity(\"assets/prefabs/player/player.prefab\", spawnPoint.pos, spawnPoint.rot, true).ToPlayer();\r\n\tif (Interface.CallHook(\"OnPlayerSpawn\", basePlayer, connection) != null)\r\n\t{\r\n\t\treturn null;\r\n\t}\r\n\tbasePlayer.health = 0f;\r\n\tbasePlayer.lifestate = global::BaseCombatEntity.LifeState.Dead;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBonusItemDrop",
      "HookName": "OnBonusItemDrop",
      "HookParameters": {
        "item": "Item",
        "basePlayer": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "LootContainer",
      "Category": "Item",
      "MethodData": {
        "MethodName": "DropBonusItems",
        "ReturnType": "void",
        "Arguments": {
          "initiator": "BaseEntity",
          "container": "ItemContainer"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t\tif (num4 > 0)\r\n\t\t\t{\r\n\t\t\t\tglobal::Item item = global::ItemManager.Create(global::LootContainer.scrapDef, num4, 0uL);\r\n\t\t\t\tif (item != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (Interface.CallHook(\"OnBonusItemDrop\", item, basePlayer) != null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t(item.Drop(this.GetDropPosition() + new Vector3(0f, 0.5f, 0f), this.GetInheritedDropVelocity(), default(Quaternion)) as global::DroppedItem).DropReason = global::DroppedItem.DropReasonEnum.Loot;\r\n\t\t\t\t\tInterface.CallHook(\"OnBonusItemDropped\", item, basePlayer);\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnPlayerCorpseSpawn",
      "HookName": "OnPlayerCorpseSpawn",
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "CreateCorpse",
        "ReturnType": "BaseCorpse",
        "Arguments": {}
      },
      "CodeAfterInjection": "public virtual global::BaseCorpse CreateCorpse()\r\n{\r\n\tif (Interface.CallHook(\"OnPlayerCorpseSpawn\", this) != null)\r\n\t{\r\n\t\treturn null;\r\n\t}\r\n\tusing (TimeWarning.New(\"Create corpse\", 0))\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerCorpseSpawned",
      "HookName": "OnPlayerCorpseSpawned",
      "HookParameters": {
        "instance": "BasePlayer",
        "enumerator": "PlayerCorpse"
      },
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "CreateCorpse",
        "ReturnType": "BaseCorpse",
        "Arguments": {}
      },
      "CodeAfterInjection": "public virtual global::BaseCorpse CreateCorpse()\r\n{\r\n\tif (Interface.CallHook(\"OnPlayerCorpseSpawn\", this) != null)\r\n\t{\r\n\t\treturn null;\r\n\t}\r\n\tusing (TimeWarning.New(\"Create corpse\", 0))\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemRefill",
      "HookName": "OnItemRefill",
      "HookParameters": {
        "item": "Item",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "ItemModRepair",
      "Category": "Item",
      "MethodData": {
        "MethodName": "ServerCommand",
        "ReturnType": "void",
        "Arguments": {
          "item": "Item",
          "command": "string",
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t}\r\n\t\tif (item.conditionNormalized >= 1f)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (Interface.CallHook(\"OnItemRefill\", item, player) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\titem.DoRepair(this.conditionLost);\r\n\t\tif (this.successEffect.isValid)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRfListenerAdd",
      "HookName": "OnRfListenerAdd",
      "HookParameters": {
        "obj": "IRFObject",
        "frequency": "int"
      },
      "ReturnBehavior": 1,
      "TargetType": "RFManager",
      "Category": "Radio",
      "MethodData": {
        "MethodName": "AddListener",
        "ReturnType": "void",
        "Arguments": {
          "frequency": "int",
          "obj": "IRFObject"
        }
      },
      "CodeAfterInjection": "public static void AddListener(int frequency, global::IRFObject obj)\r\n{\r\n\tfrequency = global::RFManager.ClampFrequency(frequency);\r\n\tif (Interface.CallHook(\"OnRfListenerAdd\", obj, frequency) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tSystem.Collections.Generic.List<global::IRFObject> listenList = global::RFManager.GetListenList(frequency);\r\n\tif (listenList.Contains(obj))\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRfListenerRemove",
      "HookName": "OnRfListenerRemove",
      "HookParameters": {
        "obj": "IRFObject",
        "frequency": "int"
      },
      "ReturnBehavior": 1,
      "TargetType": "RFManager",
      "Category": "Radio",
      "MethodData": {
        "MethodName": "RemoveListener",
        "ReturnType": "void",
        "Arguments": {
          "frequency": "int",
          "obj": "IRFObject"
        }
      },
      "CodeAfterInjection": "public static void RemoveListener(int frequency, global::IRFObject obj)\r\n{\r\n\tfrequency = global::RFManager.ClampFrequency(frequency);\r\n\tif (Interface.CallHook(\"OnRfListenerRemove\", obj, frequency) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tSystem.Collections.Generic.List<global::IRFObject> listenList = global::RFManager.GetListenList(frequency);\r\n\tif (listenList.Contains(obj))\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRfBroadcasterAdd",
      "HookName": "OnRfBroadcasterAdd",
      "HookParameters": {
        "obj": "IRFObject",
        "frequency": "int"
      },
      "ReturnBehavior": 1,
      "TargetType": "RFManager",
      "Category": "Radio",
      "MethodData": {
        "MethodName": "AddBroadcaster",
        "ReturnType": "void",
        "Arguments": {
          "frequency": "int",
          "obj": "IRFObject"
        }
      },
      "CodeAfterInjection": "public static void AddBroadcaster(int frequency, global::IRFObject obj)\r\n{\r\n\tfrequency = global::RFManager.ClampFrequency(frequency);\r\n\tif (Interface.CallHook(\"OnRfBroadcasterAdd\", obj, frequency) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tSystem.Collections.Generic.List<global::IRFObject> broadcasterList = global::RFManager.GetBroadcasterList(frequency);\r\n\tif (broadcasterList.Contains(obj))\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRfBroadcasterRemove",
      "HookName": "OnRfBroadcasterRemove",
      "HookParameters": {
        "obj": "IRFObject",
        "frequency": "int"
      },
      "ReturnBehavior": 1,
      "TargetType": "RFManager",
      "Category": "Radio",
      "MethodData": {
        "MethodName": "RemoveBroadcaster",
        "ReturnType": "void",
        "Arguments": {
          "frequency": "int",
          "obj": "IRFObject"
        }
      },
      "CodeAfterInjection": "public static void RemoveBroadcaster(int frequency, global::IRFObject obj)\r\n{\r\n\tfrequency = global::RFManager.ClampFrequency(frequency);\r\n\tif (Interface.CallHook(\"OnRfBroadcasterRemove\", obj, frequency) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tSystem.Collections.Generic.List<global::IRFObject> broadcasterList = global::RFManager.GetBroadcasterList(frequency);\r\n\tif (broadcasterList.Contains(obj))\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRfBroadcasterAdded",
      "HookName": "OnRfBroadcasterAdded",
      "HookParameters": {
        "obj": "IRFObject",
        "frequency": "int"
      },
      "ReturnBehavior": 0,
      "TargetType": "RFManager",
      "Category": "Radio",
      "MethodData": {
        "MethodName": "AddBroadcaster",
        "ReturnType": "void",
        "Arguments": {
          "frequency": "int",
          "obj": "IRFObject"
        }
      },
      "CodeAfterInjection": "public static void AddBroadcaster(int frequency, global::IRFObject obj)\r\n{\r\n\tfrequency = global::RFManager.ClampFrequency(frequency);\r\n\tif (Interface.CallHook(\"OnRfBroadcasterAdd\", obj, frequency) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tSystem.Collections.Generic.List<global::IRFObject> broadcasterList = global::RFManager.GetBroadcasterList(frequency);\r\n\tif (broadcasterList.Contains(obj))\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRfListenerRemoved",
      "HookName": "OnRfListenerRemoved",
      "HookParameters": {
        "obj": "IRFObject",
        "frequency": "int"
      },
      "ReturnBehavior": 0,
      "TargetType": "RFManager",
      "Category": "Radio",
      "MethodData": {
        "MethodName": "RemoveListener",
        "ReturnType": "void",
        "Arguments": {
          "frequency": "int",
          "obj": "IRFObject"
        }
      },
      "CodeAfterInjection": "public static void RemoveListener(int frequency, global::IRFObject obj)\r\n{\r\n\tfrequency = global::RFManager.ClampFrequency(frequency);\r\n\tif (Interface.CallHook(\"OnRfListenerRemove\", obj, frequency) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tSystem.Collections.Generic.List<global::IRFObject> listenList = global::RFManager.GetListenList(frequency);\r\n\tif (listenList.Contains(obj))\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRfListenerAdded",
      "HookName": "OnRfListenerAdded",
      "HookParameters": {
        "obj": "IRFObject",
        "frequency": "int"
      },
      "ReturnBehavior": 0,
      "TargetType": "RFManager",
      "Category": "Radio",
      "MethodData": {
        "MethodName": "AddListener",
        "ReturnType": "void",
        "Arguments": {
          "frequency": "int",
          "obj": "IRFObject"
        }
      },
      "CodeAfterInjection": "public static void AddListener(int frequency, global::IRFObject obj)\r\n{\r\n\tfrequency = global::RFManager.ClampFrequency(frequency);\r\n\tif (Interface.CallHook(\"OnRfListenerAdd\", obj, frequency) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tSystem.Collections.Generic.List<global::IRFObject> listenList = global::RFManager.GetListenList(frequency);\r\n\tif (listenList.Contains(obj))\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRfBroadcasterRemoved",
      "HookName": "OnRfBroadcasterRemoved",
      "HookParameters": {
        "obj": "IRFObject",
        "frequency": "int"
      },
      "ReturnBehavior": 0,
      "TargetType": "RFManager",
      "Category": "Radio",
      "MethodData": {
        "MethodName": "RemoveBroadcaster",
        "ReturnType": "void",
        "Arguments": {
          "frequency": "int",
          "obj": "IRFObject"
        }
      },
      "CodeAfterInjection": "public static void RemoveBroadcaster(int frequency, global::IRFObject obj)\r\n{\r\n\tfrequency = global::RFManager.ClampFrequency(frequency);\r\n\tif (Interface.CallHook(\"OnRfBroadcasterRemove\", obj, frequency) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tSystem.Collections.Generic.List<global::IRFObject> broadcasterList = global::RFManager.GetBroadcasterList(frequency);\r\n\tif (broadcasterList.Contains(obj))\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRfFrequencyChange [Broadcaster]",
      "HookName": "OnRfFrequencyChange",
      "HookParameters": {
        "instance": "RFBroadcaster",
        "num": "int",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "RFBroadcaster",
      "Category": "Radio",
      "MethodData": {
        "MethodName": "ServerSetFrequency",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\tglobal::RFManager.ReserveErrorPrint(msg.player);\r\n\t\treturn;\r\n\t}\r\n\tglobal::RFManager.ChangeFrequency(this.frequency, num, this, false, this.IsPowered());\r\n\tif (Interface.CallHook(\"OnRfFrequencyChange\", this, num, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.frequency = num;\r\n\tthis.MarkDirty();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRfFrequencyChanged [Broadcaster]",
      "HookName": "OnRfFrequencyChanged",
      "HookParameters": {
        "instance": "RFBroadcaster",
        "num": "int",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "RFBroadcaster",
      "Category": "Radio",
      "MethodData": {
        "MethodName": "ServerSetFrequency",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\tglobal::RFManager.ReserveErrorPrint(msg.player);\r\n\t\treturn;\r\n\t}\r\n\tglobal::RFManager.ChangeFrequency(this.frequency, num, this, false, this.IsPowered());\r\n\tif (Interface.CallHook(\"OnRfFrequencyChange\", this, num, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.frequency = num;\r\n\tthis.MarkDirty();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRfFrequencyChange [Receiver]",
      "HookName": "OnRfFrequencyChange",
      "HookParameters": {
        "instance": "RFReceiver",
        "num": "int",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "RFReceiver",
      "Category": "Radio",
      "MethodData": {
        "MethodName": "ServerSetFrequency",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (msg.player == null || !msg.player.CanBuild())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tint num = msg.read.Int32();\r\n\tif (Interface.CallHook(\"OnRfFrequencyChange\", this, num, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::RFManager.ChangeFrequency(this.frequency, num, this, true, true);\r\n\tthis.frequency = num;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRfFrequencyChanged [Receiver]",
      "HookName": "OnRfFrequencyChanged",
      "HookParameters": {
        "instance": "RFReceiver",
        "num": "int",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "RFReceiver",
      "Category": "Radio",
      "MethodData": {
        "MethodName": "ServerSetFrequency",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (msg.player == null || !msg.player.CanBuild())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tint num = msg.read.Int32();\r\n\tif (Interface.CallHook(\"OnRfFrequencyChange\", this, num, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::RFManager.ChangeFrequency(this.frequency, num, this, true, true);\r\n\tthis.frequency = num;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRfFrequencyChange [Detonator]",
      "HookName": "OnRfFrequencyChange",
      "HookParameters": {
        "instance": "Detonator",
        "freq": "int",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "Detonator",
      "Category": "Radio",
      "MethodData": {
        "MethodName": "ServerSetFrequency",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer",
          "freq": "int"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (global::RFManager.IsReserved(freq))\r\n\t{\r\n\t\tglobal::RFManager.ReserveErrorPrint(player);\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnRfFrequencyChange\", this, freq, player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::Item ownerItem = base.GetOwnerItem();\r\n\tglobal::RFManager.ChangeFrequency(this.frequency, freq, this, false, base.IsOn());\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRfFrequencyChanged [Detonator]",
      "HookName": "OnRfFrequencyChanged",
      "HookParameters": {
        "instance": "Detonator",
        "freq": "int",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "Detonator",
      "Category": "Radio",
      "MethodData": {
        "MethodName": "ServerSetFrequency",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer",
          "freq": "int"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (global::RFManager.IsReserved(freq))\r\n\t{\r\n\t\tglobal::RFManager.ReserveErrorPrint(player);\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnRfFrequencyChange\", this, freq, player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::Item ownerItem = base.GetOwnerItem();\r\n\tglobal::RFManager.ChangeFrequency(this.frequency, freq, this, false, base.IsOn());\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRfFrequencyChange [PagerEntity]",
      "HookName": "OnRfFrequencyChange",
      "HookParameters": {
        "instance": "PagerEntity",
        "num": "int",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "PagerEntity",
      "Category": "Radio",
      "MethodData": {
        "MethodName": "ServerSetFrequency",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.nextChangeTime = Time.time + 2f;\r\n\tint num = msg.read.Int32();\r\n\tif (Interface.CallHook(\"OnRfFrequencyChange\", this, num, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::RFManager.ChangeFrequency(this.frequency, num, this, true, true);\r\n\tthis.frequency = num;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRfFrequencyChanged [PagerEntity]",
      "HookName": "OnRfFrequencyChanged",
      "HookParameters": {
        "instance": "PagerEntity",
        "num": "int",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "PagerEntity",
      "Category": "Radio",
      "MethodData": {
        "MethodName": "ServerSetFrequency",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.nextChangeTime = Time.time + 2f;\r\n\tint num = msg.read.Int32();\r\n\tif (Interface.CallHook(\"OnRfFrequencyChange\", this, num, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::RFManager.ChangeFrequency(this.frequency, num, this, true, true);\r\n\tthis.frequency = num;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBonusItemDropped",
      "HookName": "OnBonusItemDropped",
      "HookParameters": {
        "item": "Item",
        "basePlayer": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "LootContainer",
      "Category": "Item",
      "MethodData": {
        "MethodName": "DropBonusItems",
        "ReturnType": "void",
        "Arguments": {
          "initiator": "BaseEntity",
          "container": "ItemContainer"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t\tif (num4 > 0)\r\n\t\t\t{\r\n\t\t\t\tglobal::Item item = global::ItemManager.Create(global::LootContainer.scrapDef, num4, 0uL);\r\n\t\t\t\tif (item != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (Interface.CallHook(\"OnBonusItemDrop\", item, basePlayer) != null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t(item.Drop(this.GetDropPosition() + new Vector3(0f, 0.5f, 0f), this.GetInheritedDropVelocity(), default(Quaternion)) as global::DroppedItem).DropReason = global::DroppedItem.DropReasonEnum.Loot;\r\n\t\t\t\t\tInterface.CallHook(\"OnBonusItemDropped\", item, basePlayer);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRemoveDying",
      "HookName": "OnRemoveDying",
      "HookParameters": {
        "instance": "GrowableEntity",
        "receiver": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "GrowableEntity",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "RemoveDying",
        "ReturnType": "void",
        "Arguments": {
          "receiver": "BasePlayer"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (this.Properties.removeDyingItem == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnRemoveDying\", this, receiver) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.Properties.removeDyingEffect.isValid)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnSleepingBagDestroy",
      "HookName": "OnSleepingBagDestroy",
      "HookDescription": "Called when a player tries to remove a sleeping bag from their respawn screen",
      "ReturnBehavior": 0,
      "TargetType": "SleepingBag",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "DestroyBag",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer",
          "sleepingBag": "NetworkableId"
        }
      },
      "CodeAfterInjection": "...\r\n\tglobal::SleepingBag sleepingBag2 = global::SleepingBag.FindForPlayer(player.userID, true).FirstOrDefault((global::SleepingBag x) => x.net.ID == sleepingBag);\r\n\tif (sleepingBag2 == null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (Interface.CallHook(\"OnSleepingBagDestroy\", sleepingBag2, player) != null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tglobal::SleepingBag.RemoveBagForPlayer(sleepingBag2, sleepingBag2.deployerUserID);\r\n\tsleepingBag2.deployerUserID = 0uL;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSleepingBagDestroyed",
      "HookName": "OnSleepingBagDestroyed",
      "HookDescription": "Called after a player removes a sleeping bag from their respawn screen",
      "HookParameters": {
        "sleepingBag2": "SleepingBag",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "SleepingBag",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "DestroyBag",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer",
          "sleepingBag": "NetworkableId"
        }
      },
      "CodeAfterInjection": "...\r\n\tglobal::SleepingBag sleepingBag2 = global::SleepingBag.FindForPlayer(player.userID, true).FirstOrDefault((global::SleepingBag x) => x.net.ID == sleepingBag);\r\n\tif (sleepingBag2 == null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (Interface.CallHook(\"OnSleepingBagDestroy\", sleepingBag2, player) != null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tglobal::SleepingBag.RemoveBagForPlayer(sleepingBag2, sleepingBag2.deployerUserID);\r\n\tsleepingBag2.deployerUserID = 0uL;\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnConstructionPlace",
      "HookName": "OnConstructionPlace",
      "ReturnBehavior": 0,
      "TargetType": "Planner",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "DoPlacement",
        "ReturnType": "UnityEngine.GameObject",
        "Arguments": {
          "placement": "Construction/Target",
          "component": "Construction"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\tfloat num2 = (buildingBlock != null) ? buildingBlock.currentGrade.maxHealth : baseCombatEntity.startHealth;\r\n\t\tbaseCombatEntity.ResetLifeStateOnSpawn = false;\r\n\t\tbaseCombatEntity.InitializeHealth(num2 * num, num2);\r\n\t}\r\n\tif (Interface.CallHook(\"OnConstructionPlace\", baseEntity, component, placement, ownerPlayer) != null)\r\n\t{\r\n\t\tif (baseEntity.IsValid())\r\n\t\t{\r\n\t\t\tbaseEntity.KillMessage();\r\n\t\t}\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnAnalysisComplete",
      "HookName": "OnAnalysisComplete",
      "HookDescription": "Called right after a player completes a survey crater analysis",
      "HookParameters": {
        "instance": "SurveyCrater",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "SurveyCrater",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "AnalysisComplete",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server]\r\npublic void AnalysisComplete(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tInterface.CallHook(\"OnAnalysisComplete\", this, msg.player);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBookmarkInput",
      "HookName": "OnBookmarkInput",
      "HookDescription": "Called when input is received from a player who is using a computer station with a bookmark selected",
      "HookParameters": {
        "instance": "ComputerStation",
        "player": "BasePlayer",
        "inputState": "InputState"
      },
      "ReturnBehavior": 1,
      "TargetType": "ComputerStation",
      "Category": "Bookmark",
      "MethodData": {
        "MethodName": "PlayerServerInput",
        "ReturnType": "void",
        "Arguments": {
          "inputState": "InputState",
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public override void PlayerServerInput(global::InputState inputState, global::BasePlayer player)\r\n{\r\n\tbase.PlayerServerInput(inputState, player);\r\n\tif (base.HasFlag(global::BaseEntity.Flags.Reserved2) && this.currentlyControllingEnt.IsValid(true))\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnBookmarkInput\", this, player, inputState) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis.currentlyControllingEnt.Get(true).GetComponent<global::IRemoteControllable>().UserInput(inputState, new global::CameraViewerId(player.userID, 0L));\r\n\t}\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "IOnServerInitialized",
      "HookName": "IOnServerInitialized",
      "HookParameters": {},
      "ReturnBehavior": 0,
      "TargetType": "ServerMgr",
      "Category": "Server",
      "MethodData": {
        "MethodName": "OpenConnection",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tglobal::EACServer.DoStartup();\r\n\tbase.InvokeRepeating(\"DoTick\", 1f, 1f / (float)ConVar.Server.tickrate);\r\n\tbase.InvokeRepeating(\"DoHeartbeat\", 1f, 1f);\r\n\tthis.runFrameUpdate = true;\r\n\tConsoleSystem.OnReplicatedVarChanged += new System.Action<string, string>(global::ServerMgr.OnReplicatedVarChanged);\r\n\tInterface.CallHook(\"IOnServerInitialized\");\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityControl [AutoTurret]",
      "HookName": "OnEntityControl",
      "HookDescription": "Called when a player tries to remote control an entity",
      "HookParameters": {
        "instance": "AutoTurret",
        "playerID": "UInt64"
      },
      "ReturnBehavior": 1,
      "TargetType": "AutoTurret",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "CanControl",
        "ReturnType": "bool",
        "Arguments": {
          "playerID": "ulong"
        }
      },
      "CodeAfterInjection": "public virtual bool CanControl(ulong playerID)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"OnEntityControl\", this, playerID);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn !this.booting && this.IsPowered() && !this.PeacekeeperMode();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityControl [PoweredRemoteControl]",
      "HookName": "OnEntityControl",
      "HookDescription": "Called when a player tries to remote control an entity",
      "HookParameters": {
        "instance": "PoweredRemoteControlEntity",
        "playerID": "UInt64"
      },
      "ReturnBehavior": 1,
      "TargetType": "PoweredRemoteControlEntity",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "CanControl",
        "ReturnType": "bool",
        "Arguments": {
          "playerID": "ulong"
        }
      },
      "CodeAfterInjection": "public virtual bool CanControl(ulong playerID)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"OnEntityControl\", this, playerID);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn this.IsPowered() || this.IsStatic();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityControl [RemoteControlEntity]",
      "HookName": "OnEntityControl",
      "HookDescription": "Called when a player tries to remote control an entity",
      "HookParameters": {
        "instance": "RemoteControlEntity",
        "playerID": "UInt64"
      },
      "ReturnBehavior": 1,
      "TargetType": "RemoteControlEntity",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "CanControl",
        "ReturnType": "bool",
        "Arguments": {
          "playerID": "ulong"
        }
      },
      "CodeAfterInjection": "public virtual bool CanControl(ulong playerID)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"OnEntityControl\", this, playerID);\r\n\treturn !(returnvar is bool) || (bool)returnvar;\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnLootEntityEnd [ContainerIOEntity]",
      "HookName": "OnLootEntityEnd",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "ContainerIOEntity"
      },
      "ReturnBehavior": 0,
      "TargetType": "ContainerIOEntity",
      "Category": "Player",
      "MethodData": {
        "MethodName": "PlayerStoppedLooting",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public virtual void PlayerStoppedLooting(global::BasePlayer player)\r\n{\r\n\tInterface.CallHook(\"OnLootEntityEnd\", player, this);\r\n\tbase.SetFlag(global::BaseEntity.Flags.Open, false, false, true);\r\n\tbase.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnLootEntityEnd [DroppedItemContainer]",
      "HookName": "OnLootEntityEnd",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "DroppedItemContainer"
      },
      "ReturnBehavior": 0,
      "TargetType": "DroppedItemContainer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "PlayerStoppedLooting",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public void PlayerStoppedLooting(global::BasePlayer player)\r\n{\r\n\tInterface.CallHook(\"OnLootEntityEnd\", player, this);\r\n\tif (this.inventory == null || this.inventory.itemList == null || this.inventory.itemList.Count == 0)\r\n\t{\r\n\t\tbase.Kill(global::BaseNetworkable.DestroyMode.None);\r\n\t\treturn;\r\n\t}\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnItemLock",
      "HookName": "OnItemLock",
      "ReturnBehavior": 0,
      "TargetType": "Item",
      "Category": "Item",
      "MethodData": {
        "MethodName": "LockUnlock",
        "ReturnType": "void",
        "Arguments": {
          "bNewState": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (this.HasFlag(global::Item.Flag.IsLocked) == bNewState)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (bNewState && Interface.CallHook(\"OnItemLock\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!bNewState && Interface.CallHook(\"OnItemUnlock\", this) != null)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnItemUnlock",
      "HookName": "OnItemUnlock",
      "ReturnBehavior": 0,
      "TargetType": "Item",
      "Category": "Item",
      "MethodData": {
        "MethodName": "LockUnlock",
        "ReturnType": "void",
        "Arguments": {
          "bNewState": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (this.HasFlag(global::Item.Flag.IsLocked) == bNewState)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (bNewState && Interface.CallHook(\"OnItemLock\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!bNewState && Interface.CallHook(\"OnItemUnlock\", this) != null)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTurretRotate",
      "HookName": "OnTurretRotate",
      "HookParameters": {
        "instance": "AutoTurret",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "AutoTurret",
      "Category": "Turret",
      "MethodData": {
        "MethodName": "FlipAim",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (this.IsOnline() || !this.IsAuthed(rpc.player) || this.booting)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnTurretRotate\", this, rpc.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.transform.rotation = Quaternion.LookRotation(-base.transform.forward, base.transform.up);\r\n\tbase.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnCounterTargetChange",
      "HookName": "OnCounterTargetChange",
      "HookDescription": "Called when a player tries to change the target number of a power counter",
      "ReturnBehavior": 0,
      "TargetType": "PowerCounter",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "SERVER_SetTarget",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void SERVER_SetTarget(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tint OxideGen_0 = msg.read.Int32();\r\n\tif (Interface.CallHook(\"OnCounterTargetChange\", this, msg.player, OxideGen_0) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!this.CanPlayerAdmin(msg.player))\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnCounterTargetChange [patch]",
      "HookName": "OnCounterTargetChange [patch]",
      "ReturnBehavior": 0,
      "TargetType": "PowerCounter",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "SERVER_SetTarget",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void SERVER_SetTarget(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tint OxideGen_0 = msg.read.Int32();\r\n\tif (Interface.CallHook(\"OnCounterTargetChange\", this, msg.player, OxideGen_0) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!this.CanPlayerAdmin(msg.player))\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnCounterModeToggle",
      "HookName": "OnCounterModeToggle",
      "HookDescription": "Called when a player ties to toggle a power counter between modes",
      "ReturnBehavior": 0,
      "TargetType": "PowerCounter",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "ToggleDisplayMode",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void ToggleDisplayMode(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tbool OxideGen_0 = msg.read.Bit();\r\n\tif (Interface.CallHook(\"OnCounterModeToggle\", this, msg.player, OxideGen_0) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!msg.player.CanBuild())\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnCounterModeToggle [patch]",
      "HookName": "OnCounterModeToggle [patch]",
      "ReturnBehavior": 0,
      "TargetType": "PowerCounter",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "ToggleDisplayMode",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void ToggleDisplayMode(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tbool OxideGen_0 = msg.read.Bit();\r\n\tif (Interface.CallHook(\"OnCounterModeToggle\", this, msg.player, OxideGen_0) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!msg.player.CanBuild())\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSwitchToggled [ElectricSwitch]",
      "HookName": "OnSwitchToggled",
      "HookDescription": "Called right after a player switches on or off an Entity",
      "HookParameters": {
        "instance": "ElectricSwitch",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "ElectricSwitch",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "SVSwitch",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void SVSwitch(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tif (Interface.CallHook(\"OnSwitchToggle\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.SetSwitch(!base.IsOn());\r\n\tInterface.CallHook(\"OnSwitchToggled\", this, msg.player);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSwitchToggled [FuelGenerator]",
      "HookName": "OnSwitchToggled",
      "HookDescription": "Called right after a player switches on or off an Entity",
      "HookParameters": {
        "instance": "FuelGenerator",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "FuelGenerator",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "RPC_EngineSwitch",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void RPC_EngineSwitch(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tif (Interface.CallHook(\"OnSwitchToggle\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbool generatorState = msg.read.Bit();\r\n\tthis.SetGeneratorState(generatorState);\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnEngineStart [MotorRowboat]",
      "HookName": "OnEngineStart",
      "ReturnBehavior": 0,
      "TargetType": "MotorRowboat",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "EngineToggle",
        "ReturnType": "void",
        "Arguments": {
          "wantsOn": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (!this.fuelSystem.HasFuel(true))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::BasePlayer OxideGen_0 = this.GetDriver();\r\n\tif (wantsOn && Interface.CallHook(\"OnEngineStart\", this, OxideGen_0) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.SetFlag(global::BaseEntity.Flags.Reserved1, wantsOn, false, true);\r\n\tif (wantsOn)\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnEngineStarted [MotorRowboat]",
      "HookName": "OnEngineStarted",
      "ReturnBehavior": 0,
      "TargetType": "MotorRowboat",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "EngineToggle",
        "ReturnType": "void",
        "Arguments": {
          "wantsOn": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (!this.fuelSystem.HasFuel(true))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::BasePlayer OxideGen_0 = this.GetDriver();\r\n\tif (wantsOn && Interface.CallHook(\"OnEngineStart\", this, OxideGen_0) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.SetFlag(global::BaseEntity.Flags.Reserved1, wantsOn, false, true);\r\n\tif (wantsOn)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEngineStatsRefresh",
      "HookName": "OnEngineStatsRefresh",
      "HookParameters": {
        "instance": "VehicleModuleEngine",
        "engineStorage": "EngineStorage"
      },
      "ReturnBehavior": 1,
      "TargetType": "VehicleModuleEngine",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "RefreshPerformanceStats",
        "ReturnType": "void",
        "Arguments": {
          "engineStorage": "Rust.Modular.EngineStorage"
        }
      },
      "CodeAfterInjection": "public void RefreshPerformanceStats(Rust.Modular.EngineStorage engineStorage)\r\n{\r\n\tif (Interface.CallHook(\"OnEngineStatsRefresh\", this, engineStorage) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (engineStorage == null)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEngineStatsRefreshed",
      "HookName": "OnEngineStatsRefreshed",
      "HookParameters": {
        "instance": "VehicleModuleEngine",
        "engineStorage": "EngineStorage"
      },
      "ReturnBehavior": 0,
      "TargetType": "VehicleModuleEngine",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "RefreshPerformanceStats",
        "ReturnType": "void",
        "Arguments": {
          "engineStorage": "Rust.Modular.EngineStorage"
        }
      },
      "CodeAfterInjection": "public void RefreshPerformanceStats(Rust.Modular.EngineStorage engineStorage)\r\n{\r\n\tif (Interface.CallHook(\"OnEngineStatsRefresh\", this, engineStorage) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (engineStorage == null)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnVehicleModulesAssign",
      "HookName": "OnVehicleModulesAssign",
      "HookParameters": {
        "instance": "ModularCar",
        "socketItemDefs": "ItemModVehicleModule"
      },
      "ReturnBehavior": 1,
      "TargetType": "ModularCar",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "SpawnPreassignedModules",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tif (this.spawnSettings.configurationOptions.IsNullOrEmpty<global::ModularCarPresetConfig>())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::ModularCarPresetConfig modularCarPresetConfig = this.spawnSettings.configurationOptions[UnityEngine.Random.Range(0, this.spawnSettings.configurationOptions.Length)];\r\n\tif (Interface.CallHook(\"OnVehicleModulesAssign\", this, modularCarPresetConfig.socketItemDefs) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfor (int i = 0; i < modularCarPresetConfig.socketItemDefs.Length; i++)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnVehicleModulesAssigned",
      "HookName": "OnVehicleModulesAssigned",
      "HookParameters": {
        "instance": "ModularCar",
        "socketItemDefs": "ItemModVehicleModule"
      },
      "ReturnBehavior": 0,
      "TargetType": "ModularCar",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "SpawnPreassignedModules",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tif (this.spawnSettings.configurationOptions.IsNullOrEmpty<global::ModularCarPresetConfig>())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::ModularCarPresetConfig modularCarPresetConfig = this.spawnSettings.configurationOptions[UnityEngine.Random.Range(0, this.spawnSettings.configurationOptions.Length)];\r\n\tif (Interface.CallHook(\"OnVehicleModulesAssign\", this, modularCarPresetConfig.socketItemDefs) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfor (int i = 0; i < modularCarPresetConfig.socketItemDefs.Length; i++)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnVehicleModuleSelect",
      "HookName": "OnVehicleModuleSelect",
      "HookParameters": {
        "vehicleItem": "Item",
        "instance": "ModularCarGarage",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "ModularCarGarage",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "RPC_SelectedLootItem",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t\treturn;\r\n\t}\r\n\tglobal::Item vehicleItem = this.carOccupant.GetVehicleItem(itemUID);\r\n\tif (vehicleItem != null)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnVehicleModuleSelect\", vehicleItem, this, player) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tbool flag = player.inventory.loot.RemoveContainerAt(3);\r\n\t\tglobal::BaseVehicleModule baseVehicleModule;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnVehicleModuleSelected",
      "HookName": "OnVehicleModuleSelected",
      "HookParameters": {
        "vehicleItem": "Item",
        "instance": "ModularCarGarage",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "ModularCarGarage",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "RPC_SelectedLootItem",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t\treturn;\r\n\t}\r\n\tglobal::Item vehicleItem = this.carOccupant.GetVehicleItem(itemUID);\r\n\tif (vehicleItem != null)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnVehicleModuleSelect\", vehicleItem, this, player) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tbool flag = player.inventory.loot.RemoveContainerAt(3);\r\n\t\tglobal::BaseVehicleModule baseVehicleModule;\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnVehicleModuleSelectedFix [patch]",
      "HookName": "OnVehicleModuleSelectedFix [patch]",
      "ReturnBehavior": 0,
      "TargetType": "ModularCarGarage",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "RPC_SelectedLootItem",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t\treturn;\r\n\t}\r\n\tglobal::Item vehicleItem = this.carOccupant.GetVehicleItem(itemUID);\r\n\tif (vehicleItem != null)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnVehicleModuleSelect\", vehicleItem, this, player) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tbool flag = player.inventory.loot.RemoveContainerAt(3);\r\n\t\tglobal::BaseVehicleModule baseVehicleModule;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnVehicleModuleDeselected",
      "HookName": "OnVehicleModuleDeselected",
      "HookParameters": {
        "instance": "ModularCarGarage",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "ModularCarGarage",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "RPC_DeselectedLootItem",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (player.inventory.loot.RemoveContainerAt(3))\r\n\t{\r\n\t\tplayer.inventory.loot.SendImmediate();\r\n\t}\r\n\tInterface.CallHook(\"OnVehicleModuleDeselected\", this, player);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnNpcConversationStart",
      "HookName": "OnNpcConversationStart",
      "HookParameters": {
        "instance": "NPCTalking",
        "player": "BasePlayer",
        "conversationFor": "ConversationData"
      },
      "ReturnBehavior": 1,
      "TargetType": "NPCTalking",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "Server_BeginTalking",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\tif (this.conversingPlayers.Contains(player))\r\n\t\t{\r\n\t\t\tthis.OnConversationEnded(player);\r\n\t\t}\r\n\t\tif (Interface.CallHook(\"OnNpcConversationStart\", this, player, conversationFor) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis.conversingPlayers.Add(player);\r\n\t\tthis.UpdateFlags();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnNpcConversationRespond",
      "HookName": "OnNpcConversationRespond",
      "HookParameters": {
        "instance": "NPCTalking",
        "player": "BasePlayer",
        "conversationFor": "ConversationData",
        "responseNode": "ResponseNode"
      },
      "ReturnBehavior": 1,
      "TargetType": "NPCTalking",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "Server_ResponsePressed",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t\treturn;\r\n\t}\r\n\tglobal::ConversationData.ResponseNode responseNode = conversationFor.speeches[num].responses[num2];\r\n\tif (responseNode != null)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnNpcConversationRespond\", this, player, conversationFor, responseNode) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (responseNode.conditions.Length != 0)\r\n\t\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnNpcConversationResponded",
      "HookName": "OnNpcConversationResponded",
      "HookParameters": {
        "instance": "NPCTalking",
        "player": "BasePlayer",
        "conversationFor": "ConversationData",
        "responseNode": "ResponseNode"
      },
      "ReturnBehavior": 0,
      "TargetType": "NPCTalking",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "Server_ResponsePressed",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t\treturn;\r\n\t}\r\n\tglobal::ConversationData.ResponseNode responseNode = conversationFor.speeches[num].responses[num2];\r\n\tif (responseNode != null)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnNpcConversationRespond\", this, player, conversationFor, responseNode) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (responseNode.conditions.Length != 0)\r\n\t\t{\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnNpcConversationResponded [patch]",
      "HookName": "OnNpcConversationResponded [patch]",
      "ReturnBehavior": 0,
      "TargetType": "NPCTalking",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "Server_ResponsePressed",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t\treturn;\r\n\t}\r\n\tglobal::ConversationData.ResponseNode responseNode = conversationFor.speeches[num].responses[num2];\r\n\tif (responseNode != null)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnNpcConversationRespond\", this, player, conversationFor, responseNode) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (responseNode.conditions.Length != 0)\r\n\t\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnVehicleLockableCheck",
      "HookName": "OnVehicleLockableCheck",
      "HookParameters": {
        "instance": "ModularCarCodeLock"
      },
      "ReturnBehavior": 4,
      "TargetType": "ModularCarCodeLock",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "CanHaveALock",
        "ReturnType": "bool",
        "Arguments": {}
      },
      "CodeAfterInjection": "public bool CanHaveALock()\r\n{\r\n\tobject returnvar = Interface.CallHook(\"OnVehicleLockableCheck\", this);\r\n\tif (returnvar != null)\r\n\t{\r\n\t\treturn returnvar is bool && (bool)returnvar;\r\n\t}\r\n\treturn !this.owner.IsDead() && this.owner.HasDriverMountPoints();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnElevatorCall",
      "HookName": "OnElevatorCall",
      "HookDescription": "Called when an elevator lift is called to a specific floor by electricity",
      "HookParameters": {
        "instance": "Elevator",
        "elevatorEnt": "Elevator"
      },
      "ReturnBehavior": 1,
      "TargetType": "Elevator",
      "Category": "Elevator",
      "MethodData": {
        "MethodName": "<CallElevator>b__29_0",
        "ReturnType": "void",
        "Arguments": {
          "elevatorEnt": "Elevator"
        }
      },
      "CodeAfterInjection": "[System.Runtime.CompilerServices.CompilerGenerated]\r\nprivate void <CallElevator>b__29_0(global::Elevator elevatorEnt)\r\n{\r\n\tif (elevatorEnt.IsTop)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnElevatorCall\", this, elevatorEnt) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tfloat num;\r\n\t\televatorEnt.RequestMoveLiftTo(this.Floor, out num, this);\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnElevatorMove",
      "HookName": "OnElevatorMove",
      "HookDescription": "Called right before an elevator starts moving to the target floor",
      "ReturnBehavior": 0,
      "TargetType": "Elevator",
      "Category": "Elevator",
      "MethodData": {
        "MethodName": "RequestMoveLiftTo",
        "ReturnType": "bool",
        "Arguments": {
          "targetFloor": "int",
          "timeToTravel": "System.Single&",
          "fromElevator": "Elevator"
        }
      },
      "CodeAfterInjection": "protected bool RequestMoveLiftTo(int targetFloor, out float timeToTravel, global::Elevator fromElevator)\r\n{\r\n\ttimeToTravel = 0f;\r\n\tif (Interface.CallHook(\"OnElevatorMove\", this, targetFloor) != null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (base.IsBusy())\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnElevatorButtonPress",
      "HookName": "OnElevatorButtonPress",
      "HookDescription": "Called when a player presses a button on an elevator lift",
      "ReturnBehavior": 0,
      "TargetType": "ElevatorLift",
      "Category": "Elevator",
      "MethodData": {
        "MethodName": "Server_RaiseLowerFloor",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::Elevator.Direction direction = (global::Elevator.Direction)msg.read.Int32();\r\n\tbool flag = msg.read.Bit();\r\n\tif (Interface.CallHook(\"OnElevatorButtonPress\", this, msg.player, direction, flag) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.SetFlag((direction == global::Elevator.Direction.Up) ? global::BaseEntity.Flags.Reserved1 : global::BaseEntity.Flags.Reserved2, true, false, true);\r\n\tthis.owner.Server_RaiseLowerElevator(direction, flag);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnHotAirBalloonToggle",
      "HookName": "OnHotAirBalloonToggle",
      "HookDescription": "Called when a player tries to toggle a hot air balloon on or off",
      "HookParameters": {
        "instance": "HotAirBalloon",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "HotAirBalloon",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "EngineSwitch",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void EngineSwitch(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tif (Interface.CallHook(\"OnHotAirBalloonToggle\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbool b = msg.read.Bit();\r\n\tbase.SetFlag(global::BaseEntity.Flags.On, b, false, true);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnHotAirBalloonToggled [on]",
      "HookName": "OnHotAirBalloonToggled",
      "HookDescription": "Called right after a player has toggled a hot air balloon on or off",
      "HookParameters": {
        "instance": "HotAirBalloon",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "HotAirBalloon",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "EngineSwitch",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void EngineSwitch(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tif (Interface.CallHook(\"OnHotAirBalloonToggle\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbool b = msg.read.Bit();\r\n\tbase.SetFlag(global::BaseEntity.Flags.On, b, false, true);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnHotAirBalloonToggled [off]",
      "HookName": "OnHotAirBalloonToggled",
      "HookDescription": "Called right after a player has toggled a hot air balloon on or off",
      "HookParameters": {
        "instance": "HotAirBalloon",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "HotAirBalloon",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "EngineSwitch",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void EngineSwitch(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tif (Interface.CallHook(\"OnHotAirBalloonToggle\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbool b = msg.read.Bit();\r\n\tbase.SetFlag(global::BaseEntity.Flags.On, b, false, true);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEngineLoadoutRefresh",
      "HookName": "OnEngineLoadoutRefresh",
      "HookParameters": {
        "instance": "EngineStorage"
      },
      "ReturnBehavior": 1,
      "TargetType": "Rust.Modular.EngineStorage",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "RefreshLoadoutData",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void RefreshLoadoutData()\r\n{\r\n\tif (Interface.CallHook(\"OnEngineLoadoutRefresh\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbool arg_4F_1;\r\n\tif (base.inventory.IsFull())\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnReactiveTargetReset",
      "HookName": "OnReactiveTargetReset",
      "HookDescription": "Called after the reactive target is reset",
      "HookParameters": {
        "instance": "ReactiveTarget"
      },
      "ReturnBehavior": 0,
      "TargetType": "ReactiveTarget",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "ResetTarget",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tbase.CancelInvoke(new System.Action(this.ResetTarget));\r\n\tbase.SetFlag(global::BaseEntity.Flags.On, true, false, true);\r\n\tthis.knockdownHealth = 100f;\r\n\tthis.SendPowerBurst();\r\n\tInterface.CallHook(\"OnReactiveTargetReset\", this);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnExperimentStarted",
      "HookName": "OnExperimentStarted",
      "HookParameters": {
        "instance": "Workbench",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "Workbench",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RPC_BeginExperiment",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (this.pendingBlueprint == null)\r\n\t{\r\n\t\tplayer.ChatMessage(\"You have already unlocked everything for this workbench tier.\");\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnExperimentStart\", this, player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::Item slot = base.inventory.GetSlot(0);\r\n\tif (slot != null)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnExperimentEnd",
      "HookName": "OnExperimentEnd",
      "HookParameters": {
        "instance": "Workbench"
      },
      "ReturnBehavior": 4,
      "TargetType": "Workbench",
      "Category": "Player",
      "MethodData": {
        "MethodName": "ExperimentComplete",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tint scrapForExperiment = this.GetScrapForExperiment();\r\n\tif (this.pendingBlueprint == null)\r\n\t{\r\n\t\tDebug.LogWarning(\"Pending blueprint was null!\");\r\n\t}\r\n\tif (Interface.CallHook(\"OnExperimentEnd\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (experimentResourceItem != null && experimentResourceItem.amount >= scrapForExperiment && this.pendingBlueprint != null)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnExperimentEnded",
      "HookName": "OnExperimentEnded",
      "HookParameters": {
        "instance": "Workbench"
      },
      "ReturnBehavior": 0,
      "TargetType": "Workbench",
      "Category": "Player",
      "MethodData": {
        "MethodName": "ExperimentComplete",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tint scrapForExperiment = this.GetScrapForExperiment();\r\n\tif (this.pendingBlueprint == null)\r\n\t{\r\n\t\tDebug.LogWarning(\"Pending blueprint was null!\");\r\n\t}\r\n\tif (Interface.CallHook(\"OnExperimentEnd\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (experimentResourceItem != null && experimentResourceItem.amount >= scrapForExperiment && this.pendingBlueprint != null)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnVehicleModuleMove",
      "HookName": "OnVehicleModuleMove",
      "HookParameters": {
        "moduleForItem": "BaseVehicleModule",
        "instance": "BaseModularVehicle",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 4,
      "TargetType": "BaseModularVehicle",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "CanMoveFrom",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer",
          "item": "Item"
        }
      },
      "CodeAfterInjection": "...\r\n\tglobal::BaseVehicleModule moduleForItem = this.GetModuleForItem(item);\r\n\tif (!(moduleForItem != null))\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"OnVehicleModuleMove\", moduleForItem, this, player);\r\n\tif (returnvar != null)\r\n\t{\r\n\t\treturn returnvar is bool && (bool)returnvar;\r\n\t}\r\n\treturn moduleForItem.CanBeMovedNow();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanSwapToSeat [BaseMountable]",
      "HookName": "CanSwapToSeat",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "BaseMountable"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseMountable",
      "Category": "Player",
      "MethodData": {
        "MethodName": "CanSwapToThis",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public virtual bool CanSwapToThis(global::BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanSwapToSeat\", player, this);\r\n\treturn !(returnvar is bool) || (bool)returnvar;\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "CanSwapToSeat [ModularCarSeat]",
      "HookName": "CanSwapToSeat",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "ModularCarSeat"
      },
      "ReturnBehavior": 1,
      "TargetType": "ModularCarSeat",
      "Category": "Player",
      "MethodData": {
        "MethodName": "CanSwapToThis",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public override bool CanSwapToThis(global::BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanSwapToSeat\", player, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif (this.associatedSeatingModule.DoorsAreLockable)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRidableAnimalClaim",
      "HookName": "OnRidableAnimalClaim",
      "HookParameters": {
        "instance": "BaseRidableAnimal",
        "player": "BasePlayer",
        "item": "Item"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseRidableAnimal",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "RPC_Claim",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tglobal::Item item = this.GetPurchaseToken(player, tokenItemID);\r\n\tif (item == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnRidableAnimalClaim\", this, player, item) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.SetFlag(global::BaseEntity.Flags.Reserved2, false, false, true);\r\n\tthis.OnClaimedWithToken(item);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRidableAnimalClaimed",
      "HookName": "OnRidableAnimalClaimed",
      "HookParameters": {
        "instance": "BaseRidableAnimal",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseRidableAnimal",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "RPC_Claim",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tglobal::Item item = this.GetPurchaseToken(player, tokenItemID);\r\n\tif (item == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnRidableAnimalClaim\", this, player, item) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.SetFlag(global::BaseEntity.Flags.Reserved2, false, false, true);\r\n\tthis.OnClaimedWithToken(item);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPhoneNameUpdated",
      "HookName": "OnPhoneNameUpdated",
      "HookDescription": "Called after a player has updated a phones name",
      "HookParameters": {
        "instance": "PhoneController",
        "PhoneName": "string",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "PhoneController",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "UpdatePhoneName",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tstring text = msg.read.String(256);\r\n\tif (text.Length > 20)\r\n\t{\r\n\t\ttext = text.Substring(0, 20);\r\n\t}\r\n\tif (Interface.CallHook(\"OnPhoneNameUpdate\", this, text, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.PhoneName = text;\r\n\tbase.baseEntity.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "IOnEntitySaved",
      "HookName": "IOnEntitySaved",
      "HookParameters": {
        "instance": "BaseNetworkable",
        "saveInfo": "SaveInfo"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseNetworkable",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "ToStream",
        "ReturnType": "void",
        "Arguments": {
          "stream": "System.IO.Stream",
          "saveInfo": "BaseNetworkable/SaveInfo"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t}\r\n\t\tif (saveInfo.msg.baseNetworkable == null)\r\n\t\t{\r\n\t\t\tDebug.LogError(this + \": ToStream - no baseNetworkable!?\");\r\n\t\t}\r\n\t\tInterface.CallHook(\"IOnEntitySaved\", this, saveInfo);\r\n\t\tsaveInfo.msg.ToProto(stream);\r\n\t\tthis.PostSave(saveInfo);\r\n\t}\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntitySnapshot",
      "HookName": "OnEntitySnapshot",
      "HookDescription": "Called when an entity snapshot is about to be sent to a client connection",
      "HookParameters": {
        "instance": "BaseNetworkable",
        "connection": "Connection"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseNetworkable",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "SendAsSnapshot",
        "ReturnType": "void",
        "Arguments": {
          "connection": "Network.Connection",
          "justCreated": "bool"
        }
      },
      "CodeAfterInjection": "protected void SendAsSnapshot(Connection connection, bool justCreated = false)\r\n{\r\n\tif (Interface.CallHook(\"OnEntitySnapshot\", this, connection) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tNetWrite netWrite = Net.sv.StartWrite();\r\n\tconnection.validate.entityUpdates = connection.validate.entityUpdates + 1u;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntitySnapshot [BasePlayer]",
      "HookName": "OnEntitySnapshot",
      "HookDescription": "Called when an entity snapshot is about to be sent to a client connection",
      "HookParameters": {
        "ent": "BaseNetworkable",
        "connection": "Connection"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "SendEntitySnapshot",
        "ReturnType": "void",
        "Arguments": {
          "ent": "BaseNetworkable"
        }
      },
      "CodeAfterInjection": "private void SendEntitySnapshot(global::BaseNetworkable ent)\r\n{\r\n\tif (Interface.CallHook(\"OnEntitySnapshot\", ent, this.net.connection) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tusing (TimeWarning.New(\"SendEntitySnapshot\", 0))\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnNetworkGroupEntered",
      "HookName": "OnNetworkGroupEntered",
      "HookParameters": {
        "instance": "BaseNetworkable",
        "group": "Group"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseNetworkable",
      "Category": "Network",
      "MethodData": {
        "MethodName": "OnNetworkGroupEnter",
        "ReturnType": "void",
        "Arguments": {
          "group": "Network.Visibility.Group"
        }
      },
      "CodeAfterInjection": "public virtual void OnNetworkGroupEnter(Group group)\r\n{\r\n\tInterface.CallHook(\"OnNetworkGroupEntered\", this, group);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnNetworkGroupLeft",
      "HookName": "OnNetworkGroupLeft",
      "HookParameters": {
        "instance": "BaseNetworkable",
        "group": "Group"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseNetworkable",
      "Category": "Network",
      "MethodData": {
        "MethodName": "OnNetworkGroupLeave",
        "ReturnType": "void",
        "Arguments": {
          "group": "Network.Visibility.Group"
        }
      },
      "CodeAfterInjection": "public virtual void OnNetworkGroupLeave(Group group)\r\n{\r\n\tInterface.CallHook(\"OnNetworkGroupLeft\", this, group);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnDemoRecordingStart",
      "HookName": "OnDemoRecordingStart",
      "HookParameters": {
        "text": "string",
        "instance": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "StartDemoRecording",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tif (this.net.connection.IsRecording)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tstring text = string.Format(\"demos/{0}/{1:yyyy-MM-dd-hhmmss}.dem\", this.UserIDString, System.DateTime.Now);\r\n\tif (Interface.CallHook(\"OnDemoRecordingStart\", text, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tDebug.Log(this.ToString() + \" recording started: \" + text);\r\n\tthis.net.connection.StartRecording(text, new ConVar.Demo.Header\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnDemoRecordingStarted",
      "HookName": "OnDemoRecordingStarted",
      "HookParameters": {
        "text": "string",
        "instance": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "StartDemoRecording",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tif (this.net.connection.IsRecording)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tstring text = string.Format(\"demos/{0}/{1:yyyy-MM-dd-hhmmss}.dem\", this.UserIDString, System.DateTime.Now);\r\n\tif (Interface.CallHook(\"OnDemoRecordingStart\", text, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tDebug.Log(this.ToString() + \" recording started: \" + text);\r\n\tthis.net.connection.StartRecording(text, new ConVar.Demo.Header\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnDemoRecordingStop",
      "HookName": "OnDemoRecordingStop",
      "HookParameters": {
        "RecordFilename": "string",
        "instance": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "StopDemoRecording",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (!this.net.connection.IsRecording)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnDemoRecordingStop\", this.net.connection.recordFilename, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tDebug.Log(this.ToString() + \" recording stopped: \" + this.net.connection.RecordFilename);\r\n\tthis.net.connection.StopRecording();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnDemoRecordingStopped",
      "HookName": "OnDemoRecordingStopped",
      "HookParameters": {
        "RecordFilename": "string",
        "instance": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "StopDemoRecording",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (!this.net.connection.IsRecording)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnDemoRecordingStop\", this.net.connection.recordFilename, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tDebug.Log(this.ToString() + \" recording stopped: \" + this.net.connection.RecordFilename);\r\n\tthis.net.connection.StopRecording();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnOvenCook",
      "HookName": "OnOvenCook",
      "HookDescription": "Called before an oven cooks an item",
      "HookParameters": {
        "instance": "BaseOven",
        "item": "Item"
      },
      "ReturnBehavior": 4,
      "TargetType": "BaseOven",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "Cook",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void Cook()\r\n{\r\n\tglobal::Item item = this.FindBurnable();\r\n\tif (Interface.CallHook(\"OnOvenCook\", this, item) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (item == null && !this.CanRunWithNoFuel)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnOvenCooked",
      "HookName": "OnOvenCooked",
      "HookDescription": "Called after an oven cooks an item",
      "HookParameters": {
        "instance": "BaseOven",
        "item": "Item",
        "enumerator": "BaseEntity"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseOven",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "Cook",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void Cook()\r\n{\r\n\tglobal::Item item = this.FindBurnable();\r\n\tif (Interface.CallHook(\"OnOvenCook\", this, item) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (item == null && !this.CanRunWithNoFuel)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFuelConsumed",
      "HookName": "OnFuelConsumed",
      "HookParameters": {
        "instance": "BaseOven",
        "fuel": "Item",
        "burnable": "ItemModBurnable"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseOven",
      "Category": "Fuel",
      "MethodData": {
        "MethodName": "ConsumeFuel",
        "ReturnType": "void",
        "Arguments": {
          "fuel": "Item",
          "burnable": "ItemModBurnable"
        }
      },
      "CodeAfterInjection": "private void ConsumeFuel(global::Item fuel, global::ItemModBurnable burnable)\r\n{\r\n\tif (Interface.CallHook(\"OnFuelConsume\", this, fuel, burnable) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.allowByproductCreation && burnable.byproductItem != null && UnityEngine.Random.Range(0f, 1f) > burnable.byproductChance)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFuelAmountCheck",
      "HookName": "OnFuelAmountCheck",
      "HookParameters": {
        "instance": "EntityFuelSystem",
        "fuelItem": "Item"
      },
      "ReturnBehavior": 1,
      "TargetType": "EntityFuelSystem",
      "Category": "Fuel",
      "MethodData": {
        "MethodName": "GetFuelAmount",
        "ReturnType": "int",
        "Arguments": {}
      },
      "CodeAfterInjection": "public int GetFuelAmount()\r\n{\r\n\tglobal::Item fuelItem = this.GetFuelItem();\r\n\tobject returnvar = Interface.CallHook(\"OnFuelAmountCheck\", this, fuelItem);\r\n\tif (returnvar is int)\r\n\t{\r\n\t\treturn (int)returnvar;\r\n\t}\r\n\tif (fuelItem == null || fuelItem.amount < 1)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFuelItemCheck",
      "HookName": "OnFuelItemCheck",
      "HookParameters": {
        "instance": "EntityFuelSystem",
        "fuelContainer": "StorageContainer"
      },
      "ReturnBehavior": 1,
      "TargetType": "EntityFuelSystem",
      "Category": "Fuel",
      "MethodData": {
        "MethodName": "GetFuelItem",
        "ReturnType": "Item",
        "Arguments": {}
      },
      "CodeAfterInjection": "public global::Item GetFuelItem()\r\n{\r\n\tglobal::StorageContainer fuelContainer = this.GetFuelContainer();\r\n\tobject returnvar = Interface.CallHook(\"OnFuelItemCheck\", this, fuelContainer);\r\n\tif (returnvar is global::Item)\r\n\t{\r\n\t\treturn (global::Item)returnvar;\r\n\t}\r\n\tif (fuelContainer == null)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFuelCheck",
      "HookName": "OnFuelCheck",
      "HookParameters": {
        "instance": "EntityFuelSystem"
      },
      "ReturnBehavior": 1,
      "TargetType": "EntityFuelSystem",
      "Category": "Fuel",
      "MethodData": {
        "MethodName": "HasFuel",
        "ReturnType": "bool",
        "Arguments": {
          "forceCheck": "bool"
        }
      },
      "CodeAfterInjection": "public bool HasFuel(bool forceCheck = false)\r\n{\r\n\tif (Time.time > this.nextFuelCheckTime | forceCheck)\r\n\t{\r\n\t\tobject returnvar = Interface.CallHook(\"OnFuelCheck\", this);\r\n\t\tif (returnvar is bool)\r\n\t\t{\r\n\t\t\treturn (bool)returnvar;\r\n\t\t}\r\n\t\tthis.cachedHasFuel = ((float)this.GetFuelAmount() > 0f);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanCheckFuel",
      "HookName": "CanCheckFuel",
      "HookParameters": {
        "instance": "EntityFuelSystem",
        "fuelContainer": "StorageContainer",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "EntityFuelSystem",
      "Category": "Fuel",
      "MethodData": {
        "MethodName": "IsInFuelInteractionRange",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public bool IsInFuelInteractionRange(global::BasePlayer player)\r\n{\r\n\tglobal::StorageContainer fuelContainer = this.GetFuelContainer();\r\n\tobject returnvar = Interface.CallHook(\"CanCheckFuel\", this, fuelContainer, player);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif (fuelContainer != null)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanUseFuel",
      "HookName": "CanUseFuel",
      "HookParameters": {
        "instance": "EntityFuelSystem",
        "fuelContainer": "StorageContainer",
        "seconds": "float",
        "fuelUsedPerSecond": "float"
      },
      "ReturnBehavior": 4,
      "TargetType": "EntityFuelSystem",
      "Category": "Fuel",
      "MethodData": {
        "MethodName": "TryUseFuel",
        "ReturnType": "int",
        "Arguments": {
          "seconds": "float",
          "fuelUsedPerSecond": "float"
        }
      },
      "CodeAfterInjection": "public int TryUseFuel(float seconds, float fuelUsedPerSecond)\r\n{\r\n\tglobal::StorageContainer fuelContainer = this.GetFuelContainer();\r\n\tobject returnvar = Interface.CallHook(\"CanUseFuel\", this, fuelContainer, seconds, fuelUsedPerSecond);\r\n\tif (returnvar is int)\r\n\t{\r\n\t\treturn (int)returnvar;\r\n\t}\r\n\tif (fuelContainer == null)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanUnlockTechTreeNode",
      "HookName": "CanUnlockTechTreeNode",
      "HookParameters": {
        "player": "BasePlayer",
        "node": "NodeInstance",
        "instance": "TechTreeData"
      },
      "ReturnBehavior": 1,
      "TargetType": "TechTreeData",
      "Category": "TechTree",
      "MethodData": {
        "MethodName": "PlayerCanUnlock",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer",
          "node": "TechTreeData/NodeInstance"
        }
      },
      "CodeAfterInjection": "public bool PlayerCanUnlock(global::BasePlayer player, global::TechTreeData.NodeInstance node)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanUnlockTechTreeNode\", player, node, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn this.PlayerHasPathForUnlock(player, node) && !this.HasPlayerUnlocked(player, node);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanUnlockTechTreeNodePath",
      "HookName": "CanUnlockTechTreeNodePath",
      "HookParameters": {
        "player": "BasePlayer",
        "node": "NodeInstance",
        "instance": "TechTreeData"
      },
      "ReturnBehavior": 1,
      "TargetType": "TechTreeData",
      "Category": "TechTree",
      "MethodData": {
        "MethodName": "PlayerHasPathForUnlock",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer",
          "node": "TechTreeData/NodeInstance"
        }
      },
      "CodeAfterInjection": "public bool PlayerHasPathForUnlock(global::BasePlayer player, global::TechTreeData.NodeInstance node)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanUnlockTechTreeNodePath\", player, node, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tglobal::TechTreeData.NodeInstance entryNode = this.GetEntryNode();\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnIORefCleared [patch]",
      "HookName": "OnIORefCleared [patch]",
      "ReturnBehavior": 0,
      "TargetType": "IOEntity/IORef",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "Clear",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void Clear()\r\n{\r\n\tglobal::IOEntity OxideGen_0 = this.ioEnt;\r\n\tthis.ioEnt = null;\r\n\tthis.entityRef.Set(null);\r\n\tInterface.CallHook(\"OnIORefCleared\", this, OxideGen_0);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnIORefCleared",
      "HookName": "OnIORefCleared",
      "HookDescription": "Called after a wire has been disconnected from an electrical entity, such as when its connected entity was destroyed or when a player removed the wire",
      "HookParameters": {
        "instance": "IORef",
        "OxideGen_0": "IOEntity"
      },
      "ReturnBehavior": 0,
      "TargetType": "IOEntity/IORef",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "Clear",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void Clear()\r\n{\r\n\tglobal::IOEntity OxideGen_0 = this.ioEnt;\r\n\tthis.ioEnt = null;\r\n\tthis.entityRef.Set(null);\r\n\tInterface.CallHook(\"OnIORefCleared\", this, OxideGen_0);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTechTreeNodeUnlock",
      "HookName": "OnTechTreeNodeUnlock",
      "HookParameters": {
        "instance": "Workbench",
        "byID": "NodeInstance",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "Workbench",
      "Category": "TechTree",
      "MethodData": {
        "MethodName": "RPC_TechTreeUnlock",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t\tDebug.Log(\"Player unlocked group :\" + byID.groupName);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (byID.itemDef != null)\r\n\t\t{\r\n\t\t\tif (Interface.CallHook(\"OnTechTreeNodeUnlock\", this, byID, player) != null)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tint num2 = global::ResearchTable.ScrapForResearch(byID.itemDef, global::ResearchTable.ResearchType.TechTree);\r\n\t\t\tint itemid = global::ItemManager.FindItemDefinition(\"scrap\").itemid;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTechTreeNodeUnlocked",
      "HookName": "OnTechTreeNodeUnlocked",
      "HookParameters": {
        "instance": "Workbench",
        "byID": "NodeInstance",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "Workbench",
      "Category": "TechTree",
      "MethodData": {
        "MethodName": "RPC_TechTreeUnlock",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t\tDebug.Log(\"Player unlocked group :\" + byID.groupName);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (byID.itemDef != null)\r\n\t\t{\r\n\t\t\tif (Interface.CallHook(\"OnTechTreeNodeUnlock\", this, byID, player) != null)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tint num2 = global::ResearchTable.ScrapForResearch(byID.itemDef, global::ResearchTable.ResearchType.TechTree);\r\n\t\t\tint itemid = global::ItemManager.FindItemDefinition(\"scrap\").itemid;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPhoneAnswer",
      "HookName": "OnPhoneAnswer",
      "HookParameters": {
        "instance": "PhoneController",
        "activeCallTo": "PhoneController"
      },
      "ReturnBehavior": 4,
      "TargetType": "PhoneController",
      "Category": "Phone",
      "MethodData": {
        "MethodName": "AnswerPhone",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (this.activeCallTo == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::BasePlayer player = msg.player;\r\n\tif (Interface.CallHook(\"OnPhoneAnswer\", this, this.activeCallTo) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.UpdateServerPlayer(player);\r\n\tthis.BeginCall();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPhoneCallStart",
      "HookName": "OnPhoneCallStart",
      "HookParameters": {
        "instance": "PhoneController",
        "activeCallTo": "PhoneController",
        "currentPlayer": "BasePlayer"
      },
      "ReturnBehavior": 4,
      "TargetType": "PhoneController",
      "Category": "Phone",
      "MethodData": {
        "MethodName": "BeginCall",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void BeginCall()\r\n{\r\n\tif (Interface.CallHook(\"OnPhoneCallStart\", this, this.activeCallTo, this.currentPlayer) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.IsMobile && this.activeCallTo != null && !this.activeCallTo.RequirePower)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPhoneCallStarted",
      "HookName": "OnPhoneCallStarted",
      "HookParameters": {
        "instance": "PhoneController",
        "activeCallTo": "PhoneController",
        "currentPlayer": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "PhoneController",
      "Category": "Phone",
      "MethodData": {
        "MethodName": "BeginCall",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void BeginCall()\r\n{\r\n\tif (Interface.CallHook(\"OnPhoneCallStart\", this, this.activeCallTo, this.currentPlayer) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.IsMobile && this.activeCallTo != null && !this.activeCallTo.RequirePower)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanReceiveCall",
      "HookName": "CanReceiveCall",
      "HookParameters": {
        "instance": "PhoneController"
      },
      "ReturnBehavior": 1,
      "TargetType": "PhoneController",
      "Category": "Phone",
      "MethodData": {
        "MethodName": "CanReceiveCall",
        "ReturnType": "bool",
        "Arguments": {}
      },
      "CodeAfterInjection": "private bool CanReceiveCall()\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanReceiveCall\", this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn (!this.RequirePower || this.IsPowered()) && (!this.RequireParent || base.baseEntity.HasParent());\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPhoneDial",
      "HookName": "OnPhoneDial",
      "HookParameters": {
        "instance": "PhoneController",
        "telephone": "PhoneController",
        "currentPlayer": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "PhoneController",
      "Category": "Phone",
      "MethodData": {
        "MethodName": "CallPhone",
        "ReturnType": "void",
        "Arguments": {
          "number": "int"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (!(telephone != null))\r\n\t{\r\n\t\tthis.OnDialFailed(global::Telephone.DialFailReason.WrongNumber);\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnPhoneDial\", this, telephone, this.currentPlayer) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (telephone.serverState == global::Telephone.CallState.Idle && telephone.CanReceiveCall())\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPhoneDialFail",
      "HookName": "OnPhoneDialFail",
      "HookParameters": {
        "instance": "PhoneController",
        "reason": "DialFailReason",
        "currentPlayer": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "PhoneController",
      "Category": "Phone",
      "MethodData": {
        "MethodName": "OnDialFailed",
        "ReturnType": "void",
        "Arguments": {
          "reason": "Telephone/DialFailReason"
        }
      },
      "CodeAfterInjection": "public void OnDialFailed(global::Telephone.DialFailReason reason)\r\n{\r\n\tif (Interface.CallHook(\"OnPhoneDialFail\", this, reason, this.currentPlayer) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.SetPhoneState(global::Telephone.CallState.Idle);\r\n\tbase.baseEntity.ClientRPC<int>(null, \"ClientOnDialFailed\", (int)reason);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPhoneDialTimeout",
      "HookName": "OnPhoneDialTimeout",
      "HookParameters": {
        "activeCallTo": "PhoneController",
        "instance": "PhoneController",
        "currentPlayer": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "PhoneController",
      "Category": "Phone",
      "MethodData": {
        "MethodName": "TimeOutDialing",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "private void TimeOutDialing()\r\n{\r\n\tif (Interface.CallHook(\"OnPhoneDialTimeout\", this.activeCallTo, this, this.activeCallTo.currentPlayer) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.activeCallTo != null)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPhoneDialFailed",
      "HookName": "OnPhoneDialFailed",
      "HookParameters": {
        "instance": "PhoneController",
        "reason": "DialFailReason",
        "currentPlayer": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "PhoneController",
      "Category": "Phone",
      "MethodData": {
        "MethodName": "OnDialFailed",
        "ReturnType": "void",
        "Arguments": {
          "reason": "Telephone/DialFailReason"
        }
      },
      "CodeAfterInjection": "public void OnDialFailed(global::Telephone.DialFailReason reason)\r\n{\r\n\tif (Interface.CallHook(\"OnPhoneDialFail\", this, reason, this.currentPlayer) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.SetPhoneState(global::Telephone.CallState.Idle);\r\n\tbase.baseEntity.ClientRPC<int>(null, \"ClientOnDialFailed\", (int)reason);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPhoneDialTimedOut",
      "HookName": "OnPhoneDialTimedOut",
      "HookParameters": {
        "activeCallTo": "PhoneController",
        "instance": "PhoneController",
        "currentPlayer": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "PhoneController",
      "Category": "Phone",
      "MethodData": {
        "MethodName": "TimeOutDialing",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "private void TimeOutDialing()\r\n{\r\n\tif (Interface.CallHook(\"OnPhoneDialTimeout\", this.activeCallTo, this, this.activeCallTo.currentPlayer) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.activeCallTo != null)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPhoneAnswered",
      "HookName": "OnPhoneAnswered",
      "HookParameters": {
        "instance": "PhoneController",
        "activeCallTo": "PhoneController"
      },
      "ReturnBehavior": 0,
      "TargetType": "PhoneController",
      "Category": "Phone",
      "MethodData": {
        "MethodName": "AnswerPhone",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (this.activeCallTo == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::BasePlayer player = msg.player;\r\n\tif (Interface.CallHook(\"OnPhoneAnswer\", this, this.activeCallTo) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.UpdateServerPlayer(player);\r\n\tthis.BeginCall();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnInventoryNetworkUpdate",
      "HookName": "OnInventoryNetworkUpdate",
      "HookParameters": {
        "instance": "PlayerInventory",
        "container": "ItemContainer",
        "updateItemContainer": "UpdateItemContainer",
        "type": "Type",
        "bSendInventoryToEveryone": "bool"
      },
      "ReturnBehavior": 1,
      "TargetType": "PlayerInventory",
      "Category": "Player",
      "MethodData": {
        "MethodName": "SendUpdatedInventory",
        "ReturnType": "void",
        "Arguments": {
          "type": "PlayerInventory/Type",
          "container": "ItemContainer",
          "bSendInventoryToEveryone": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t{\r\n\t\t\tcontainer.dirty = false;\r\n\t\t\tupdateItemContainer.container = Pool.Get<System.Collections.Generic.List<ProtoBuf.ItemContainer>>();\r\n\t\t\tupdateItemContainer.container.Add(container.Save());\r\n\t\t}\r\n\t\tif (Interface.CallHook(\"OnInventoryNetworkUpdate\", this, container, updateItemContainer, type, bSendInventoryToEveryone) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (bSendInventoryToEveryone)\r\n\t\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnResearchCostDetermine [ItemDef]",
      "HookName": "OnResearchCostDetermine",
      "HookParameters": {
        "info": "ItemDefinition"
      },
      "ReturnBehavior": 1,
      "TargetType": "ResearchTable",
      "Category": "Item",
      "MethodData": {
        "MethodName": "ScrapForResearch",
        "ReturnType": "int",
        "Arguments": {
          "info": "ItemDefinition",
          "type": "ResearchTable/ResearchType"
        }
      },
      "CodeAfterInjection": "public static int ScrapForResearch(global::ItemDefinition info, global::ResearchTable.ResearchType type)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"OnResearchCostDetermine\", info);\r\n\tif (returnvar is int)\r\n\t{\r\n\t\treturn (int)returnvar;\r\n\t}\r\n\tint num = 0;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityFlagsNetworkUpdate",
      "HookName": "OnEntityFlagsNetworkUpdate",
      "HookDescription": "Called after an entity's flags have been updated on the server, before they are sent over the network",
      "HookParameters": {
        "instance": "BaseEntity"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseEntity",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "SendNetworkUpdate_Flags",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\treturn;\r\n\t}\r\n\tusing (TimeWarning.New(\"SendNetworkUpdate_Flags\", 0))\r\n\t{\r\n\t\tbase.LogEntry(global::BaseMonoBehaviour.LogEntryType.Network, 2, \"SendNetworkUpdate_Flags\");\r\n\t\tif (Interface.CallHook(\"OnEntityFlagsNetworkUpdate\", this) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tSystem.Collections.Generic.List<Connection> subscribers = base.GetSubscribers();\r\n\t\tif (subscribers != null && subscribers.Count > 0)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnLootNetworkUpdate",
      "HookName": "OnLootNetworkUpdate",
      "HookParameters": {
        "instance": "PlayerLoot"
      },
      "ReturnBehavior": 1,
      "TargetType": "PlayerLoot",
      "Category": "Player",
      "MethodData": {
        "MethodName": "SendUpdate",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tthis.isInvokingSendUpdate = false;\r\n\tif (!base.baseEntity.IsValid())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnLootNetworkUpdate\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tusing (PlayerUpdateLoot playerUpdateLoot = Pool.Get<PlayerUpdateLoot>())\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnVendingTransaction",
      "HookName": "OnVendingTransaction",
      "HookParameters": {
        "instance": "VendingMachine",
        "buyer": "BasePlayer",
        "sellOrderId": "int",
        "numberOfTransactions": "int",
        "targetContainer": "ItemContainer"
      },
      "ReturnBehavior": 1,
      "TargetType": "VendingMachine",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "DoTransaction",
        "ReturnType": "bool",
        "Arguments": {
          "buyer": "BasePlayer",
          "sellOrderId": "int",
          "numberOfTransactions": "int",
          "targetContainer": "ItemContainer",
          "onCurrencyRemoved": "System.Action`2<BasePlayer,Item>",
          "onItemPurchased": "System.Action`2<BasePlayer,Item>",
          "droneMarketTerminal": "MarketTerminal"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (targetContainer == null && Vector3.Distance(buyer.transform.position, base.transform.position) > 4f)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"OnVendingTransaction\", this, buyer, sellOrderId, numberOfTransactions, targetContainer);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tProtoBuf.VendingMachine.SellOrder sellOrder = this.sellOrders.sellOrders[sellOrderId];\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFindSpawnPoint",
      "HookName": "OnFindSpawnPoint",
      "HookParameters": {
        "forPlayer": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "ServerMgr",
      "Category": "Player",
      "MethodData": {
        "MethodName": "FindSpawnPoint",
        "ReturnType": "BasePlayer/SpawnPoint",
        "Arguments": {
          "forPlayer": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public static global::BasePlayer.SpawnPoint FindSpawnPoint(global::BasePlayer forPlayer = null)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"OnFindSpawnPoint\", forPlayer);\r\n\tif (returnvar is global::BasePlayer.SpawnPoint)\r\n\t{\r\n\t\treturn (global::BasePlayer.SpawnPoint)returnvar;\r\n\t}\r\n\tbool flag = false;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanLock [key]",
      "HookName": "CanLock",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "KeyLock"
      },
      "ReturnBehavior": 1,
      "TargetType": "KeyLock",
      "Category": "Player",
      "MethodData": {
        "MethodName": "Lock",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (base.IsLocked())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanLock\", player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!this.HasLockPermission(player))\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnNpcConversationEnded",
      "HookName": "OnNpcConversationEnded",
      "HookParameters": {
        "instance": "NPCTalking",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "NPCTalking",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "ForceEndConversation",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public void ForceEndConversation(global::BasePlayer player)\r\n{\r\n\tbase.ClientRPCPlayer(null, player, \"Client_EndConversation\");\r\n\tInterface.CallHook(\"OnNpcConversationEnded\", this, player);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnNpcConversationEnded",
      "HookName": "OnNpcConversationEnded",
      "HookParameters": {
        "instance": "NPCTalking",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "NPCTalking",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "Server_EndTalking",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.CallsPerSecond(1uL), global::BaseEntity.RPC_Server.MaxDistance(3f)]\r\npublic void Server_EndTalking(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tthis.OnConversationEnded(msg.player);\r\n\tInterface.CallHook(\"OnNpcConversationEnded\", this, msg.player);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBookmarkControlStarted",
      "HookName": "OnBookmarkControlStarted",
      "HookDescription": "Called after a player has selected a bookmark at a computer station",
      "HookParameters": {
        "instance": "ComputerStation",
        "player": "BasePlayer",
        "text": "string",
        "remoteControllable": "IRemoteControllable"
      },
      "ReturnBehavior": 0,
      "TargetType": "ComputerStation",
      "Category": "Bookmark",
      "MethodData": {
        "MethodName": "BeginControllingBookmark",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (Vector3.Distance(base.transform.position, ent.transform.position) >= remoteControllable.MaxRange)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnBookmarkControl\", this, player, text, remoteControllable) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::BaseEntity baseEntity = this.currentlyControllingEnt.Get(true);\r\n\tif (baseEntity)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBookmarkControlEnded",
      "HookName": "OnBookmarkControlEnded",
      "HookDescription": "Called after a player has stopped viewing/controlling an entity at a computer station",
      "HookParameters": {
        "instance": "ComputerStation",
        "ply": "BasePlayer",
        "baseEntity": "BaseEntity"
      },
      "ReturnBehavior": 0,
      "TargetType": "ComputerStation",
      "Category": "Bookmark",
      "MethodData": {
        "MethodName": "StopControl",
        "ReturnType": "void",
        "Arguments": {
          "ply": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public void StopControl(global::BasePlayer ply)\r\n{\r\n\tglobal::BaseEntity baseEntity = this.currentlyControllingEnt.Get(true);\r\n\tif (baseEntity)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnBookmarkControlEnd\", this, ply, baseEntity) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tbaseEntity.GetComponent<global::IRemoteControllable>().StopControl(new global::CameraViewerId(this.currentPlayerID, 0L));\r\n\t}\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnPlayerAddModifiers",
      "HookName": "OnPlayerAddModifiers",
      "ReturnBehavior": 0,
      "TargetType": "ItemModConsume",
      "Category": "Player",
      "MethodData": {
        "MethodName": "DoAction",
        "ReturnType": "void",
        "Arguments": {
          "item": "Item",
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t\t{\r\n\t\t\t\tplayer.metabolism.ApplyChange(current.type, current.amount * num3 * num4, current.time * num3 * num4);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (player.modifiers != null && Interface.CallHook(\"OnPlayerAddModifiers\", player, item, consumable) == null)\r\n\t{\r\n\t\tplayer.modifiers.Add(consumable.modifiers);\r\n\t}\r\n\tif (this.product != null)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCargoPlaneSignaled",
      "HookName": "OnCargoPlaneSignaled",
      "HookDescription": "Called when a supply signal has called a cargo plane",
      "HookParameters": {
        "baseEntity": "BaseEntity",
        "instance": "SupplySignal"
      },
      "ReturnBehavior": 0,
      "TargetType": "SupplySignal",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "Explode",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tif (baseEntity)\r\n\t{\r\n\t\tVector3 b = new Vector3(UnityEngine.Random.Range(-20f, 20f), 0f, UnityEngine.Random.Range(-20f, 20f));\r\n\t\tbaseEntity.SendMessage(\"InitDropPosition\", base.transform.position + b, SendMessageOptions.DontRequireReceiver);\r\n\t\tbaseEntity.Spawn();\r\n\t\tInterface.CallHook(\"OnCargoPlaneSignaled\", baseEntity, this);\r\n\t}\r\n\tbase.Invoke(new System.Action(this.FinishUp), 210f);\r\n\tbase.SetFlag(global::BaseEntity.Flags.On, true, false, true);\r\n\tbase.SendNetworkUpdateImmediate(false);\r\n}\r\n"
    },
    {
      "Type": 1,
      "Name": "OnCargoPlaneSignaled [Patch]",
      "HookName": "OnCargoPlaneSignaled [Patch]",
      "ReturnBehavior": 0,
      "TargetType": "SupplySignal",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "Explode",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tif (baseEntity)\r\n\t{\r\n\t\tVector3 b = new Vector3(UnityEngine.Random.Range(-20f, 20f), 0f, UnityEngine.Random.Range(-20f, 20f));\r\n\t\tbaseEntity.SendMessage(\"InitDropPosition\", base.transform.position + b, SendMessageOptions.DontRequireReceiver);\r\n\t\tbaseEntity.Spawn();\r\n\t\tInterface.CallHook(\"OnCargoPlaneSignaled\", baseEntity, this);\r\n\t}\r\n\tbase.Invoke(new System.Action(this.FinishUp), 210f);\r\n\tbase.SetFlag(global::BaseEntity.Flags.On, true, false, true);\r\n\tbase.SendNetworkUpdateImmediate(false);\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSupplyDropDropped",
      "HookName": "OnSupplyDropDropped",
      "HookDescription": "Called right after a cargo plane has dropped a supply drop",
      "HookParameters": {
        "baseEntity": "BaseEntity",
        "instance": "CargoPlane"
      },
      "ReturnBehavior": 0,
      "TargetType": "CargoPlane",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "Update",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\tglobal::BaseEntity baseEntity = global::GameManager.server.CreateEntity(this.prefabDrop.resourcePath, base.transform.position, default(Quaternion), true);\r\n\t\tif (baseEntity)\r\n\t\t{\r\n\t\t\tbaseEntity.globalBroadcast = true;\r\n\t\t\tbaseEntity.Spawn();\r\n\t\t\tInterface.CallHook(\"OnSupplyDropDropped\", baseEntity, this);\r\n\t\t}\r\n\t}\r\n\tbase.transform.position = Vector3.Lerp(this.startPos, this.endPos, num);\r\n\tbase.transform.hasChanged = true;\r\n\tif (num >= 1f)\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnSupplyDropDropped [patch 1]",
      "HookName": "OnSupplyDropDropped [patch 1]",
      "ReturnBehavior": 0,
      "TargetType": "CargoPlane",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "Update",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\tglobal::BaseEntity baseEntity = global::GameManager.server.CreateEntity(this.prefabDrop.resourcePath, base.transform.position, default(Quaternion), true);\r\n\t\tif (baseEntity)\r\n\t\t{\r\n\t\t\tbaseEntity.globalBroadcast = true;\r\n\t\t\tbaseEntity.Spawn();\r\n\t\t\tInterface.CallHook(\"OnSupplyDropDropped\", baseEntity, this);\r\n\t\t}\r\n\t}\r\n\tbase.transform.position = Vector3.Lerp(this.startPos, this.endPos, num);\r\n\tbase.transform.hasChanged = true;\r\n\tif (num >= 1f)\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnSupplyDropDropped [patch 2]",
      "HookName": "OnSupplyDropDropped [patch 2]",
      "ReturnBehavior": 0,
      "TargetType": "CargoPlane",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "Update",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\tglobal::BaseEntity baseEntity = global::GameManager.server.CreateEntity(this.prefabDrop.resourcePath, base.transform.position, default(Quaternion), true);\r\n\t\tif (baseEntity)\r\n\t\t{\r\n\t\t\tbaseEntity.globalBroadcast = true;\r\n\t\t\tbaseEntity.Spawn();\r\n\t\t\tInterface.CallHook(\"OnSupplyDropDropped\", baseEntity, this);\r\n\t\t}\r\n\t}\r\n\tbase.transform.position = Vector3.Lerp(this.startPos, this.endPos, num);\r\n\tbase.transform.hasChanged = true;\r\n\tif (num >= 1f)\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnSupplyDropDropped [patch 3]",
      "HookName": "OnSupplyDropDropped [patch 3]",
      "ReturnBehavior": 0,
      "TargetType": "CargoPlane",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "Update",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\tglobal::BaseEntity baseEntity = global::GameManager.server.CreateEntity(this.prefabDrop.resourcePath, base.transform.position, default(Quaternion), true);\r\n\t\tif (baseEntity)\r\n\t\t{\r\n\t\t\tbaseEntity.globalBroadcast = true;\r\n\t\t\tbaseEntity.Spawn();\r\n\t\t\tInterface.CallHook(\"OnSupplyDropDropped\", baseEntity, this);\r\n\t\t}\r\n\t}\r\n\tbase.transform.position = Vector3.Lerp(this.startPos, this.endPos, num);\r\n\tbase.transform.hasChanged = true;\r\n\tif (num >= 1f)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBookmarkControlEnded [2]",
      "HookName": "OnBookmarkControlEnded",
      "HookDescription": "",
      "HookParameters": {
        "instance": "ComputerStation",
        "player": "BasePlayer",
        "b": "IRemoteControllable"
      },
      "ReturnBehavior": 0,
      "TargetType": "ComputerStation",
      "Category": "Bookmark",
      "MethodData": {
        "MethodName": "BeginControllingBookmark",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (Vector3.Distance(base.transform.position, ent.transform.position) >= remoteControllable.MaxRange)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnBookmarkControl\", this, player, text, remoteControllable) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::BaseEntity baseEntity = this.currentlyControllingEnt.Get(true);\r\n\tif (baseEntity)\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnBookmarkControlEnded [2] [patch]",
      "HookName": "OnBookmarkControlEnded [2] [patch]",
      "ReturnBehavior": 0,
      "TargetType": "ComputerStation",
      "Category": "Bookmark",
      "MethodData": {
        "MethodName": "BeginControllingBookmark",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (Vector3.Distance(base.transform.position, ent.transform.position) >= remoteControllable.MaxRange)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnBookmarkControl\", this, player, text, remoteControllable) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::BaseEntity baseEntity = this.currentlyControllingEnt.Get(true);\r\n\tif (baseEntity)\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "LimitNetworkingNoEffect [patch 1]",
      "HookName": "LimitNetworkingNoEffect [patch 1]",
      "ReturnBehavior": 0,
      "TargetType": "Effect/server",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "ImpactEffect",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "public static void ImpactEffect(global::HitInfo info)\r\n{\r\n\tif (Interface.CallHook(\"OnImpactEffectCreate\", info) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (info.InitiatorPlayer && info.InitiatorPlayer.limitNetworking)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "LimitNetworkingNoEffect [patch 2]",
      "HookName": "LimitNetworkingNoEffect [patch 2]",
      "ReturnBehavior": 0,
      "TargetType": "BaseProjectile",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "CLProject",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\tglobal::AntiHack.Log(player, global::AntiHackType.ProjectileHack, \"Count mismatch (\" + base.ShortPrefabName + \")\");\r\n\t\tplayer.stats.combat.LogInvalid(player, this, \"count_mismatch\");\r\n\t\treturn;\r\n\t}\r\n\tInterface.CallHook(\"OnWeaponFired\", this, msg.player, component, projectileShoot);\r\n\tif (player.InGesture)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.SignalBroadcast(global::BaseEntity.Signal.Attack, string.Empty, msg.connection);\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "LimitNetworkingNoEffect [patch 3]",
      "HookName": "LimitNetworkingNoEffect [patch 3]",
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "OnAttacked",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "public override void OnAttacked(global::HitInfo info)\r\n{\r\n\tif (Interface.CallHook(\"IOnBasePlayerAttacked\", this, info) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat health = base.health;\r\n\tif (this.InSafeZone() && !this.IsHostile() && info.Initiator != null && info.Initiator != this)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemSubmit",
      "HookName": "OnItemSubmit",
      "HookParameters": {
        "slot": "Item",
        "instance": "Mailbox",
        "fromPlayer": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "Mailbox",
      "Category": "Item",
      "MethodData": {
        "MethodName": "SubmitInputItems",
        "ReturnType": "void",
        "Arguments": {
          "fromPlayer": "BasePlayer"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (slot != null)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnItemSubmit\", slot, this, fromPlayer) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (this.MoveItemToStorage(slot))\r\n\t\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemStacked [1]",
      "HookName": "OnItemStacked",
      "HookParameters": {
        "i": "Item",
        "instance": "Item",
        "newcontainer": "ItemContainer",
        "slot2": "int"
      },
      "ReturnBehavior": 0,
      "TargetType": "Item",
      "Category": "Item",
      "MethodData": {
        "MethodName": "MoveToContainer",
        "ReturnType": "bool",
        "Arguments": {
          "newcontainer": "ItemContainer",
          "iTargetPos": "int",
          "allowStack": "bool",
          "ignoreStackLimit": "bool",
          "sourcePlayer": "BasePlayer",
          "allowSwap": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t\t\t\t\tint num2 = Mathf.Min(num - slot2.amount, this.amount);\r\n\t\t\t\t\t\tslot2.amount += num2;\r\n\t\t\t\t\t\tthis.amount -= num2;\r\n\t\t\t\t\t\tslot2.MarkDirty();\r\n\t\t\t\t\t\tthis.MarkDirty();\r\n\t\t\t\t\t\tInterface.CallHook(\"OnItemStacked\", slot2, this, newcontainer, num2);\r\n\t\t\t\t\t\tif (this.amount <= 0)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tthis.RemoveFromWorld();\r\n\t\t\t\t\t\t\tthis.RemoveFromContainer();\r\n\t\t\t\t\t\t\tthis.Remove(0f);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnThreatLevelUpdate",
      "HookName": "OnThreatLevelUpdate",
      "HookParameters": {
        "instance": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "EnsureUpdated",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tthis.lastUpdateTime = Time.realtimeSinceStartup;\r\n\tthis.cachedThreatLevel = 0f;\r\n\tif (!this.IsSleeping())\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnThreatLevelUpdate\", this) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (this.inventory.containerWear.itemList.Count > 2)\r\n\t\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnWaterPurify",
      "HookName": "OnWaterPurify",
      "HookDescription": "Called when salt water is about to be converted to fresh water in a water purifier",
      "HookParameters": {
        "instance": "WaterPurifier",
        "timeCooked": "Single"
      },
      "ReturnBehavior": 4,
      "TargetType": "WaterPurifier",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "ConvertWater",
        "ReturnType": "void",
        "Arguments": {
          "timeCooked": "float"
        }
      },
      "CodeAfterInjection": "...\r\n\t\tif (slot != null && slot.amount >= slot.MaxStackable())\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\tif (Interface.CallHook(\"OnWaterPurify\", this, timeCooked) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat num = timeCooked * ((float)this.waterToProcessPerMinute / 60f);\r\n\tthis.dirtyWaterProcssed += num;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnWaterPurified",
      "HookName": "OnWaterPurified",
      "HookDescription": "Called after salt water has been converted to fresh water in a water purifier",
      "HookParameters": {
        "instance": "WaterPurifier",
        "timeCooked": "Single"
      },
      "ReturnBehavior": 0,
      "TargetType": "WaterPurifier",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "ConvertWater",
        "ReturnType": "void",
        "Arguments": {
          "timeCooked": "float"
        }
      },
      "CodeAfterInjection": "...\r\n\t\tif (slot != null && slot.amount >= slot.MaxStackable())\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\tif (Interface.CallHook(\"OnWaterPurify\", this, timeCooked) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat num = timeCooked * ((float)this.waterToProcessPerMinute / 60f);\r\n\tthis.dirtyWaterProcssed += num;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanUseGesture",
      "HookName": "CanUseGesture",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "GestureConfig"
      },
      "ReturnBehavior": 1,
      "TargetType": "GestureConfig",
      "Category": "Player",
      "MethodData": {
        "MethodName": "IsOwnedBy",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public bool IsOwnedBy(global::BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanUseGesture\", player, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif (this.forceUnlock)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnClientDisconnect",
      "HookName": "OnClientDisconnect",
      "HookParameters": {
        "connection": "Connection",
        "text": "string"
      },
      "ReturnBehavior": 0,
      "TargetType": "ServerMgr",
      "Category": "Player",
      "MethodData": {
        "MethodName": "ReadDisconnectReason",
        "ReturnType": "void",
        "Arguments": {
          "packet": "Network.Message"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tstring text = packet.read.String(4096);\r\n\tstring text2 = packet.connection.ToString();\r\n\tif (!string.IsNullOrEmpty(text) && !string.IsNullOrEmpty(text2))\r\n\t{\r\n\t\tInterface.CallHook(\"OnClientDisconnect\", packet.connection, text);\r\n\t\tDebugEx.Log(text2 + \" disconnecting: \" + text, StackTraceLogType.None);\r\n\t}\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnIngredientsCollect",
      "HookName": "OnIngredientsCollect",
      "HookDescription": "Called when ingredients are about to be collected for crafting an item",
      "HookParameters": {
        "instance": "ItemCrafter",
        "bp": "ItemBlueprint",
        "task": "ItemCraftTask",
        "amount": "Int32",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "ItemCrafter",
      "Category": "Crafting",
      "MethodData": {
        "MethodName": "CollectIngredients",
        "ReturnType": "void",
        "Arguments": {
          "bp": "ItemBlueprint",
          "task": "ItemCraftTask",
          "amount": "int",
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "private void CollectIngredients(global::ItemBlueprint bp, global::ItemCraftTask task, int amount = 1, global::BasePlayer player = null)\r\n{\r\n\tif (Interface.CallHook(\"OnIngredientsCollect\", this, bp, task, amount, player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tSystem.Collections.Generic.List<global::Item> list = new System.Collections.Generic.List<global::Item>();\r\n\tforeach (global::ItemAmount current in bp.ingredients)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRespawnInformationGiven",
      "HookName": "OnRespawnInformationGiven",
      "HookParameters": {
        "instance": "BasePlayer",
        "respawnInformation": "RespawnInformation"
      },
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "SendRespawnOptions",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\tif (this.IsDead())\r\n\t\t{\r\n\t\t\trespawnInformation.previousLife = this.previousLifeStory;\r\n\t\t\trespawnInformation.fadeIn = (this.previousLifeStory != null && (ulong)this.previousLifeStory.timeDied > (ulong)((long)(Epoch.Current - 5)));\r\n\t\t}\r\n\t\tInterface.CallHook(\"OnRespawnInformationGiven\", this, respawnInformation);\r\n\t\tbase.ClientRPCPlayer<RespawnInformation>(null, this, \"OnRespawnInformation\", respawnInformation);\r\n\t}\r\n}\r\n\r\n"
    },
    {
      "Type": 1,
      "Name": "OnCentralizedBanCheck",
      "HookName": "OnCentralizedBanCheck",
      "ReturnBehavior": 0,
      "TargetType": "Auth_CentralizedBans/<Run>d__0",
      "Category": "Player",
      "MethodData": {
        "MethodName": "MoveNext",
        "ReturnType": "bool",
        "Arguments": {}
      },
      "CodeAfterInjection": "bool System.Collections.IEnumerator.MoveNext()\r\n{\r\n\tobject OxideGen_3 = Interface.CallHook(\"OnCentralizedBanCheck\", this.connection);\r\n\tif (OxideGen_3 != null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tswitch (this.<>1__state)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnClientCommand",
      "HookName": "OnClientCommand",
      "HookParameters": {
        "connection": "Connection",
        "text": "string"
      },
      "ReturnBehavior": 1,
      "TargetType": "ConsoleNetwork",
      "Category": "Player",
      "MethodData": {
        "MethodName": "OnClientCommand",
        "ReturnType": "void",
        "Arguments": {
          "packet": "Network.Message"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (packet.connection == null || !packet.connection.connected)\r\n\t{\r\n\t\tDebug.LogWarning(\"Client without connection tried to run command: \" + text);\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnClientCommand\", packet.connection, text) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tstring text2 = ConsoleSystem.Run(ConsoleSystem.Option.Server.FromConnection(packet.connection).Quiet(), text, System.Array.Empty<object>());\r\n\tif (!string.IsNullOrEmpty(text2))\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSleepingBagValidCheck",
      "HookName": "OnSleepingBagValidCheck",
      "HookDescription": "Called when determining if a sleeping bag is a valid respawn location for a player\r\nUseful in conjunction with OnRespawnInformationGiven since a custom sleeping bag will need to pass this check",
      "HookParameters": {
        "instance": "SleepingBag",
        "playerID": "ulong",
        "ignoreTimers": "bool"
      },
      "ReturnBehavior": 1,
      "TargetType": "SleepingBag",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "ValidForPlayer",
        "ReturnType": "bool",
        "Arguments": {
          "playerID": "ulong",
          "ignoreTimers": "bool"
        }
      },
      "CodeAfterInjection": "public virtual bool ValidForPlayer(ulong playerID, bool ignoreTimers)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"OnSleepingBagValidCheck\", this, playerID, ignoreTimers);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn this.deployerUserID == playerID && (ignoreTimers || this.unlockTime < Time.realtimeSinceStartup);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCupboardAuthorize [ItemModDeployable]",
      "HookName": "OnCupboardAuthorize",
      "HookParameters": {
        "buildingPrivlidge": "BuildingPrivlidge",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "ItemModDeployable",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "OnDeployed",
        "ReturnType": "void",
        "Arguments": {
          "ent": "BaseEntity",
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "...\r\n\t\tplayer.GiveAchievement(this.UnlockAchievement);\r\n\t}\r\n\tglobal::BuildingPrivlidge buildingPrivlidge;\r\n\tif ((buildingPrivlidge = (ent as global::BuildingPrivlidge)) != null)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnCupboardAuthorize\", buildingPrivlidge, player) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tbuildingPrivlidge.AddPlayer(player);\r\n\t}\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "FixAIBrainTryThinkNRE [patch]",
      "HookName": "FixAIBrainTryThinkNRE [patch]",
      "ReturnBehavior": 0,
      "TargetType": "BaseAnimalNPC",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "TryThink",
        "ReturnType": "void",
        "Arguments": {}
      }
    },
    {
      "Type": 1,
      "Name": "OnNpcTarget [AIBrainSenses]",
      "HookName": "OnNpcTarget",
      "ReturnBehavior": 0,
      "TargetType": "AIBrainSenses",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "GetNearest",
        "ReturnType": "BaseEntity",
        "Arguments": {
          "entities": "System.Collections.Generic.List`1<BaseEntity>",
          "rangeFraction": "float"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tfloat num = float.PositiveInfinity;\r\n\tglobal::BaseEntity result = null;\r\n\tforeach (global::BaseEntity current in entities)\r\n\t{\r\n\t\tif (!(current == null) && current.Health() > 0f && Interface.CallHook(\"OnNpcTarget\", this.owner, current) == null)\r\n\t\t{\r\n\t\t\tfloat num2 = Vector3.Distance(current.transform.position, this.owner.transform.position);\r\n\t\t\tif (num2 <= rangeFraction * this.maxRange && num2 < num)\r\n\t\t\t{\r\n\t\t\t\tresult = current;\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "ContinueTargetScan [patch]",
      "HookName": "ContinueTargetScan [patch]",
      "ReturnBehavior": 0,
      "TargetType": "AutoTurret",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "TargetScan",
        "ReturnType": "void",
        "Arguments": {}
      }
    },
    {
      "Type": 1,
      "Name": "LimitNetworkingAcquaintances [patch]",
      "HookName": "LimitNetworkingAcquaintances [patch]",
      "ReturnBehavior": 0,
      "TargetType": "RelationshipManager",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "UpdateAcquaintancesFor",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer",
          "deltaSeconds": "float"
        }
      }
    },
    {
      "Type": 0,
      "Name": "OnWaterCollect [WaterCatcher]",
      "HookName": "OnWaterCollect",
      "HookDescription": "Called when a water catcher is about to collect water",
      "HookParameters": {
        "instance": "WaterCatcher"
      },
      "ReturnBehavior": 1,
      "TargetType": "WaterCatcher",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "CollectWater",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (this.IsFull())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnWaterCollect\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat num = 0.25f;\r\n\tnum += global::Climate.GetFog(base.transform.position) * 2f;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnLiquidVesselFill",
      "HookName": "OnLiquidVesselFill",
      "HookDescription": "Called when a player is attempting to fill a liquid vessel",
      "HookParameters": {
        "instance": "BaseLiquidVessel",
        "ownerPlayer": "BasePlayer",
        "facingLiquidContainer": "LiquidContainer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseLiquidVessel",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "FillCheck",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\treturn;\r\n\t}\r\n\tfloat f = (Time.realtimeSinceStartup - this.lastFillTime) * this.fillMlPerSec;\r\n\tVector3 pos = ownerPlayer.transform.position - new Vector3(0f, 1f, 0f);\r\n\tglobal::LiquidContainer facingLiquidContainer = this.GetFacingLiquidContainer();\r\n\tif (Interface.CallHook(\"OnLiquidVesselFill\", this, ownerPlayer, facingLiquidContainer) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (facingLiquidContainer == null && this.CanFillFromWorld())\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCCTVDirectionChange",
      "HookName": "OnCCTVDirectionChange",
      "HookDescription": "Called when a player attempts to change the direction of a CCTV camera to face them",
      "HookParameters": {
        "instance": "CCTV_RC",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "CCTV_RC",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "Server_SetDir",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tglobal::BasePlayer player = msg.player;\r\n\tif (!player.CanBuild() || !player.IsBuildingAuthed())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnCCTVDirectionChange\", this, player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tVector3 vector = Vector3Ex.Direction(player.eyes.position, this.yaw.transform.position);\r\n\tvector = base.transform.InverseTransformDirection(vector);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanSetRelationship",
      "HookName": "CanSetRelationship",
      "HookParameters": {
        "player": "BasePlayer",
        "otherPlayer": "BasePlayer",
        "type": "RelationshipType",
        "weight": "int"
      },
      "ReturnBehavior": 1,
      "TargetType": "RelationshipManager",
      "Category": "Player",
      "MethodData": {
        "MethodName": "SetRelationship",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer",
          "otherPlayer": "BasePlayer",
          "type": "RelationshipManager/RelationshipType",
          "weight": "int",
          "sendImmediate": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (otherPlayer != null && otherPlayer.IsNpc)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanSetRelationship\", player, otherPlayer, type, weight) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::RelationshipManager.PlayerRelationships playerRelationships = this.GetRelationships(userID);\r\n\tif (!this.CleanupOldContacts(playerRelationships, userID, global::RelationshipManager.RelationshipType.Acquaintance))\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerRecover",
      "HookName": "OnPlayerRecover",
      "HookParameters": {
        "instance": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RecoverFromWounded",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "private void RecoverFromWounded()\r\n{\r\n\tif (Interface.CallHook(\"OnPlayerRecover\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.IsCrawling())\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerWound",
      "HookName": "OnPlayerWound",
      "HookParameters": {
        "instance": "BasePlayer",
        "info": "HitInfo"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "BecomeWounded",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (this.IsWounded())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnPlayerWound\", this, info) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbool flag = info != null && info.damageTypes.GetMajorityDamageType() == Rust.DamageType.Fall;\r\n\tif (this.IsCrawling())\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerRecovered",
      "HookName": "OnPlayerRecovered",
      "HookParameters": {
        "instance": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RecoverFromWounded",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "private void RecoverFromWounded()\r\n{\r\n\tif (Interface.CallHook(\"OnPlayerRecover\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.IsCrawling())\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "IncapacitatedFalseRespawn [patch]",
      "HookName": "IncapacitatedFalseRespawn [patch]",
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "RespawnAt",
        "ReturnType": "void",
        "Arguments": {
          "position": "UnityEngine.Vector3",
          "rotation": "UnityEngine.Quaternion",
          "spawnPointEntity": "BaseEntity"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (this.net != null)\r\n\t{\r\n\t\tglobal::EACServer.OnStartLoading(this.net.connection);\r\n\t}\r\n\tInterface.CallHook(\"OnPlayerRespawned\", this);\r\n}\r\n\r\n"
    },
    {
      "Type": 1,
      "Name": "FixAIBrainThinkNRE [patch]",
      "HookName": "FixAIBrainThinkNRE [patch]",
      "ReturnBehavior": 0,
      "TargetType": "BaseAIBrain",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "Think",
        "ReturnType": "void",
        "Arguments": {
          "delta": "float"
        }
      }
    },
    {
      "Type": 0,
      "Name": "OnPlayerDismountFailed",
      "HookName": "OnPlayerDismountFailed",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "BaseMountable"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseMountable",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RPC_WantsDismount",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\npublic void RPC_WantsDismount(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tglobal::BasePlayer player = msg.player;\r\n\tif (!this.HasValidDismountPosition(player))\r\n\t{\r\n\t\tInterface.CallHook(\"OnPlayerDismountFailed\", player, this);\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnPlayerWantsDismount\", player, this) != null)\r\n\t{\r\n\t\treturn;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanAccessVendingMachine",
      "HookName": "CanAccessVendingMachine",
      "HookParameters": {
        "config": "DeliveryDroneConfig",
        "vendingMachine": "VendingMachine"
      },
      "ReturnBehavior": 1,
      "TargetType": "MarketTerminal",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "<GetDeliveryEligibleVendingMachines>g__IsEligible|24_0",
        "ReturnType": "bool",
        "Arguments": {
          "vendingMachine": "VendingMachine",
          "offset": "UnityEngine.Vector3",
          "n": "int"
        }
      },
      "CodeAfterInjection": "[System.Runtime.CompilerServices.CompilerGenerated]\r\nprivate bool <GetDeliveryEligibleVendingMachines>g__IsEligible|24_0(global::VendingMachine vendingMachine, Vector3 offset, int n)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanAccessVendingMachine\", this.config, vendingMachine);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tRaycastHit raycastHit;\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "ConsumptionAmountField [AutoTurret]",
      "HookName": "ConsumptionAmountField [AutoTurret]",
      "ReturnBehavior": 0,
      "TargetType": "AutoTurret",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "ConsumptionAmount",
        "ReturnType": "int",
        "Arguments": {}
      }
    },
    {
      "Type": 1,
      "Name": "ConsumptionAmountField [AutoTurret]",
      "HookName": "ConsumptionAmountField [AutoTurret]",
      "ReturnBehavior": 0,
      "TargetType": "AutoTurret",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": ".ctor",
        "ReturnType": "void",
        "Arguments": {}
      }
    },
    {
      "Type": 0,
      "Name": "OnDecayHeal",
      "HookName": "OnDecayHeal",
      "HookDescription": "Called when a entity heals from upkeep",
      "HookParameters": {
        "instance": "DecayEntity"
      },
      "ReturnBehavior": 1,
      "TargetType": "DecayEntity",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "DecayTick",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\t}\r\n\t\tif (this.upkeepTimer < 1f)\r\n\t\t{\r\n\t\t\tif (base.healthFraction < 1f && ConVar.Decay.upkeep_heal_scale > 0f && base.SecondsSinceAttacked > 600f)\r\n\t\t\t{\r\n\t\t\t\tif (Interface.CallHook(\"OnDecayHeal\", this) != null)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tfloat num3 = num / this.decay.GetDecayDuration(this) * ConVar.Decay.upkeep_heal_scale;\r\n\t\t\t\tthis.Heal(this.MaxHealth() * num3);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnDecayDamage",
      "HookName": "OnDecayDamage",
      "HookDescription": "Called when a entity takes damage from decaying",
      "HookParameters": {
        "instance": "DecayEntity"
      },
      "ReturnBehavior": 1,
      "TargetType": "DecayEntity",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "DecayTick",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\t}\r\n\t\tif (this.upkeepTimer < 1f)\r\n\t\t{\r\n\t\t\tif (base.healthFraction < 1f && ConVar.Decay.upkeep_heal_scale > 0f && base.SecondsSinceAttacked > 600f)\r\n\t\t\t{\r\n\t\t\t\tif (Interface.CallHook(\"OnDecayHeal\", this) != null)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tfloat num3 = num / this.decay.GetDecayDuration(this) * ConVar.Decay.upkeep_heal_scale;\r\n\t\t\t\tthis.Heal(this.MaxHealth() * num3);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnWindmillUpdate",
      "HookName": "OnWindmillUpdate",
      "HookDescription": "Called when a Windmill updates it's energy output",
      "HookParameters": {
        "instance": "ElectricWindmill"
      },
      "ReturnBehavior": 1,
      "TargetType": "ElectricWindmill",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "WindUpdate",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void WindUpdate()\r\n{\r\n\tif (Interface.CallHook(\"OnWindmillUpdate\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.serverWindSpeed = this.GetWindSpeedScale();\r\n\tif (!this.AmIVisible())\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnWindmillUpdated",
      "HookName": "OnWindmillUpdated",
      "HookDescription": "Called after a Windmill updates it's energy output",
      "HookParameters": {
        "instance": "ElectricWindmill"
      },
      "ReturnBehavior": 0,
      "TargetType": "ElectricWindmill",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "WindUpdate",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void WindUpdate()\r\n{\r\n\tif (Interface.CallHook(\"OnWindmillUpdate\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.serverWindSpeed = this.GetWindSpeedScale();\r\n\tif (!this.AmIVisible())\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanElevatorLiftMove",
      "HookName": "CanElevatorLiftMove",
      "HookDescription": "Called when an elevator lift attempts to move between levels",
      "HookParameters": {
        "instance": "ElevatorLift"
      },
      "ReturnBehavior": 1,
      "TargetType": "ElevatorLift",
      "Category": "Elevator",
      "MethodData": {
        "MethodName": "CanMove",
        "ReturnType": "bool",
        "Arguments": {}
      },
      "CodeAfterInjection": "public bool CanMove()\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanElevatorLiftMove\", this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif (this.VehicleTrigger.HasContents && this.VehicleTrigger.entityContents != null)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnGrowableStateChange",
      "HookName": "OnGrowableStateChange",
      "HookParameters": {
        "instance": "GrowableEntity",
        "state": "State"
      },
      "ReturnBehavior": 1,
      "TargetType": "GrowableEntity",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "ChangeState",
        "ReturnType": "void",
        "Arguments": {
          "state": "PlantProperties/State",
          "resetAge": "bool",
          "loading": "bool"
        }
      },
      "CodeAfterInjection": "private void ChangeState(global::PlantProperties.State state, bool resetAge, bool loading = false)\r\n{\r\n\tif (Interface.CallHook(\"OnGrowableStateChange\", this, state) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (base.isServer && this.State == state)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanBeRecycled",
      "HookName": "CanBeRecycled",
      "HookDescription": "Called when a recycler attempts to recycle an item",
      "HookParameters": {
        "item": "Item",
        "instance": "Recycler"
      },
      "ReturnBehavior": 1,
      "TargetType": "Recycler",
      "Category": "Crafting",
      "MethodData": {
        "MethodName": "CanBeRecycled",
        "ReturnType": "bool",
        "Arguments": {
          "item": "Item"
        }
      },
      "CodeAfterInjection": "private bool CanBeRecycled(global::Item item)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanBeRecycled\", item, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn item != null && item.info.Blueprint != null;\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnBigWheelLoss",
      "HookName": "OnBigWheelLoss",
      "HookDescription": "Called when a specific item is lost on the big wheel game",
      "ReturnBehavior": 0,
      "TargetType": "BigWheelGame",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "Payout",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\t\tglobal::Item slot = current.inventory.GetSlot((int)currentHitType.hitType);\r\n\t\t\tif (slot != null)\r\n\t\t\t{\r\n\t\t\t\tint num = currentHitType.ColorToMultiplier(currentHitType.hitType);\r\n\t\t\t\tint amount = slot.amount;\r\n\t\t\t\tif (Interface.CallHook(\"OnBigWheelWin\", this, slot, current, num) == null)\r\n\t\t\t\t{\r\n\t\t\t\t\tslot.amount += slot.amount * num;\r\n\t\t\t\t\tslot.RemoveFromContainer();\r\n\t\t\t\t\tslot.MoveToContainer(current.inventory, 5, true, false, null, true);\r\n\t\t\t\t\tflag = true;\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnBigWheelWin",
      "HookName": "OnBigWheelWin",
      "HookDescription": "Called when BigWheel attempts to apply winning multiplier to item",
      "ReturnBehavior": 0,
      "TargetType": "BigWheelGame",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "Payout",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\t\tglobal::Item slot = current.inventory.GetSlot((int)currentHitType.hitType);\r\n\t\t\tif (slot != null)\r\n\t\t\t{\r\n\t\t\t\tint num = currentHitType.ColorToMultiplier(currentHitType.hitType);\r\n\t\t\t\tint amount = slot.amount;\r\n\t\t\t\tif (Interface.CallHook(\"OnBigWheelWin\", this, slot, current, num) == null)\r\n\t\t\t\t{\r\n\t\t\t\t\tslot.amount += slot.amount * num;\r\n\t\t\t\t\tslot.RemoveFromContainer();\r\n\t\t\t\t\tslot.MoveToContainer(current.inventory, 5, true, false, null, true);\r\n\t\t\t\t\tflag = true;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityPickedUp",
      "HookName": "OnEntityPickedUp",
      "HookDescription": "Called when an entity is picked up by a player",
      "HookParameters": {
        "instance": "BaseCombatEntity",
        "createdItem": "Item",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseCombatEntity",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "OnPickedUp",
        "ReturnType": "void",
        "Arguments": {
          "createdItem": "Item",
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public virtual void OnPickedUp(global::Item createdItem, global::BasePlayer player)\r\n{\r\n\tInterface.CallHook(\"OnEntityPickedUp\", this, createdItem, player);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnServerRestartInterrupt",
      "HookName": "OnServerRestartInterrupt",
      "HookParameters": {},
      "ReturnBehavior": 1,
      "TargetType": "ServerMgr",
      "Category": "Server",
      "MethodData": {
        "MethodName": "RestartServer",
        "ReturnType": "void",
        "Arguments": {
          "strNotice": "string",
          "iSeconds": "int"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (SingletonComponent<global::ServerMgr>.Instance.restartCoroutine != null)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnServerRestartInterrupt\") != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tglobal::ConsoleNetwork.BroadcastToAllClients(\"chat.add\", new object[]\r\n\t\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnServerRestart",
      "HookName": "OnServerRestart",
      "HookParameters": {
        "strNotice": "string",
        "iSeconds": "int"
      },
      "ReturnBehavior": 1,
      "TargetType": "ServerMgr",
      "Category": "Server",
      "MethodData": {
        "MethodName": "RestartServer",
        "ReturnType": "void",
        "Arguments": {
          "strNotice": "string",
          "iSeconds": "int"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (SingletonComponent<global::ServerMgr>.Instance.restartCoroutine != null)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnServerRestartInterrupt\") != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tglobal::ConsoleNetwork.BroadcastToAllClients(\"chat.add\", new object[]\r\n\t\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanUseHelicopter",
      "HookName": "CanUseHelicopter",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "CH47HelicopterAIController"
      },
      "ReturnBehavior": 1,
      "TargetType": "CH47HelicopterAIController",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "AttemptMount",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer",
          "doMountChecks": "bool"
        }
      },
      "CodeAfterInjection": "public override void AttemptMount(global::BasePlayer player, bool doMountChecks = true)\r\n{\r\n\tif (Interface.CallHook(\"CanUseHelicopter\", player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.AttemptMount(player, doMountChecks);\r\n}\r\n"
    },
    {
      "Type": 1,
      "Name": "AllowNpcNonAdminHeliUse [patch]",
      "HookName": "AllowNpcNonAdminHeliUse [patch]",
      "ReturnBehavior": 0,
      "TargetType": "CH47HelicopterAIController",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "AttemptMount",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer",
          "doMountChecks": "bool"
        }
      },
      "CodeAfterInjection": "public override void AttemptMount(global::BasePlayer player, bool doMountChecks = true)\r\n{\r\n\tif (Interface.CallHook(\"CanUseHelicopter\", player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.AttemptMount(player, doMountChecks);\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnWildlifeTrap",
      "HookName": "OnWildlifeTrap",
      "HookParameters": {
        "instance": "WildlifeTrap",
        "trapped": "TrappableWildlife"
      },
      "ReturnBehavior": 1,
      "TargetType": "WildlifeTrap",
      "Category": "Traps",
      "MethodData": {
        "MethodName": "TrapWildlife",
        "ReturnType": "void",
        "Arguments": {
          "trapped": "TrappableWildlife"
        }
      },
      "CodeAfterInjection": "public void TrapWildlife(global::TrappableWildlife trapped)\r\n{\r\n\tif (Interface.CallHook(\"OnWildlifeTrap\", this, trapped) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::Item item = global::ItemManager.Create(trapped.inventoryObject, UnityEngine.Random.Range(trapped.minToCatch, trapped.maxToCatch + 1), 0uL);\r\n\tif (!item.MoveToContainer(base.inventory, -1, true, false, null, true))\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFishingStopped",
      "HookName": "OnFishingStopped",
      "HookParameters": {
        "instance": "BaseFishingRod",
        "reason": "FailReason"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseFishingRod",
      "Category": "Fishing",
      "MethodData": {
        "MethodName": "Server_Cancel",
        "ReturnType": "void",
        "Arguments": {
          "reason": "BaseFishingRod/FailReason"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\tfishingBobber.Kill(global::BaseNetworkable.DestroyMode.None);\r\n\t\tthis.currentBobber.Set(null);\r\n\t}\r\n\tbase.ClientRPC<int>(null, \"Client_ResetLine\", (int)reason);\r\n\tInterface.CallHook(\"OnFishingStopped\", this, reason);\r\n}\r\n\r\n"
    },
    {
      "Type": 1,
      "Name": "CanCastFishingRod",
      "HookName": "CanCastFishingRod",
      "ReturnBehavior": 0,
      "TargetType": "BaseFishingRod",
      "Category": "Fishing",
      "MethodData": {
        "MethodName": "Server_RequestCast",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (!this.EvaluateFishingPosition(ref vector, ownerPlayer, out reason, out this.surfaceBody))\r\n\t{\r\n\t\tthis.FailedCast(reason);\r\n\t\treturn;\r\n\t}\r\n\tobject OxideGen_7 = Interface.CallHook(\"CanCastFishingRod\", ownerPlayer, this, currentLure, vector);\r\n\tif (OxideGen_7 is bool && !(bool)OxideGen_7)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::FishingBobber component = base.gameManager.CreateEntity(this.FishingBobberRef.resourcePath, base.transform.position + Vector3.up * 2.8f + ownerPlayer.eyes.BodyForward() * 1.8f, base.GetOwnerPlayer().ServerRotation, true).GetComponent<global::FishingBobber>();\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "CanCatchFish",
      "HookName": "CanCatchFish",
      "ReturnBehavior": 0,
      "TargetType": "BaseFishingRod",
      "Category": "Fishing",
      "MethodData": {
        "MethodName": "CatchProcessBudgeted",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\tthis.CurrentState = global::BaseFishingRod.CatchState.Caught;\r\n\t\tif (this.currentFishTarget != null)\r\n\t\t{\r\n\t\t\tglobal::Item item = global::ItemManager.Create(this.currentFishTarget, 1, 0uL);\r\n\t\t\tobject OxideGen_14 = Interface.CallHook(\"CanCatchFish\", ownerPlayer, this, item);\r\n\t\t\tif (OxideGen_14 is bool && !(bool)OxideGen_14)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tobject OxideGen_15 = Interface.CallHook(\"OnFishCatch\", item, this, ownerPlayer);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFishingRodCast",
      "HookName": "OnFishingRodCast",
      "HookParameters": {
        "instance": "BaseFishingRod",
        "ownerPlayer": "BasePlayer",
        "currentLure": "Item"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseFishingRod",
      "Category": "Fishing",
      "MethodData": {
        "MethodName": "Server_RequestCast",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (!this.EvaluateFishingPosition(ref vector, ownerPlayer, out reason, out this.surfaceBody))\r\n\t{\r\n\t\tthis.FailedCast(reason);\r\n\t\treturn;\r\n\t}\r\n\tobject OxideGen_7 = Interface.CallHook(\"CanCastFishingRod\", ownerPlayer, this, currentLure, vector);\r\n\tif (OxideGen_7 is bool && !(bool)OxideGen_7)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::FishingBobber component = base.gameManager.CreateEntity(this.FishingBobberRef.resourcePath, base.transform.position + Vector3.up * 2.8f + ownerPlayer.eyes.BodyForward() * 1.8f, base.GetOwnerPlayer().ServerRotation, true).GetComponent<global::FishingBobber>();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTurretAuthorize",
      "HookName": "OnTurretAuthorize",
      "HookParameters": {
        "instance": "AutoTurret",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "AutoTurret",
      "Category": "Turret",
      "MethodData": {
        "MethodName": "AddSelfAuthorize",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (this.AtMaxAuthCapacity())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnTurretAuthorize\", this, player2) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.authorizedPlayers.RemoveAll((PlayerNameID x) => x.userid == player.userID);\r\n\tPlayerNameID playerNameID = new PlayerNameID();\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnFishCatch",
      "HookName": "OnFishCatch",
      "ReturnBehavior": 0,
      "TargetType": "BaseFishingRod",
      "Category": "Fishing",
      "MethodData": {
        "MethodName": "CatchProcessBudgeted",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\tthis.CurrentState = global::BaseFishingRod.CatchState.Caught;\r\n\t\tif (this.currentFishTarget != null)\r\n\t\t{\r\n\t\t\tglobal::Item item = global::ItemManager.Create(this.currentFishTarget, 1, 0uL);\r\n\t\t\tobject OxideGen_14 = Interface.CallHook(\"CanCatchFish\", ownerPlayer, this, item);\r\n\t\t\tif (OxideGen_14 is bool && !(bool)OxideGen_14)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tobject OxideGen_15 = Interface.CallHook(\"OnFishCatch\", item, this, ownerPlayer);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFishCaught",
      "HookName": "OnFishCaught",
      "HookParameters": {
        "currentFishTarget": "ItemDefinition",
        "instance": "BaseFishingRod",
        "ownerPlayer": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseFishingRod",
      "Category": "Fishing",
      "MethodData": {
        "MethodName": "CatchProcessBudgeted",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\tthis.CurrentState = global::BaseFishingRod.CatchState.Caught;\r\n\t\tif (this.currentFishTarget != null)\r\n\t\t{\r\n\t\t\tglobal::Item item = global::ItemManager.Create(this.currentFishTarget, 1, 0uL);\r\n\t\t\tobject OxideGen_14 = Interface.CallHook(\"CanCatchFish\", ownerPlayer, this, item);\r\n\t\t\tif (OxideGen_14 is bool && !(bool)OxideGen_14)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tobject OxideGen_15 = Interface.CallHook(\"OnFishCatch\", item, this, ownerPlayer);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerDrink",
      "HookName": "OnPlayerDrink",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "LiquidContainer"
      },
      "ReturnBehavior": 1,
      "TargetType": "LiquidContainer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "SVDrink",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (!rpc.player.metabolism.CanConsume())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnPlayerDrink\", rpc.player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tforeach (global::Item current in base.inventory.itemList)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanPurchaseItem",
      "HookName": "CanPurchaseItem",
      "HookParameters": {
        "buyer": "BasePlayer",
        "num3": "Item",
        "onItemPurchased": "Action`2",
        "instance": "VendingMachine",
        "targetContainer": "ItemContainer"
      },
      "ReturnBehavior": 1,
      "TargetType": "VendingMachine",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "DoTransaction",
        "ReturnType": "bool",
        "Arguments": {
          "buyer": "BasePlayer",
          "sellOrderId": "int",
          "numberOfTransactions": "int",
          "targetContainer": "ItemContainer",
          "onCurrencyRemoved": "System.Action`2<BasePlayer,Item>",
          "onItemPurchased": "System.Action`2<BasePlayer,Item>",
          "droneMarketTerminal": "MarketTerminal"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (targetContainer == null && Vector3.Distance(buyer.transform.position, base.transform.position) > 4f)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"OnVendingTransaction\", this, buyer, sellOrderId, numberOfTransactions, targetContainer);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tProtoBuf.VendingMachine.SellOrder sellOrder = this.sellOrders.sellOrders[sellOrderId];\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnVendingShopOpen [NPCTalking]",
      "HookName": "OnVendingShopOpen",
      "HookParameters": {
        "itemDefinition": "InvisibleVendingMachine",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "NPCTalking",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "OnConversationAction",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer",
          "action": "string"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\tglobal::InvisibleVendingMachine vendingMachine = base.GetVendingMachine();\r\n\t\tif (vendingMachine != null && Vector3.Distance(player.transform.position, base.transform.position) < 5f)\r\n\t\t{\r\n\t\t\tthis.ForceEndConversation(player);\r\n\t\t\tif (Interface.CallHook(\"OnVendingShopOpen\", vendingMachine, player) != null)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvendingMachine.PlayerOpenLoot(player, \"vendingmachine.customer\", false);\r\n\t\t\tInterface.CallHook(\"OnVendingShopOpened\", vendingMachine, player);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnLootEntityEnd [FuseBox]",
      "HookName": "OnLootEntityEnd",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "ItemBasedFlowRestrictor"
      },
      "ReturnBehavior": 0,
      "TargetType": "ItemBasedFlowRestrictor",
      "Category": "Player",
      "MethodData": {
        "MethodName": "PlayerStoppedLooting",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public void PlayerStoppedLooting(global::BasePlayer player)\r\n{\r\n\tInterface.CallHook(\"OnLootEntityEnd\", player, this);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTurretAssign",
      "HookName": "OnTurretAssign",
      "HookParameters": {
        "instance": "AutoTurret",
        "num": "ulong",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "AutoTurret",
      "Category": "Turret",
      "MethodData": {
        "MethodName": "AssignToFriend",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tulong num = msg.read.UInt64();\r\n\tif (num == 0uL || this.IsAuthed(num))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnTurretAssign\", this, num, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tstring username = global::BasePlayer.SanitizePlayerNameString(msg.read.String(256), num);\r\n\tPlayerNameID playerNameID = new PlayerNameID();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTurretAssigned",
      "HookName": "OnTurretAssigned",
      "HookParameters": {
        "instance": "AutoTurret",
        "num": "ulong",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "AutoTurret",
      "Category": "Turret",
      "MethodData": {
        "MethodName": "AssignToFriend",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tulong num = msg.read.UInt64();\r\n\tif (num == 0uL || this.IsAuthed(num))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnTurretAssign\", this, num, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tstring username = global::BasePlayer.SanitizePlayerNameString(msg.read.String(256), num);\r\n\tPlayerNameID playerNameID = new PlayerNameID();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMissionFailed",
      "HookName": "OnMissionFailed",
      "HookParameters": {
        "instance": "BaseMission",
        "missionInstance": "MissionInstance",
        "assignee": "BasePlayer",
        "failReason": "MissionFailReason"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseMission",
      "Category": "Mission",
      "MethodData": {
        "MethodName": "MissionFailed",
        "ReturnType": "void",
        "Arguments": {
          "instance": "BaseMission/MissionInstance",
          "assignee": "BasePlayer",
          "failReason": "BaseMission/MissionFailReason"
        }
      },
      "CodeAfterInjection": "...\r\n\tglobal::BaseMission.DoMissionEffect(this.failedEffect.resourcePath, assignee);\r\n\tFacepunch.Rust.Analytics.Server.MissionFailed(this, failReason);\r\n\tFacepunch.Rust.Analytics.Azure.OnMissionComplete(assignee, this, new global::BaseMission.MissionFailReason?(failReason));\r\n\tinstance.status = global::BaseMission.MissionStatus.Failed;\r\n\tthis.MissionEnded(instance, assignee);\r\n\tInterface.CallHook(\"OnMissionFailed\", this, instance, assignee, failReason);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMissionSucceeded",
      "HookName": "OnMissionSucceeded",
      "HookParameters": {
        "instance": "BaseMission",
        "missionInstance": "MissionInstance",
        "assignee": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseMission",
      "Category": "Mission",
      "MethodData": {
        "MethodName": "MissionSuccess",
        "ReturnType": "void",
        "Arguments": {
          "instance": "BaseMission/MissionInstance",
          "assignee": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public virtual void MissionSuccess(global::BaseMission.MissionInstance instance, global::BasePlayer assignee)\r\n{\r\n\tinstance.status = global::BaseMission.MissionStatus.Accomplished;\r\n\tthis.MissionEnded(instance, assignee);\r\n\tthis.MissionComplete(instance, assignee);\r\n\tInterface.CallHook(\"OnMissionSucceeded\", this, instance, assignee);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMissionStart",
      "HookName": "OnMissionStart",
      "HookParameters": {
        "instance": "BaseMission",
        "missionInstance": "MissionInstance",
        "assignee": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseMission",
      "Category": "Mission",
      "MethodData": {
        "MethodName": "MissionStart",
        "ReturnType": "void",
        "Arguments": {
          "instance": "BaseMission/MissionInstance",
          "assignee": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public virtual void MissionStart(global::BaseMission.MissionInstance instance, global::BasePlayer assignee)\r\n{\r\n\tif (Interface.CallHook(\"OnMissionStart\", this, instance, assignee) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.SetupRewards(instance, assignee);\r\n\tthis.SetupPositions(instance, assignee);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanAssignMission",
      "HookName": "CanAssignMission",
      "HookParameters": {
        "assignee": "BasePlayer",
        "mission": "BaseMission",
        "provider": "IMissionProvider"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseMission",
      "Category": "Mission",
      "MethodData": {
        "MethodName": "AssignMission",
        "ReturnType": "bool",
        "Arguments": {
          "assignee": "BasePlayer",
          "provider": "IMissionProvider",
          "mission": "BaseMission"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (!mission.IsEligableForMission(assignee, provider))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"CanAssignMission\", assignee, mission, provider);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tglobal::BaseMission.MissionInstance missionInstance = Pool.Get<global::BaseMission.MissionInstance>();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMissionAssigned",
      "HookName": "OnMissionAssigned",
      "HookParameters": {
        "mission": "BaseMission",
        "provider": "IMissionProvider",
        "assignee": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseMission",
      "Category": "Mission",
      "MethodData": {
        "MethodName": "AssignMission",
        "ReturnType": "bool",
        "Arguments": {
          "assignee": "BasePlayer",
          "provider": "IMissionProvider",
          "mission": "BaseMission"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (!mission.IsEligableForMission(assignee, provider))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"CanAssignMission\", assignee, mission, provider);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tglobal::BaseMission.MissionInstance missionInstance = Pool.Get<global::BaseMission.MissionInstance>();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMissionStarted",
      "HookName": "OnMissionStarted",
      "HookParameters": {
        "instance": "BaseMission",
        "missionInstance": "MissionInstance",
        "assignee": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseMission",
      "Category": "Mission",
      "MethodData": {
        "MethodName": "MissionStart",
        "ReturnType": "void",
        "Arguments": {
          "instance": "BaseMission/MissionInstance",
          "assignee": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public virtual void MissionStart(global::BaseMission.MissionInstance instance, global::BasePlayer assignee)\r\n{\r\n\tif (Interface.CallHook(\"OnMissionStart\", this, instance, assignee) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.SetupRewards(instance, assignee);\r\n\tthis.SetupPositions(instance, assignee);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanUpdateSign [CarvablePumpkin]",
      "HookName": "CanUpdateSign",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "CarvablePumpkin"
      },
      "ReturnBehavior": 1,
      "TargetType": "CarvablePumpkin",
      "Category": "Player",
      "MethodData": {
        "MethodName": "CanUpdateSign",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public virtual bool CanUpdateSign(global::BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanUpdateSign\", player, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn player.IsAdmin || player.IsDeveloper || (player.CanBuild() && (!base.IsLocked() || player.userID == base.OwnerID));\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnWaterCollect [WaterPump]",
      "HookName": "OnWaterCollect",
      "HookDescription": "Called when a water pump is about to collect water",
      "HookParameters": {
        "instance": "WaterPump",
        "atPoint": "ItemDefinition"
      },
      "ReturnBehavior": 1,
      "TargetType": "WaterPump",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "CreateWater",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\treturn;\r\n\t}\r\n\tglobal::ItemDefinition atPoint = global::WaterResource.GetAtPoint(this.WaterResourceLocation.position);\r\n\tif (atPoint != null)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnWaterCollect\", this, atPoint) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tbase.inventory.AddItem(atPoint, this.AmountPerPump, 0uL, global::ItemContainer.LimitStack.Existing);\r\n\t\tbase.UpdateOnFlag();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFlameExplosion",
      "HookName": "OnFlameExplosion",
      "HookParameters": {
        "instance": "FlameExplosive",
        "component": "Collider"
      },
      "ReturnBehavior": 0,
      "TargetType": "FlameExplosive",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "FlameExplode",
        "ReturnType": "void",
        "Arguments": {
          "surfaceNormal": "UnityEngine.Vector3"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t\tfloat num2 = (float)num / this.numToCreate;\r\n\t\t\tVector3 modifiedAimConeDirection = global::AimConeUtil.GetModifiedAimConeDirection(this.spreadAngle * this.spreadCurve.Evaluate(num2), surfaceNormal, true);\r\n\t\t\tbaseEntity.transform.SetPositionAndRotation(position, Quaternion.LookRotation(modifiedAimConeDirection));\r\n\t\t\tbaseEntity.creatorEntity = ((this.creatorEntity == null) ? baseEntity : this.creatorEntity);\r\n\t\t\tbaseEntity.Spawn();\r\n\t\t\tInterface.CallHook(\"OnFlameExplosion\", this, component);\r\n\t\t\tVector3 vector = modifiedAimConeDirection.normalized * UnityEngine.Random.Range(this.minVelocity, this.maxVelocity) * this.velocityCurve.Evaluate(num2 * UnityEngine.Random.Range(1f, 1.1f));\r\n\t\t\tglobal::FireBall component2 = baseEntity.GetComponent<global::FireBall>();\r\n\t\t\tif (component2 != null)\r\n\t\t\t{\r\n\t\t\t\tcomponent2.SetDelayedVelocity(vector);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEyePosValidate",
      "HookName": "OnEyePosValidate",
      "HookParameters": {
        "instance": "AttackEntity",
        "player": "BasePlayer",
        "eyePos": "Vector3"
      },
      "ReturnBehavior": 1,
      "TargetType": "AttackEntity",
      "Category": "Player",
      "MethodData": {
        "MethodName": "ValidateEyePos",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer",
          "eyePos": "UnityEngine.Vector3"
        }
      },
      "CodeAfterInjection": "protected bool ValidateEyePos(global::BasePlayer player, Vector3 eyePos)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"OnEyePosValidate\", this, player, eyePos);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tbool flag = true;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnImpactEffectCreate",
      "HookName": "OnImpactEffectCreate",
      "HookParameters": {
        "info": "HitInfo"
      },
      "ReturnBehavior": 4,
      "TargetType": "Effect/server",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "ImpactEffect",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "public static void ImpactEffect(global::HitInfo info)\r\n{\r\n\tif (Interface.CallHook(\"OnImpactEffectCreate\", info) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (info.InitiatorPlayer && info.InitiatorPlayer.limitNetworking)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnSamSiteTargetScan",
      "HookName": "OnSamSiteTargetScan",
      "ReturnBehavior": 0,
      "TargetType": "SamSite",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "TargetScan",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tif (this.IsDead())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tSystem.Collections.Generic.List<global::SamSite.ISamSiteTarget> list = Pool.GetList<global::SamSite.ISamSiteTarget>();\r\n\tif (Interface.CallHook(\"OnSamSiteTargetScan\", this, list) == null)\r\n\t{\r\n\t\tif (!this.IsInDefenderMode())\r\n\t\t{\r\n\t\t\tthis.<TargetScan>g__AddTargetSet|55_0(list, 32768, global::SamSite.targetTypeVehicle.scanRadius);\r\n\t\t}\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemUnwrap",
      "HookName": "OnItemUnwrap",
      "HookParameters": {
        "item": "Item",
        "player": "BasePlayer",
        "instance": "ItemModUnwrap"
      },
      "ReturnBehavior": 4,
      "TargetType": "ItemModUnwrap",
      "Category": "Item",
      "MethodData": {
        "MethodName": "ServerCommand",
        "ReturnType": "void",
        "Arguments": {
          "item": "Item",
          "command": "string",
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\tif (item.amount <= 0)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (Interface.CallHook(\"OnItemUnwrap\", item, player, this) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\titem.UseItem(1);\r\n\t\tint num = UnityEngine.Random.Range(this.minTries, this.maxTries + 1);\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnSendModelState",
      "HookName": "OnSendModelState",
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "SendModelState",
        "ReturnType": "void",
        "Arguments": {
          "force": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n\tthis.modelState.sleeping = this.IsSleeping();\r\n\tthis.modelState.mounted = this.isMounted;\r\n\tthis.modelState.relaxed = this.IsRelaxed();\r\n\tthis.modelState.onPhone = (this.HasActiveTelephone && !this.activeTelephone.IsMobile);\r\n\tthis.modelState.crawling = this.IsCrawling();\r\n\tif (base.limitNetworking || Interface.CallHook(\"OnSendModelState\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.ClientRPC<ModelState>(null, \"OnModelState\", this.modelState);\r\n}\r\n"
    },
    {
      "Type": 1,
      "Name": "OnEngineStart",
      "HookName": "OnEngineStart",
      "ReturnBehavior": 0,
      "TargetType": "VehicleEngineController`1",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "TryStartEngine",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (!this.CanRunEngine())\r\n\t{\r\n\t\tthis.owner.OnEngineStartFailed();\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnEngineStart\", this.owner, player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.owner.SetFlag(this.engineStartingFlag, true, false, true);\r\n\tthis.owner.SetFlag(global::BaseEntity.Flags.On, false, false, true);\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnEngineStarted",
      "HookName": "OnEngineStarted",
      "ReturnBehavior": 0,
      "TargetType": "VehicleEngineController`1",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "TryStartEngine",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (!this.CanRunEngine())\r\n\t{\r\n\t\tthis.owner.OnEngineStartFailed();\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnEngineStart\", this.owner, player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.owner.SetFlag(this.engineStartingFlag, true, false, true);\r\n\tthis.owner.SetFlag(global::BaseEntity.Flags.On, false, false, true);\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnEngineStop",
      "HookName": "OnEngineStop",
      "ReturnBehavior": 0,
      "TargetType": "VehicleEngineController`1",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "StopEngine",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (this.IsOff)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnEngineStop\", this.owner) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.CancelEngineStart();\r\n\tthis.owner.SetFlag(global::BaseEntity.Flags.On, false, false, true);\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnEngineStopped",
      "HookName": "OnEngineStopped",
      "ReturnBehavior": 0,
      "TargetType": "VehicleEngineController`1",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "StopEngine",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (this.IsOff)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnEngineStop\", this.owner) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.CancelEngineStart();\r\n\tthis.owner.SetFlag(global::BaseEntity.Flags.On, false, false, true);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCorpsePopulate [FrankensteinPet]",
      "HookName": "OnCorpsePopulate",
      "HookParameters": {
        "instance": "FrankensteinPet",
        "nPCPlayerCorpse": "NPCPlayerCorpse"
      },
      "ReturnBehavior": 1,
      "TargetType": "FrankensteinPet",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "CreateCorpse",
        "ReturnType": "BaseCorpse",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\t\tfor (int i = 0; i < containers.Length; i++)\r\n\t\t\t{\r\n\t\t\t\tcontainers[i].Clear();\r\n\t\t\t}\r\n\t\t}\r\n\t\tobject returnvar = Interface.CallHook(\"OnCorpsePopulate\", this, nPCPlayerCorpse);\r\n\t\tif (returnvar is global::BaseCorpse)\r\n\t\t{\r\n\t\t\treturn (global::BaseCorpse)returnvar;\r\n\t\t}\r\n\t\tresult = nPCPlayerCorpse;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCorpsePopulate [ScarecrowNPC]",
      "HookName": "OnCorpsePopulate",
      "HookParameters": {
        "instance": "ScarecrowNPC",
        "text": "string"
      },
      "ReturnBehavior": 1,
      "TargetType": "ScarecrowNPC",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "CreateCorpse",
        "ReturnType": "BaseCorpse",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\t\t{\r\n\t\t\t\tcontainers[i].Clear();\r\n\t\t\t}\r\n\t\t\tif (this.LootSpawnSlots.Length != 0)\r\n\t\t\t{\r\n\t\t\t\tobject returnvar = Interface.CallHook(\"OnCorpsePopulate\", this, text);\r\n\t\t\t\tif (returnvar is global::BaseCorpse)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn (global::BaseCorpse)returnvar;\r\n\t\t\t\t}\r\n\t\t\t\tglobal::LootContainer.LootSpawnSlot[] lootSpawnSlots = this.LootSpawnSlots;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCorpsePopulate [GingerbreadNPC]",
      "HookName": "OnCorpsePopulate",
      "HookParameters": {
        "instance": "GingerbreadNPC",
        "nPCPlayerCorpse": "NPCPlayerCorpse"
      },
      "ReturnBehavior": 1,
      "TargetType": "GingerbreadNPC",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "CreateCorpse",
        "ReturnType": "BaseCorpse",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\t\t{\r\n\t\t\t\tcontainers[i].Clear();\r\n\t\t\t}\r\n\t\t\tif (this.LootSpawnSlots.Length != 0)\r\n\t\t\t{\r\n\t\t\t\tobject returnvar = Interface.CallHook(\"OnCorpsePopulate\", this, nPCPlayerCorpse);\r\n\t\t\t\tif (returnvar is global::BaseCorpse)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn (global::BaseCorpse)returnvar;\r\n\t\t\t\t}\r\n\t\t\t\tglobal::LootContainer.LootSpawnSlot[] lootSpawnSlots = this.LootSpawnSlots;\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnNpcTarget [HumanNPC]",
      "HookName": "OnNpcTarget",
      "ReturnBehavior": 0,
      "TargetType": "HumanNPC",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "GetBestTarget",
        "ReturnType": "BaseEntity",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n{\r\n\tglobal::BaseEntity result = null;\r\n\tfloat num = -1f;\r\n\tforeach (global::BaseEntity current in this.Brain.Senses.Players)\r\n\t{\r\n\t\tif (!(current == null) && current.Health() > 0f && Interface.CallHook(\"OnNpcTarget\", this, current) == null)\r\n\t\t{\r\n\t\t\tfloat value = Vector3.Distance(current.transform.position, base.transform.position);\r\n\t\t\tfloat num2 = 1f - Mathf.InverseLerp(1f, this.Brain.SenseRange, value);\r\n\t\t\tfloat value2 = Vector3.Dot((current.transform.position - this.eyes.position).normalized, this.eyes.BodyForward());\r\n\t\t\tnum2 += Mathf.InverseLerp(this.Brain.VisionCone, 1f, value2) / 2f;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnXmasLootDistribute",
      "HookName": "OnXmasLootDistribute",
      "HookParameters": {
        "instance": "XMasRefill"
      },
      "ReturnBehavior": 1,
      "TargetType": "XMasRefill",
      "Category": "Seasonal",
      "MethodData": {
        "MethodName": "ServerInit",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\treturn;\r\n\t}\r\n\tthis.goodKids = ((global::BasePlayer.activePlayerList != null) ? new System.Collections.Generic.List<global::BasePlayer>(global::BasePlayer.activePlayerList) : new System.Collections.Generic.List<global::BasePlayer>());\r\n\tthis.stockings = ((global::Stocking.stockings != null) ? new System.Collections.Generic.List<global::Stocking>(global::Stocking.stockings.Values) : new System.Collections.Generic.List<global::Stocking>());\r\n\tbase.Invoke(new System.Action(this.RemoveMe), 60f);\r\n\tif (Interface.CallHook(\"OnXmasLootDistribute\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.InvokeRepeating(new System.Action(this.DistributeLoot), 3f, 0.02f);\r\n\tbase.Invoke(new System.Action(this.SendBells), 0.5f);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnXmasStockingFill",
      "HookName": "OnXmasStockingFill",
      "HookParameters": {
        "instance": "Stocking"
      },
      "ReturnBehavior": 1,
      "TargetType": "Stocking",
      "Category": "Seasonal",
      "MethodData": {
        "MethodName": "SpawnLoot",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\tDebug.Log(\"CONTACT DEVELOPERS! Stocking::PopulateLoot has null inventory!!! \" + base.name);\r\n\t\treturn;\r\n\t}\r\n\tif (this.IsEmpty())\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnXmasStockingFill\", this) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tbase.SpawnLoot();\r\n\t\tbase.SetFlag(global::BaseEntity.Flags.On, true, false, true);\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnXmasGiftsDistribute",
      "HookName": "OnXmasGiftsDistribute",
      "ReturnBehavior": 0,
      "TargetType": "XMasRefill",
      "Category": "Seasonal",
      "MethodData": {
        "MethodName": "DistributeGiftsForPlayer",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public bool DistributeGiftsForPlayer(global::BasePlayer player)\r\n{\r\n\tif (Interface.CallHook(\"OnXmasGiftsDistribute\", this, player) != null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tint num = this.GiftsPerPlayer();\r\n\tint num2 = this.GiftSpawnAttempts();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBradleyApcThink",
      "HookName": "OnBradleyApcThink",
      "HookParameters": {
        "instance": "BradleyAPC"
      },
      "ReturnBehavior": 1,
      "TargetType": "BradleyAPC",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "DoSimpleAI",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tif (base.isClient)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.SetFlag(global::BaseEntity.Flags.Reserved5, TOD_Sky.Instance.IsNight, false, true);\r\n\tif (Interface.CallHook(\"OnBradleyApcThink\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!this.DoAI)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTerrainCreate",
      "HookName": "OnTerrainCreate",
      "HookParameters": {
        "instance": "TerrainGenerator"
      },
      "ReturnBehavior": 0,
      "TargetType": "TerrainGenerator",
      "Category": "World",
      "MethodData": {
        "MethodName": "CreateTerrain",
        "ReturnType": "UnityEngine.GameObject",
        "Arguments": {
          "heightmapResolution": "int",
          "alphamapResolution": "int"
        }
      },
      "CodeAfterInjection": "public GameObject CreateTerrain(int heightmapResolution, int alphamapResolution)\r\n{\r\n\tInterface.CallHook(\"OnTerrainCreate\", this);\r\n\tTerrain component = Terrain.CreateTerrainGameObject(new TerrainData\r\n\t{\r\n\t\tbaseMapResolution = global::TerrainGenerator.GetBaseMapRes(),\r\n\t\theightmapResolution = heightmapResolution,\r\n\t\talphamapResolution = alphamapResolution,\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerColliderEnable",
      "HookName": "OnPlayerColliderEnable",
      "HookParameters": {
        "instance": "BasePlayer",
        "playerCollider": "CapsuleCollider"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "EnablePlayerCollider",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (this.playerCollider.enabled)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnPlayerColliderEnable\", this, this.playerCollider) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.RefreshColliderSize(true);\r\n\tthis.playerCollider.enabled = true;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerSleepEnded",
      "HookName": "OnPlayerSleepEnded",
      "HookParameters": {
        "instance": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "EndSleeping",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (!this.IsSleeping())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnPlayerSleepEnd\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.SetPlayerFlag(global::BasePlayer.PlayerFlags.Sleeping, false);\r\n\tthis.sleepStartTime = -1f;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnExcavatorSuppliesRequest",
      "HookName": "OnExcavatorSuppliesRequest",
      "HookDescription": "Called just after the excavator supply computer is triggered, before the plane is spawned.",
      "HookParameters": {
        "instance": "ExcavatorSignalComputer",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "ExcavatorSignalComputer",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "RequestSupplies",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.CallsPerSecond(5uL), global::BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void RequestSupplies(global::BaseEntity.RPCMessage rpc)\r\n{\r\n\tif (base.HasFlag(global::BaseEntity.Flags.Reserved7) && this.IsPowered() && this.chargePower >= global::ExcavatorSignalComputer.chargeNeededForSupplies)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnExcavatorSuppliesRequest\", this, rpc.player) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tglobal::BaseEntity baseEntity = global::GameManager.server.CreateEntity(this.supplyPlanePrefab.resourcePath, default(Vector3), default(Quaternion), true);\r\n\t\tif (baseEntity)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnExcavatorSuppliesRequested",
      "HookName": "OnExcavatorSuppliesRequested",
      "HookDescription": "Called after the excavator signal computer was triggered, just after the supply plane is spawned.",
      "HookParameters": {
        "instance": "ExcavatorSignalComputer",
        "player": "BasePlayer",
        "baseEntity": "BaseEntity"
      },
      "ReturnBehavior": 0,
      "TargetType": "ExcavatorSignalComputer",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "RequestSupplies",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.CallsPerSecond(5uL), global::BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void RequestSupplies(global::BaseEntity.RPCMessage rpc)\r\n{\r\n\tif (base.HasFlag(global::BaseEntity.Flags.Reserved7) && this.IsPowered() && this.chargePower >= global::ExcavatorSignalComputer.chargeNeededForSupplies)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnExcavatorSuppliesRequest\", this, rpc.player) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tglobal::BaseEntity baseEntity = global::GameManager.server.CreateEntity(this.supplyPlanePrefab.resourcePath, default(Vector3), default(Quaternion), true);\r\n\t\tif (baseEntity)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnClientProjectileEffectCreate",
      "HookName": "OnClientProjectileEffectCreate",
      "HookParameters": {
        "sourceConnection": "Connection",
        "instance": "BaseProjectile",
        "prefabName": "string"
      },
      "ReturnBehavior": 4,
      "TargetType": "BaseProjectile",
      "Category": "Player",
      "MethodData": {
        "MethodName": "CreateProjectileEffectClientside",
        "ReturnType": "void",
        "Arguments": {
          "prefabName": "string",
          "pos": "UnityEngine.Vector3",
          "velocity": "UnityEngine.Vector3",
          "seed": "int",
          "sourceConnection": "Network.Connection",
          "silenced": "bool",
          "forceClientsideEffects": "bool"
        }
      },
      "CodeAfterInjection": "private void CreateProjectileEffectClientside(string prefabName, Vector3 pos, Vector3 velocity, int seed, Connection sourceConnection, bool silenced = false, bool forceClientsideEffects = false)\r\n{\r\n\tif (Interface.CallHook(\"OnClientProjectileEffectCreate\", sourceConnection, this, prefabName) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::Effect effect = global::BaseProjectile.reusableInstance;\r\n\teffect.Clear();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanDesignFirework",
      "HookName": "CanDesignFirework",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "PatternFirework"
      },
      "ReturnBehavior": 1,
      "TargetType": "PatternFirework",
      "Category": "Firework",
      "MethodData": {
        "MethodName": "PlayerCanModify",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (player == null || !player.CanInteract())\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"CanDesignFirework\", player, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tglobal::BuildingPrivlidge buildingPrivilege = this.GetBuildingPrivilege();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFireworkStarted",
      "HookName": "OnFireworkStarted",
      "HookParameters": {
        "instance": "BaseFirework"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseFirework",
      "Category": "Firework",
      "MethodData": {
        "MethodName": "Begin",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public virtual void Begin()\r\n{\r\n\tbase.SetFlag(global::BaseEntity.Flags.OnFire, false, false, true);\r\n\tbase.SetFlag(global::BaseEntity.Flags.On, true, false, false);\r\n\tbase.SendNetworkUpdate_Flags();\r\n\tInterface.CallHook(\"OnFireworkStarted\", this);\r\n\tbase.Invoke(new System.Action(this.OnExhausted), this.activityLength);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFireworkExhausted",
      "HookName": "OnFireworkExhausted",
      "HookParameters": {
        "instance": "BaseFirework"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseFirework",
      "Category": "Firework",
      "MethodData": {
        "MethodName": "OnExhausted",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tbase.SetFlag(global::BaseEntity.Flags.Reserved8, true, false, false);\r\n\tbase.SetFlag(global::BaseEntity.Flags.OnFire, false, false, false);\r\n\tbase.SetFlag(global::BaseEntity.Flags.On, false, false, false);\r\n\tbase.EnableGlobalBroadcast(false);\r\n\tbase.SendNetworkUpdate_Flags();\r\n\tInterface.CallHook(\"OnFireworkExhausted\", this);\r\n\tbase.Invoke(new System.Action(this.Cleanup), this.corpseDuration);\r\n\tglobal::BaseFirework._activeFireworks.Remove(this);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFireworkDamage",
      "HookName": "OnFireworkDamage",
      "HookParameters": {
        "instance": "BaseFirework",
        "info": "HitInfo"
      },
      "ReturnBehavior": 4,
      "TargetType": "BaseFirework",
      "Category": "Firework",
      "MethodData": {
        "MethodName": "OnAttacked",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "...\r\n\tbase.OnAttacked(info);\r\n\tif (!base.isServer)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnFireworkDamage\", this, info) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (info.damageTypes.Has(Rust.DamageType.Heat))\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFireworkDesignChange",
      "HookName": "OnFireworkDesignChange",
      "HookParameters": {
        "instance": "PatternFirework",
        "design": "Design",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "PatternFirework",
      "Category": "Firework",
      "MethodData": {
        "MethodName": "ServerSetFireworkDesign",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (!this.PlayerCanModify(rpc.player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tProtoBuf.PatternFirework.Design design = ProtoBuf.PatternFirework.Design.Deserialize(rpc.read);\r\n\tif (Interface.CallHook(\"OnFireworkDesignChange\", this, design, rpc.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (((design != null) ? design.stars : null) != null)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFireworkDesignChanged",
      "HookName": "OnFireworkDesignChanged",
      "HookParameters": {
        "instance": "PatternFirework",
        "design": "Design",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "PatternFirework",
      "Category": "Firework",
      "MethodData": {
        "MethodName": "ServerSetFireworkDesign",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (!this.PlayerCanModify(rpc.player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tProtoBuf.PatternFirework.Design design = ProtoBuf.PatternFirework.Design.Deserialize(rpc.read);\r\n\tif (Interface.CallHook(\"OnFireworkDesignChange\", this, design, rpc.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (((design != null) ? design.stars : null) != null)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnServerInformationUpdated",
      "HookName": "OnServerInformationUpdated",
      "HookParameters": {},
      "ReturnBehavior": 0,
      "TargetType": "ServerMgr",
      "Category": "Server",
      "MethodData": {
        "MethodName": "UpdateServerInformation",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\tSteamServer.SetKey(\"fps\", global::Performance.report.frameRate.ToString());\r\n\t\tSteamServer.SetKey(\"fps_avg\", global::Performance.report.frameRateAverage.ToString(\"0.00\"));\r\n\t\tSteamServer.SetKey(\"ent_cnt\", global::BaseNetworkable.serverEntities.Count.ToString());\r\n\t\tSteamServer.SetKey(\"build\", BuildInfo.Current.Scm.ChangeId);\r\n\t}\r\n\tInterface.CallHook(\"OnServerInformationUpdated\");\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSignUpdated [CarvablePumpkin]",
      "HookName": "OnSignUpdated",
      "HookParameters": {
        "instance": "CarvablePumpkin",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "CarvablePumpkin",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "UpdateSign",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t}\r\n\t\tthis.textureIDs[num] = global::FileStorage.server.Store(array, global::FileStorage.Type.png, this.net.ID, (uint)num);\r\n\t}\r\n\tthis.LogEdit(msg.player);\r\n\tbase.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);\r\n\tInterface.CallHook(\"OnSignUpdated\", this, msg.player);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMlrsFire",
      "HookName": "OnMlrsFire",
      "HookParameters": {
        "instance": "MLRS",
        "owner": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "MLRS",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "Fire",
        "ReturnType": "void",
        "Arguments": {
          "owner": "BasePlayer"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (this._mounted == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnMlrsFire\", this, owner) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.SetFlag(global::BaseEntity.Flags.Reserved6, true, false, true);\r\n\tthis.radiusModIndex = 0;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMlrsFired",
      "HookName": "OnMlrsFired",
      "HookParameters": {
        "instance": "MLRS",
        "owner": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "MLRS",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "Fire",
        "ReturnType": "void",
        "Arguments": {
          "owner": "BasePlayer"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (this._mounted == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnMlrsFire\", this, owner) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.SetFlag(global::BaseEntity.Flags.Reserved6, true, false, true);\r\n\tthis.radiusModIndex = 0;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMlrsRocketFired",
      "HookName": "OnMlrsRocketFired",
      "HookParameters": {
        "instance": "MLRS",
        "serverProjectile": "ServerProjectile"
      },
      "ReturnBehavior": 0,
      "TargetType": "MLRS",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "FireNextRocket",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tVector3 aimToTarget = this.GetAimToTarget(targetPos, out num);\r\n\tglobal::ServerProjectile serverProjectile;\r\n\tif (base.TryFireProjectile(rocketContainer, AmmoTypes.MLRS_ROCKET, firingPos, aimToTarget, this.rocketOwnerRef.Get(true) as global::BasePlayer, 0f, 0f, out serverProjectile))\r\n\t{\r\n\t\tserverProjectile.gravityModifier = num / -Physics.gravity.y;\r\n\t\tInterface.CallHook(\"OnMlrsRocketFired\", this, serverProjectile);\r\n\t\tthis.nextRocketIndex--;\r\n\t\treturn;\r\n\t}\r\n\tthis.EndFiring();\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMlrsFiringEnded",
      "HookName": "OnMlrsFiringEnded",
      "HookParameters": {
        "instance": "MLRS"
      },
      "ReturnBehavior": 0,
      "TargetType": "MLRS",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "EndFiring",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tbase.SetFlag(global::BaseEntity.Flags.Reserved6, false, false, false);\r\n\tbase.SetFlag(global::BaseEntity.Flags.Broken, true, false, false);\r\n\tbase.SendNetworkUpdate_Flags();\r\n\tthis.timeSinceBroken = 0f;\r\n\tInterface.CallHook(\"OnMlrsFiringEnded\", this);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMlrsTarget",
      "HookName": "OnMlrsTarget",
      "HookParameters": {
        "instance": "MLRS",
        "worldPos": "Vector3",
        "_mounted": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "MLRS",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "SetUserTargetHitPos",
        "ReturnType": "void",
        "Arguments": {
          "worldPos": "UnityEngine.Vector3"
        }
      },
      "CodeAfterInjection": "...\r\n\t\tVector3 vector = position + global::TerrainMeta.Size;\r\n\t\tworldPos.x = Mathf.Clamp(worldPos.x, position.x, vector.x);\r\n\t\tworldPos.z = Mathf.Clamp(worldPos.z, position.z, vector.z);\r\n\t\tworldPos.y = this.GetSurfaceHeight(worldPos);\r\n\t}\r\n\tif (Interface.CallHook(\"OnMlrsTarget\", this, worldPos, this._mounted) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.UserTargetHitPos = worldPos;\r\n\tif (base.isServer)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMlrsTargetSet",
      "HookName": "OnMlrsTargetSet",
      "HookParameters": {
        "instance": "MLRS",
        "trueTargetHitPos": "Vector3",
        "_mounted": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "MLRS",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "SetUserTargetHitPos",
        "ReturnType": "void",
        "Arguments": {
          "worldPos": "UnityEngine.Vector3"
        }
      },
      "CodeAfterInjection": "...\r\n\t\tVector3 vector = position + global::TerrainMeta.Size;\r\n\t\tworldPos.x = Mathf.Clamp(worldPos.x, position.x, vector.x);\r\n\t\tworldPos.z = Mathf.Clamp(worldPos.z, position.z, vector.z);\r\n\t\tworldPos.y = this.GetSurfaceHeight(worldPos);\r\n\t}\r\n\tif (Interface.CallHook(\"OnMlrsTarget\", this, worldPos, this._mounted) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.UserTargetHitPos = worldPos;\r\n\tif (base.isServer)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityReskin",
      "HookName": "OnEntityReskin",
      "HookDescription": "Called when the player attempts to reskin a entity",
      "HookParameters": {
        "baseEntity": "BaseEntity",
        "skin": "Skin",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "SprayCan",
      "Category": "Crafting",
      "MethodData": {
        "MethodName": "ChangeItemSkin",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tglobal::ItemDefinition itemDefinition2 = null;\r\n\t\tulong skinID = global::ItemDefinition.FindSkin(itemDefinition.itemid, <>c__DisplayClass34_.targetSkin);\r\n\t\tglobal::ItemSkinDirectory.Skin skin = itemDefinition.skins.FirstOrDefault((global::ItemSkinDirectory.Skin x) => x.id == <>c__DisplayClass34_.targetSkin);\r\n\t\tif (Interface.CallHook(\"OnEntityReskin\", baseEntity, skin, msg.player) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tglobal::ItemSkin itemSkin;\r\n\t\tif (skin.invItem != null && (itemSkin = (skin.invItem as global::ItemSkin)) != null)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityReskinned",
      "HookName": "OnEntityReskinned",
      "HookDescription": "Called when the player has reskinned an entity",
      "HookParameters": {
        "baseEntity": "BaseEntity",
        "skin": "Skin",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "SprayCan",
      "Category": "Crafting",
      "MethodData": {
        "MethodName": "ChangeItemSkin",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tglobal::ItemDefinition itemDefinition2 = null;\r\n\t\tulong skinID = global::ItemDefinition.FindSkin(itemDefinition.itemid, <>c__DisplayClass34_.targetSkin);\r\n\t\tglobal::ItemSkinDirectory.Skin skin = itemDefinition.skins.FirstOrDefault((global::ItemSkinDirectory.Skin x) => x.id == <>c__DisplayClass34_.targetSkin);\r\n\t\tif (Interface.CallHook(\"OnEntityReskin\", baseEntity, skin, msg.player) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tglobal::ItemSkin itemSkin;\r\n\t\tif (skin.invItem != null && (itemSkin = (skin.invItem as global::ItemSkin)) != null)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemStacked [2]",
      "HookName": "OnItemStacked",
      "HookParameters": {
        "enumerator": "IItemContainerEntity",
        "instance": "Item",
        "newcontainer": "ItemContainer"
      },
      "ReturnBehavior": 0,
      "TargetType": "Item",
      "Category": "Item",
      "MethodData": {
        "MethodName": "MoveToContainer",
        "ReturnType": "bool",
        "Arguments": {
          "newcontainer": "ItemContainer",
          "iTargetPos": "int",
          "allowStack": "bool",
          "ignoreStackLimit": "bool",
          "sourcePlayer": "BasePlayer",
          "allowSwap": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t\t\t\t\tint num2 = Mathf.Min(num - slot2.amount, this.amount);\r\n\t\t\t\t\t\tslot2.amount += num2;\r\n\t\t\t\t\t\tthis.amount -= num2;\r\n\t\t\t\t\t\tslot2.MarkDirty();\r\n\t\t\t\t\t\tthis.MarkDirty();\r\n\t\t\t\t\t\tInterface.CallHook(\"OnItemStacked\", slot2, this, newcontainer, num2);\r\n\t\t\t\t\t\tif (this.amount <= 0)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tthis.RemoveFromWorld();\r\n\t\t\t\t\t\t\tthis.RemoveFromContainer();\r\n\t\t\t\t\t\t\tthis.Remove(0f);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnConnectionDequeue",
      "HookName": "OnConnectionDequeue",
      "HookParameters": {
        "connection": "Connection"
      },
      "ReturnBehavior": 1,
      "TargetType": "ConnectionQueue",
      "Category": "Queue",
      "MethodData": {
        "MethodName": "RemoveConnection",
        "ReturnType": "void",
        "Arguments": {
          "connection": "Network.Connection"
        }
      },
      "CodeAfterInjection": "public void RemoveConnection(Connection connection)\r\n{\r\n\tif (Interface.CallHook(\"OnConnectionDequeue\", connection) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.queue.Remove(connection))\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnConnectionQueue",
      "HookName": "OnConnectionQueue",
      "HookParameters": {
        "connection": "Connection"
      },
      "ReturnBehavior": 1,
      "TargetType": "ConnectionQueue",
      "Category": "Queue",
      "MethodData": {
        "MethodName": "Join",
        "ReturnType": "void",
        "Arguments": {
          "connection": "Network.Connection"
        }
      },
      "CodeAfterInjection": "internal void Join(Connection connection)\r\n{\r\n\tif (Interface.CallHook(\"OnConnectionQueue\", connection) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tconnection.state = Connection.State.InQueue;\r\n\tthis.queue.Add(connection);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnQueueMessage",
      "HookName": "OnQueueMessage",
      "HookParameters": {
        "c": "Connection",
        "position": "Int32"
      },
      "ReturnBehavior": 1,
      "TargetType": "ConnectionQueue",
      "Category": "Queue",
      "MethodData": {
        "MethodName": "SendMessage",
        "ReturnType": "void",
        "Arguments": {
          "c": "Network.Connection",
          "position": "int"
        }
      },
      "CodeAfterInjection": "private void SendMessage(Connection c, int position)\r\n{\r\n\tif (Interface.CallHook(\"OnQueueMessage\", c, position) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tstring val = string.Empty;\r\n\tif (position > 0)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnQueueCycle",
      "HookName": "OnQueueCycle",
      "HookParameters": {
        "availableSlots": "Int32"
      },
      "ReturnBehavior": 1,
      "TargetType": "ConnectionQueue",
      "Category": "Queue",
      "MethodData": {
        "MethodName": "Cycle",
        "ReturnType": "void",
        "Arguments": {
          "availableSlots": "int"
        }
      },
      "CodeAfterInjection": "public void Cycle(int availableSlots)\r\n{\r\n\tif (Interface.CallHook(\"OnQueueCycle\", availableSlots) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.queue.Count == 0)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSprinklerSplashed",
      "HookName": "OnSprinklerSplashed",
      "HookDescription": "Called after a Sprinkler has splashed water",
      "HookParameters": {
        "instance": "Sprinkler"
      },
      "ReturnBehavior": 0,
      "TargetType": "Sprinkler",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "DoSplash",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\tif (this.DecayPerSplash > 0f)\r\n\t\t{\r\n\t\t\tbase.Hurt(this.DecayPerSplash);\r\n\t\t}\r\n\t}\r\n\tInterface.CallHook(\"OnSprinklerSplashed\", this);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "CanWaterBallSplash",
      "HookName": "CanWaterBallSplash",
      "HookDescription": "Called when a WaterBall splash effect is about to happen",
      "HookParameters": {
        "liquidDef": "ItemDefinition",
        "position": "Vector3",
        "radius": "float",
        "amount": "int"
      },
      "ReturnBehavior": 1,
      "TargetType": "WaterBall",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "DoSplash",
        "ReturnType": "bool",
        "Arguments": {
          "position": "UnityEngine.Vector3",
          "radius": "float",
          "liquidDef": "ItemDefinition",
          "amount": "int"
        }
      },
      "CodeAfterInjection": "public static bool DoSplash(Vector3 position, float radius, global::ItemDefinition liquidDef, int amount)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanWaterBallSplash\", liquidDef, position, radius, amount);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tSystem.Collections.Generic.List<global::BaseEntity> list = Pool.GetList<global::BaseEntity>();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanFireLiquidWeapon",
      "HookName": "CanFireLiquidWeapon",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "LiquidWeapon"
      },
      "ReturnBehavior": 1,
      "TargetType": "LiquidWeapon",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "CanFire",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "private bool CanFire(global::BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanFireLiquidWeapon\", player, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif (this.RequiresPumping && this.pressure < this.PressureLossPerTick)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnLiquidWeaponFired",
      "HookName": "OnLiquidWeaponFired",
      "HookParameters": {
        "instance": "LiquidWeapon",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "LiquidWeapon",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "StartFiring",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tthis.StartCooldown(this.FireRate);\r\n\tif (base.isServer)\r\n\t{\r\n\t\tbase.SendNetworkUpdateImmediate(false);\r\n\t}\r\n\tInterface.CallHook(\"OnLiquidWeaponFired\", this, player);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnLiquidWeaponFiringStopped",
      "HookName": "OnLiquidWeaponFiringStopped",
      "HookParameters": {
        "instance": "LiquidWeapon"
      },
      "ReturnBehavior": 0,
      "TargetType": "LiquidWeapon",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "StopFiring",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tbase.SetFlag(global::BaseEntity.Flags.On, false, false, true);\r\n\tif (base.isServer)\r\n\t{\r\n\t\tbase.SendNetworkUpdateImmediate(false);\r\n\t}\r\n\tInterface.CallHook(\"OnLiquidWeaponFiringStopped\", this);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPhotoCapture",
      "HookName": "OnPhotoCapture",
      "HookDescription": "Called when a player attemts to capture a photo using a camera",
      "HookParameters": {
        "photoEntity": "PhotoEntity",
        "item": "Item",
        "player": "BasePlayer",
        "array": "Byte[]"
      },
      "ReturnBehavior": 1,
      "TargetType": "InstantCameraTool",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "TakePhoto",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t\titem2.Remove(0f);\r\n\t\tDebug.LogError(\"Sub-entity is not a photo\");\r\n\t\treturn;\r\n\t}\r\n\tphotoEntity.SetImageData(player.userID, array);\r\n\tif (Interface.CallHook(\"OnPhotoCapture\", photoEntity, item, player, array) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!player.inventory.GiveItem(item2, null, false))\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPhotoCaptured",
      "HookName": "OnPhotoCaptured",
      "HookDescription": "Called after a player captures a photo using a camera",
      "HookParameters": {
        "photoEntity": "PhotoEntity",
        "item": "Item",
        "player": "BasePlayer",
        "array": "Byte[]"
      },
      "ReturnBehavior": 0,
      "TargetType": "InstantCameraTool",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "TakePhoto",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t\titem2.Remove(0f);\r\n\t\tDebug.LogError(\"Sub-entity is not a photo\");\r\n\t\treturn;\r\n\t}\r\n\tphotoEntity.SetImageData(player.userID, array);\r\n\tif (Interface.CallHook(\"OnPhotoCapture\", photoEntity, item, player, array) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!player.inventory.GiveItem(item2, null, false))\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnDoorKnocked [DoorKnocker]",
      "HookName": "OnDoorKnocked",
      "HookParameters": {
        "instance": "DoorKnocker",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "DoorKnocker",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "Knock",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public void Knock(global::BasePlayer player)\r\n{\r\n\tbase.ClientRPC<Vector3>(null, \"ClientKnock\", player.transform.position);\r\n\tInterface.CallHook(\"OnDoorKnocked\", this, player);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnNpcTargetSense",
      "HookName": "OnNpcTargetSense",
      "HookParameters": {
        "owner": "BaseEntity",
        "ent": "BaseEntity",
        "brainSenses": "AIBrainSenses"
      },
      "ReturnBehavior": 1,
      "TargetType": "Rust.AI.SimpleAIMemory",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "SetKnown",
        "ReturnType": "void",
        "Arguments": {
          "ent": "BaseEntity",
          "owner": "BaseEntity",
          "brainSenses": "AIBrainSenses"
        }
      },
      "CodeAfterInjection": "public void SetKnown(global::BaseEntity ent, global::BaseEntity owner, global::AIBrainSenses brainSenses)\r\n{\r\n\tif (Interface.CallHook(\"OnNpcTargetSense\", owner, ent, brainSenses) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::IAISenses iAISenses = owner as global::IAISenses;\r\n\tglobal::BasePlayer basePlayer = ent as global::BasePlayer;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTreeMarkerHit",
      "HookName": "OnTreeMarkerHit",
      "HookDescription": "Called when a player hits a tree with a tool (rock, hatchet, etc.)",
      "HookParameters": {
        "instance": "TreeEntity",
        "info": "HitInfo"
      },
      "ReturnBehavior": 1,
      "TargetType": "TreeEntity",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "DidHitMarker",
        "ReturnType": "bool",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (this.xMarker == null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"OnTreeMarkerHit\", this, info);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif (global::PrefabAttribute.server.Find<global::TreeMarkerData>(this.prefabID) != null)\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnEngineStartFinished",
      "HookName": "OnEngineStartFinished",
      "ReturnBehavior": 0,
      "TargetType": "VehicleEngineController`1",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "FinishStartingEngine",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.owner.SetFlag(global::BaseEntity.Flags.On, true, false, true);\r\n\tthis.owner.SetFlag(this.engineStartingFlag, false, false, true);\r\n\tInterface.CallHook(\"OnEngineStartFinished\", this.owner);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnNetworkSubscriptionsGather",
      "HookName": "OnNetworkSubscriptionsGather",
      "HookParameters": {
        "instance": "NetworkVisibilityGrid",
        "group": "Group",
        "groups": "List`1",
        "radius": "Int32"
      },
      "ReturnBehavior": 1,
      "TargetType": "NetworkVisibilityGrid",
      "Category": "Network",
      "MethodData": {
        "MethodName": "GetVisibleFrom",
        "ReturnType": "void",
        "Arguments": {
          "group": "Network.Visibility.Group",
          "groups": "System.Collections.Generic.List`1<Network.Visibility.Group>",
          "radius": "int"
        }
      },
      "CodeAfterInjection": "private void GetVisibleFrom(Group group, System.Collections.Generic.List<Group> groups, int radius)\r\n{\r\n\tif (Interface.CallHook(\"OnNetworkSubscriptionsGather\", this, group, groups, radius) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::NetworkVisibilityGrid.<>c__DisplayClass34_0 <>c__DisplayClass34_;\r\n\t<>c__DisplayClass34_.groups = groups;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnVendingShopOpened [VendingMachine]",
      "HookName": "OnVendingShopOpened",
      "HookParameters": {
        "instance": "VendingMachine",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "VendingMachine",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "RPC_OpenShop",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (!base.OccupiedCheck(msg.player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnVendingShopOpen\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.SendSellOrders(msg.player);\r\n\tthis.PlayerOpenLoot(msg.player, this.customerPanel, true);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnVendingShopOpened [NPCTalking]",
      "HookName": "OnVendingShopOpened",
      "HookParameters": {
        "itemDefinition": "InvisibleVendingMachine",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "NPCTalking",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "OnConversationAction",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer",
          "action": "string"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\tglobal::InvisibleVendingMachine vendingMachine = base.GetVendingMachine();\r\n\t\tif (vendingMachine != null && Vector3.Distance(player.transform.position, base.transform.position) < 5f)\r\n\t\t{\r\n\t\t\tthis.ForceEndConversation(player);\r\n\t\t\tif (Interface.CallHook(\"OnVendingShopOpen\", vendingMachine, player) != null)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvendingMachine.PlayerOpenLoot(player, \"vendingmachine.customer\", false);\r\n\t\t\tInterface.CallHook(\"OnVendingShopOpened\", vendingMachine, player);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnAdventGiftAward",
      "HookName": "OnAdventGiftAward",
      "HookParameters": {
        "instance": "AdventCalendar",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "AdventCalendar",
      "Category": "Seasonal",
      "MethodData": {
        "MethodName": "AwardGift",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public void AwardGift(global::BasePlayer player)\r\n{\r\n\tif (Interface.CallHook(\"OnAdventGiftAward\", this, player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tSystem.DateTime now = System.DateTime.Now;\r\n\tint num = now.Day - this.startDay;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnAdventGiftAwarded",
      "HookName": "OnAdventGiftAwarded",
      "HookParameters": {
        "instance": "AdventCalendar",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "AdventCalendar",
      "Category": "Seasonal",
      "MethodData": {
        "MethodName": "AwardGift",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public void AwardGift(global::BasePlayer player)\r\n{\r\n\tif (Interface.CallHook(\"OnAdventGiftAward\", this, player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tSystem.DateTime now = System.DateTime.Now;\r\n\tint num = now.Day - this.startDay;\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "CanBeAwardedAdventGift",
      "HookName": "CanBeAwardedAdventGift",
      "ReturnBehavior": 0,
      "TargetType": "AdventCalendar",
      "Category": "Seasonal",
      "MethodData": {
        "MethodName": "WasAwardedTodaysGift",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public bool WasAwardedTodaysGift(global::BasePlayer player)\r\n{\r\n\tobject OxideGen_2 = Interface.CallHook(\"CanBeAwardedAdventGift\", this, player);\r\n\tif (OxideGen_2 is bool)\r\n\t{\r\n\t\treturn !(bool)OxideGen_2;\r\n\t}\r\n\tif (!global::AdventCalendar.playerRewardHistory.ContainsKey(player.userID))\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemPainted",
      "HookName": "OnItemPainted",
      "HookParameters": {
        "instance": "PaintedItemStorageEntity",
        "enumerator": "Item",
        "player": "BasePlayer",
        "current": "Byte[]"
      },
      "ReturnBehavior": 0,
      "TargetType": "PaintedItemStorageEntity",
      "Category": "Item",
      "MethodData": {
        "MethodName": "Server_UpdateImage",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t{\r\n\t\t\titem.LoseCondition(0.25f);\r\n\t\t}\r\n\t\tthis.lastEditedBy = msg.player.userID;\r\n\t}\r\n\tInterface.CallHook(\"OnItemPainted\", this, item, msg.player, array);\r\n\tbase.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemRecycleAmount",
      "HookName": "OnItemRecycleAmount",
      "HookParameters": {
        "slot": "Item",
        "num2": "int",
        "instance": "Recycler"
      },
      "ReturnBehavior": 3,
      "TargetType": "Recycler",
      "Category": "Item",
      "MethodData": {
        "MethodName": "RecycleThink",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tfor (int i = 0; i < 6; i++)\r\n\t{\r\n\t\tglobal::Item slot = base.inventory.GetSlot(i);\r\n\t\tif (this.CanBeRecycled(slot))\r\n\t\t{\r\n\t\t\tif (Interface.CallHook(\"OnItemRecycle\", slot, this) != null)\r\n\t\t\t{\r\n\t\t\t\tif (!base.HasRecyclable())\r\n\t\t\t\t{\r\n\t\t\t\t\tbase.StopRecycling();\r\n\t\t\t\t\treturn;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTrainCarUncouple",
      "HookName": "OnTrainCarUncouple",
      "HookParameters": {
        "instance": "TrainCar",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "TrainCar",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "RPC_WantsUncouple",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (Vector3.SqrMagnitude(base.transform.position - player.transform.position) > 200f)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnTrainCarUncouple\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbool front = msg.read.Bit();\r\n\tthis.coupling.Uncouple(front);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanTrainCarCouple",
      "HookName": "CanTrainCarCouple",
      "HookParameters": {
        "owner": "TrainCar",
        "owner2": "TrainCar"
      },
      "ReturnBehavior": 1,
      "TargetType": "TrainCoupling",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "TryCouple",
        "ReturnType": "bool",
        "Arguments": {
          "theirCoupling": "TrainCoupling",
          "reflect": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (this.IsCoupled)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"CanTrainCarCouple\", this.owner, theirCoupling.owner);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif (reflect && !theirCoupling.TryCouple(this, false))\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSamSiteModeToggle",
      "HookName": "OnSamSiteModeToggle",
      "HookDescription": "Called when player attempts to change SamSite targeting mode",
      "HookParameters": {
        "instance": "SamSite",
        "player": "BasePlayer",
        "flag": "bool"
      },
      "ReturnBehavior": 1,
      "TargetType": "SamSite",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "ToggleDefenderMode",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tbool flag = msg.read.Bit();\r\n\tif (flag == this.IsInDefenderMode())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnSamSiteModeToggle\", this, player, flag) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.SetFlag(this.Flag_DefenderMode, flag, false, true);\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSprayCreate",
      "HookName": "OnSprayCreate",
      "HookDescription": "Called when the player attempts to use a spraycan to place a spray",
      "HookParameters": {
        "instance": "SprayCan",
        "vector": "Vector3",
        "quaternion": "Quaternion"
      },
      "ReturnBehavior": 1,
      "TargetType": "SprayCan",
      "Category": "Crafting",
      "MethodData": {
        "MethodName": "CreateSpray",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (num != 0 && !flag && !msg.player.blueprints.CheckSkinOwnership(num, msg.player.userID))\r\n\t{\r\n\t\tDebug.Log(string.Format(\"SprayCan.ChangeItemSkin player does not have item :{0}:\", num));\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnSprayCreate\", this, vector, quaternion) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tulong skinID = global::ItemDefinition.FindSkin(this.SprayDecalItem.itemid, num);\r\n\tglobal::BaseEntity expr_160 = global::GameManager.server.CreateEntity(this.SprayDecalEntityRef.resourcePath, vector, quaternion, true);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnLockerSwap",
      "HookName": "OnLockerSwap",
      "HookParameters": {
        "instance": "Locker",
        "num": "int",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "Locker",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "RPC_Equip",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tint num = msg.read.Int32();\r\n\tif (num < 0 || num >= 3)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnLockerSwap\", this, num, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.IsEquipping())\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnWeaponModChange",
      "HookName": "OnWeaponModChange",
      "HookParameters": {
        "instance": "BaseProjectile",
        "GetOwnerPlayer()": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseProjectile",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "DelayedModsChanged",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void DelayedModsChanged()\r\n{\r\n\tif (Interface.CallHook(\"OnWeaponModChange\", this, this.GetOwnerPlayer()) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tSystem.Func<global::ProjectileWeaponMod, global::ProjectileWeaponMod.Modifier> arg_59_1;\r\n\tif ((arg_59_1 = global::BaseProjectile.<>c.<>9__88_0) == null)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSprayRemove",
      "HookName": "OnSprayRemove",
      "HookDescription": "Called when SprayCan spray is being removed",
      "HookParameters": {
        "instance": "SprayCanSpray",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "SprayCanSpray",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "Server_RequestWaterClear",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (!this.Menu_WaterClear_ShowIf(player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnSprayRemove\", this, player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.Kill(global::BaseNetworkable.DestroyMode.None);\r\n}\r\n"
    },
    {
      "Type": 1,
      "Name": "SplashThresholdField [SprayCanSpray]",
      "HookName": "SplashThresholdField [SprayCanSpray]",
      "ReturnBehavior": 0,
      "TargetType": "SprayCanSpray",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "WantsSplash",
        "ReturnType": "bool",
        "Arguments": {
          "splashType": "ItemDefinition",
          "amount": "int"
        }
      }
    },
    {
      "Type": 0,
      "Name": "OnHelicopterAttacked [BaseHelicopter]",
      "HookName": "OnHelicopterAttacked",
      "HookParameters": {
        "instance": "BaseHelicopter",
        "info": "HitInfo"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseHelicopter",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "Hurt",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "public override void Hurt(global::HitInfo info)\r\n{\r\n\tif (Interface.CallHook(\"OnHelicopterAttacked\", this, info) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbool flag = false;\r\n\tif (info.damageTypes.Total() >= base.health)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnComposterUpdate",
      "HookName": "OnComposterUpdate",
      "HookDescription": "Called when a Composer is recalculating it's composting items",
      "HookParameters": {
        "instance": "Composter"
      },
      "ReturnBehavior": 1,
      "TargetType": "Composter",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "UpdateComposting",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void UpdateComposting()\r\n{\r\n\tif (Interface.CallHook(\"OnComposterUpdate\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfor (int i = 0; i < base.inventory.capacity; i++)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnInventoryItemsCount",
      "HookName": "OnInventoryItemsCount",
      "HookParameters": {
        "instance": "PlayerInventory",
        "itemid": "Int32"
      },
      "ReturnBehavior": 1,
      "TargetType": "PlayerInventory",
      "Category": "Item",
      "MethodData": {
        "MethodName": "GetAmount",
        "ReturnType": "int",
        "Arguments": {
          "itemid": "int"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (itemid == 0)\r\n\t{\r\n\t\treturn 0;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"OnInventoryItemsCount\", this, itemid);\r\n\tif (returnvar is int)\r\n\t{\r\n\t\treturn (int)returnvar;\r\n\t}\r\n\tint num = 0;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnInventoryItemsTake",
      "HookName": "OnInventoryItemsTake",
      "HookParameters": {
        "instance": "PlayerInventory",
        "collect": "List`1",
        "itemid": "Int32",
        "amount": "Int32"
      },
      "ReturnBehavior": 1,
      "TargetType": "PlayerInventory",
      "Category": "Item",
      "MethodData": {
        "MethodName": "Take",
        "ReturnType": "int",
        "Arguments": {
          "collect": "System.Collections.Generic.List`1<Item>",
          "itemid": "int",
          "amount": "int"
        }
      },
      "CodeAfterInjection": "public int Take(System.Collections.Generic.List<global::Item> collect, int itemid, int amount)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"OnInventoryItemsTake\", this, collect, itemid, amount);\r\n\tif (returnvar is int)\r\n\t{\r\n\t\treturn (int)returnvar;\r\n\t}\r\n\tint num = 0;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnInventoryItemsFind",
      "HookName": "OnInventoryItemsFind",
      "HookParameters": {
        "instance": "PlayerInventory",
        "id": "Int32"
      },
      "ReturnBehavior": 1,
      "TargetType": "PlayerInventory",
      "Category": "Item",
      "MethodData": {
        "MethodName": "FindItemIDs",
        "ReturnType": "System.Collections.Generic.List`1<Item>",
        "Arguments": {
          "id": "int"
        }
      },
      "CodeAfterInjection": "public System.Collections.Generic.List<global::Item> FindItemIDs(int id)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"OnInventoryItemsFind\", this, id);\r\n\tif (returnvar is System.Collections.Generic.List<global::Item>)\r\n\t{\r\n\t\treturn (System.Collections.Generic.List<global::Item>)returnvar;\r\n\t}\r\n\tSystem.Collections.Generic.List<global::Item> list = new System.Collections.Generic.List<global::Item>();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnInventoryAmmoFind",
      "HookName": "OnInventoryAmmoFind",
      "HookParameters": {
        "instance": "PlayerInventory",
        "list": "List`1",
        "ammoType": "AmmoTypes"
      },
      "ReturnBehavior": 1,
      "TargetType": "PlayerInventory",
      "Category": "Item",
      "MethodData": {
        "MethodName": "FindAmmo",
        "ReturnType": "void",
        "Arguments": {
          "list": "System.Collections.Generic.List`1<Item>",
          "ammoType": "Rust.AmmoTypes"
        }
      },
      "CodeAfterInjection": "public void FindAmmo(System.Collections.Generic.List<global::Item> list, AmmoTypes ammoType)\r\n{\r\n\tif (Interface.CallHook(\"OnInventoryAmmoFind\", this, list, ammoType) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.containerMain != null)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnDroppedItemCombined",
      "HookName": "OnDroppedItemCombined",
      "HookParameters": {
        "instance": "DroppedItem"
      },
      "ReturnBehavior": 0,
      "TargetType": "DroppedItem",
      "Category": "Item",
      "MethodData": {
        "MethodName": "OnDroppedOn",
        "ReturnType": "void",
        "Arguments": {
          "di": "DroppedItem"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (di.item == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanCombineDroppedItem\", this, di) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (di.item.info != this.item.info)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnRandomItemAward",
      "HookName": "OnRandomItemAward",
      "ReturnBehavior": 0,
      "TargetType": "RandomItemDispenser",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "TryAward",
        "ReturnType": "bool",
        "Arguments": {
          "itemChance": "RandomItemDispenser/RandomItemChance",
          "forPlayer": "BasePlayer",
          "distributorPosition": "UnityEngine.Vector3"
        }
      },
      "CodeAfterInjection": "private bool TryAward(global::RandomItemDispenser.RandomItemChance itemChance, global::BasePlayer forPlayer, Vector3 distributorPosition)\r\n{\r\n\tif (Interface.CallHook(\"OnRandomItemAward\", this, itemChance, forPlayer, distributorPosition) != null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tfloat num = UnityEngine.Random.Range(0f, 1f);\r\n\tif (itemChance.Chance >= num)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRemoteIdentifierUpdate",
      "HookName": "OnRemoteIdentifierUpdate",
      "HookDescription": "Called when a remote controlled entity it's identifier changes",
      "HookParameters": {
        "instance": "PoweredRemoteControlEntity",
        "newID": "string"
      },
      "ReturnBehavior": 1,
      "TargetType": "PoweredRemoteControlEntity",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "UpdateIdentifier",
        "ReturnType": "void",
        "Arguments": {
          "newID": "string",
          "clientSend": "bool"
        }
      },
      "CodeAfterInjection": "public void UpdateIdentifier(string newID, bool clientSend = false)\r\n{\r\n\tif (Interface.CallHook(\"OnRemoteIdentifierUpdate\", this, newID) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tstring arg_16_0 = this.rcIdentifier;\r\n\tif (base.isServer)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnOvenStart",
      "HookName": "OnOvenStart",
      "HookDescription": "Called when a Oven starts to cook",
      "HookParameters": {
        "instance": "BaseOven"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseOven",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "StartCooking",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public virtual void StartCooking()\r\n{\r\n\tif (Interface.CallHook(\"OnOvenStart\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.FindBurnable() == null && !this.CanRunWithNoFuel)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnOvenStarted",
      "HookName": "OnOvenStarted",
      "HookDescription": "Called when a Oven started to cook",
      "HookParameters": {
        "instance": "BaseOven"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseOven",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "StartCooking",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public virtual void StartCooking()\r\n{\r\n\tif (Interface.CallHook(\"OnOvenStart\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.FindBurnable() == null && !this.CanRunWithNoFuel)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerBanned [EAC]",
      "HookName": "OnPlayerBanned",
      "HookParameters": {
        "connection": "Connection",
        "ToString()": "string"
      },
      "ReturnBehavior": 0,
      "TargetType": "EACServer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "OnClientActionRequired",
        "ReturnType": "void",
        "Arguments": {
          "data": "Epic.OnlineServices.AntiCheatCommon.OnClientActionRequiredCallbackInfo&"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t\t{\r\n\t\t\t\tUtf8String actionReasonDetailsString = data.ActionReasonDetailsString;\r\n\t\t\t\tDebug.Log(string.Format(\"[EAC] Kicking {0} / {1} ({2})\", connection.userid, connection.username, actionReasonDetailsString));\r\n\t\t\t\tconnection.authStatus = \"eac\";\r\n\t\t\t\tNetwork.Net.sv.Kick(connection, \"EAC: \" + actionReasonDetailsString, false);\r\n\t\t\t\tInterface.CallHook(\"OnPlayerKicked\", connection, actionReasonDetailsString.ToString());\r\n\t\t\t\tif (data.ActionReasonCode == AntiCheatCommonClientActionReason.PermanentBanned || data.ActionReasonCode == AntiCheatCommonClientActionReason.TemporaryBanned)\r\n\t\t\t\t{\r\n\t\t\t\t\tconnection.authStatus = \"eacbanned\";\r\n\t\t\t\t\tglobal::ConsoleNetwork.BroadcastToAllClients(\"chat.add\", new object[]\r\n\t\t\t\t\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerKicked [EAC]",
      "HookName": "OnPlayerKicked",
      "HookParameters": {
        "connection": "Connection",
        "ToString()": "string"
      },
      "ReturnBehavior": 0,
      "TargetType": "EACServer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "OnClientActionRequired",
        "ReturnType": "void",
        "Arguments": {
          "data": "Epic.OnlineServices.AntiCheatCommon.OnClientActionRequiredCallbackInfo&"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t\t{\r\n\t\t\t\tUtf8String actionReasonDetailsString = data.ActionReasonDetailsString;\r\n\t\t\t\tDebug.Log(string.Format(\"[EAC] Kicking {0} / {1} ({2})\", connection.userid, connection.username, actionReasonDetailsString));\r\n\t\t\t\tconnection.authStatus = \"eac\";\r\n\t\t\t\tNetwork.Net.sv.Kick(connection, \"EAC: \" + actionReasonDetailsString, false);\r\n\t\t\t\tInterface.CallHook(\"OnPlayerKicked\", connection, actionReasonDetailsString.ToString());\r\n\t\t\t\tif (data.ActionReasonCode == AntiCheatCommonClientActionReason.PermanentBanned || data.ActionReasonCode == AntiCheatCommonClientActionReason.TemporaryBanned)\r\n\t\t\t\t{\r\n\t\t\t\t\tconnection.authStatus = \"eacbanned\";\r\n\t\t\t\t\tglobal::ConsoleNetwork.BroadcastToAllClients(\"chat.add\", new object[]\r\n\t\t\t\t\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnOvenTemperature",
      "HookName": "OnOvenTemperature",
      "HookDescription": "Called when an Oven temptrature is calculated for specific slot",
      "HookParameters": {
        "instance": "BaseOven",
        "slot": "Int32"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseOven",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "GetTemperature",
        "ReturnType": "float",
        "Arguments": {
          "slot": "int"
        }
      },
      "CodeAfterInjection": "public float GetTemperature(int slot)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"OnOvenTemperature\", this, slot);\r\n\tif (returnvar is float)\r\n\t{\r\n\t\treturn (float)returnvar;\r\n\t}\r\n\tif (!base.HasFlag(global::BaseEntity.Flags.On))\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBuildingMerge",
      "HookName": "OnBuildingMerge",
      "HookParameters": {
        "instance": "ServerBuildingManager",
        "building1": "Building",
        "building2": "Building"
      },
      "ReturnBehavior": 0,
      "TargetType": "ServerBuildingManager",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "Merge",
        "ReturnType": "void",
        "Arguments": {
          "building1": "BuildingManager/Building",
          "building2": "BuildingManager/Building"
        }
      },
      "CodeAfterInjection": "private void Merge(global::BuildingManager.Building building1, global::BuildingManager.Building building2)\r\n{\r\n\tInterface.CallHook(\"OnBuildingMerge\", this, building1, building2);\r\n\twhile (building2.HasDecayEntities())\r\n\t{\r\n\t\tbuilding2.decayEntities[0].AttachToBuilding(building1.ID);\r\n\t}\r\n\tif (ConVar.AI.nav_carve_use_building_optimization)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFeedbackReported",
      "HookName": "OnFeedbackReported",
      "HookParameters": {
        "instance": "BasePlayer",
        "text": "string",
        "text2": "string",
        "reportType": "ReportType"
      },
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "OnFeedbackReport",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t\tSubject = text\r\n\t\t};\r\n\t\tfeedback.AppInfo.Image = image;\r\n\t\tFacepunch.Feedback.ServerReport(ConVar.Server.reportsServerEndpoint, this.userID, ConVar.Server.reportsServerEndpointKey, feedback);\r\n\t}\r\n\tInterface.CallHook(\"OnFeedbackReported\", this, text, text2, reportType);\r\n}\r\n\r\n"
    },
    {
      "Type": 1,
      "Name": "OnFeedbackReported [patch]",
      "HookName": "OnFeedbackReported",
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "OnFeedbackReport",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t\tSubject = text\r\n\t\t};\r\n\t\tfeedback.AppInfo.Image = image;\r\n\t\tFacepunch.Feedback.ServerReport(ConVar.Server.reportsServerEndpoint, this.userID, ConVar.Server.reportsServerEndpointKey, feedback);\r\n\t}\r\n\tInterface.CallHook(\"OnFeedbackReported\", this, text, text2, reportType);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPortalUse",
      "HookName": "OnPortalUse",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "BasePortal"
      },
      "ReturnBehavior": 4,
      "TargetType": "BasePortal",
      "Category": "Player",
      "MethodData": {
        "MethodName": "UsePortal",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public virtual void UsePortal(global::BasePlayer player)\r\n{\r\n\tif (Interface.CallHook(\"OnPortalUse\", player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.LinkPortal();\r\n\tif (this.targetPortal != null)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPortalUsed",
      "HookName": "OnPortalUsed",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "BasePortal"
      },
      "ReturnBehavior": 0,
      "TargetType": "BasePortal",
      "Category": "Player",
      "MethodData": {
        "MethodName": "UsePortal",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public virtual void UsePortal(global::BasePlayer player)\r\n{\r\n\tif (Interface.CallHook(\"OnPortalUse\", player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.LinkPortal();\r\n\tif (this.targetPortal != null)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemDespawn",
      "HookName": "OnItemDespawn",
      "HookParameters": {
        "item": "Item"
      },
      "ReturnBehavior": 0,
      "TargetType": "DroppedItem",
      "Category": "Item",
      "MethodData": {
        "MethodName": "IdleDestroy",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void IdleDestroy()\r\n{\r\n\tInterface.CallHook(\"OnItemDespawn\", this.item);\r\n\tFacepunch.Rust.Analytics.Azure.OnItemDespawn(this, this.item, (int)this.DropReason, this.DroppedBy);\r\n\tbase.DestroyItem();\r\n\tbase.Kill(global::BaseNetworkable.DestroyMode.None);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "CanUnlock [ModularCarCodeLock]",
      "HookName": "CanUnlock",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "ModularCarCodeLock",
        "codeEntered": "string"
      },
      "ReturnBehavior": 1,
      "TargetType": "ModularCarCodeLock",
      "Category": "Player",
      "MethodData": {
        "MethodName": "TryOpenWithCode",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer",
          "codeEntered": "string"
        }
      },
      "CodeAfterInjection": "public bool TryOpenWithCode(global::BasePlayer player, string codeEntered)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanUnlock\", player, this, codeEntered);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif (this.CodeEntryBlocked(player))\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnVehicleLockRequest",
      "HookName": "OnVehicleLockRequest",
      "HookParameters": {
        "instance": "ModularCarGarage",
        "player": "BasePlayer",
        "text": "string"
      },
      "ReturnBehavior": 1,
      "TargetType": "ModularCarGarage",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "RPC_RequestAddLock",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (player == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tstring text = msg.read.String(256);\r\n\tif (Interface.CallHook(\"OnVehicleLockRequest\", this, player, text) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::ItemAmount itemAmount = this.lockResourceCost;\r\n\tif ((float)player.inventory.GetAmount(itemAmount.itemDef.itemid) >= itemAmount.amount && this.carOccupant.CarLock.TryAddALock(text, player.userID))\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "CanLootEntity [IndustrialCrafter]",
      "HookName": "CanLootEntity",
      "ReturnBehavior": 0,
      "TargetType": "IndustrialCrafter",
      "Category": "Player",
      "MethodData": {
        "MethodName": "PlayerOpenLoot",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer",
          "panelToOpen": "string",
          "doPositionChecks": "bool"
        }
      },
      "CodeAfterInjection": "public virtual bool PlayerOpenLoot(global::BasePlayer player, string panelToOpen = \"\", bool doPositionChecks = true)\r\n{\r\n\tif (Interface.CallHook(\"CanLootEntity\", player, this) != null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (this.NeedsBuildingPrivilegeToUse && !player.CanBuild())\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnConveyorFiltersChange",
      "HookName": "OnConveyorFiltersChange",
      "HookParameters": {
        "instance": "IndustrialConveyor",
        "player": "BasePlayer",
        "itemFilterList": "ItemFilterList"
      },
      "ReturnBehavior": 4,
      "TargetType": "IndustrialConveyor",
      "Category": "Industrial",
      "MethodData": {
        "MethodName": "RPC_ChangeFilters",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tProtoBuf.IndustrialConveyor.ItemFilterList itemFilterList = ProtoBuf.IndustrialConveyor.ItemFilterList.Deserialize(msg.read);\r\n\tif (itemFilterList.filters == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnConveyorFiltersChange\", this, msg.player, itemFilterList) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tint num = Mathf.Min(itemFilterList.filters.Count, 24);\r\n\tint num2 = 0;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSwitchToggle [IndustrialConveyor]",
      "HookName": "OnSwitchToggle",
      "HookDescription": "Called when a player attempts to switch on or of a Entity",
      "HookParameters": {
        "instance": "IndustrialConveyor",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 4,
      "TargetType": "IndustrialConveyor",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "SvSwitch",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.CallsPerSecond(2uL), global::BaseEntity.RPC_Server.IsVisible(3f)]\r\nprivate void SvSwitch(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tif (Interface.CallHook(\"OnSwitchToggle\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.SetSwitch(!base.IsOn());\r\n\tInterface.CallHook(\"OnSwitchToggled\", this, msg.player);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSwitchToggled [IndustrialConveyor]",
      "HookName": "OnSwitchToggled",
      "HookDescription": "Called right after a player switches on or off an Entity",
      "HookParameters": {
        "instance": "IndustrialConveyor",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "IndustrialConveyor",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "SvSwitch",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.CallsPerSecond(2uL), global::BaseEntity.RPC_Server.IsVisible(3f)]\r\nprivate void SvSwitch(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tif (Interface.CallHook(\"OnSwitchToggle\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.SetSwitch(!base.IsOn());\r\n\tInterface.CallHook(\"OnSwitchToggled\", this, msg.player);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemCraft [IndustrialCrafter]",
      "HookName": "OnItemCraft",
      "HookParameters": {
        "instance": "IndustrialCrafter",
        "blueprint": "ItemBlueprint"
      },
      "ReturnBehavior": 1,
      "TargetType": "IndustrialCrafter",
      "Category": "Industrial",
      "MethodData": {
        "MethodName": "RunJob",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\tglobal::Item targetBlueprint = this.GetTargetBlueprint(i);\r\n\t\tif (targetBlueprint != null && !(this.GetWorkbench() == null) && this.GetWorkbench().Workbenchlevel >= targetBlueprint.blueprintTargetDef.Blueprint.workbenchLevelRequired)\r\n\t\t{\r\n\t\t\tglobal::ItemBlueprint blueprint = targetBlueprint.blueprintTargetDef.Blueprint;\r\n\t\t\tif (Interface.CallHook(\"OnItemCraft\", this, blueprint) != null)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tbool flag = true;\r\n\t\t\tforeach (global::ItemAmount current in blueprint.ingredients)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnVehicleHornPressed",
      "HookName": "OnVehicleHornPressed",
      "HookParameters": {
        "instance": "VehicleModuleSeating",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "VehicleModuleSeating",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "PlayerServerInput",
        "ReturnType": "void",
        "Arguments": {
          "inputState": "InputState",
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t{\r\n\t\t\tbase.SetFlag(global::BaseEntity.Flags.Reserved8, flag, false, true);\r\n\t\t}\r\n\t\tif (flag)\r\n\t\t{\r\n\t\t\tInterface.CallHook(\"OnVehicleHornPressed\", this, player);\r\n\t\t\tthis.hornPlayer = player;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "CanExplosiveStick",
      "HookName": "CanExplosiveStick",
      "HookDescription": "Called when a TimeExplosive attempts to stick to an entity",
      "HookParameters": {
        "instance": "TimedExplosive",
        "entity": "BaseEntity"
      },
      "ReturnBehavior": 1,
      "TargetType": "TimedExplosive",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "CanStickTo",
        "ReturnType": "bool",
        "Arguments": {
          "entity": "BaseEntity"
        }
      },
      "CodeAfterInjection": "public virtual bool CanStickTo(global::BaseEntity entity)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanExplosiveStick\", this, entity);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tglobal::DecorDeployable decorDeployable;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnInventoryAmmoItemFind",
      "HookName": "OnInventoryAmmoItemFind",
      "HookParameters": {
        "inventory": "PlayerInventory",
        "fuelType": "ItemDefinition"
      },
      "ReturnBehavior": 1,
      "TargetType": "Chainsaw",
      "Category": "Item",
      "MethodData": {
        "MethodName": "GetAmmo",
        "ReturnType": "Item",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tglobal::BasePlayer ownerPlayer = base.GetOwnerPlayer();\r\n\tif (!ownerPlayer)\r\n\t{\r\n\t\treturn null;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"OnInventoryAmmoItemFind\", ownerPlayer.inventory, this.fuelType);\r\n\tif (returnvar is global::Item)\r\n\t{\r\n\t\treturn (global::Item)returnvar;\r\n\t}\r\n\tglobal::Item item = ownerPlayer.inventory.containerMain.FindItemsByItemName(this.fuelType.shortname);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnInventoryAmmoItemFind",
      "HookName": "OnInventoryAmmoItemFind",
      "HookParameters": {
        "inventory": "PlayerInventory",
        "fuelType": "ItemDefinition"
      },
      "ReturnBehavior": 1,
      "TargetType": "FlameThrower",
      "Category": "Item",
      "MethodData": {
        "MethodName": "GetAmmo",
        "ReturnType": "Item",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tglobal::BasePlayer ownerPlayer = base.GetOwnerPlayer();\r\n\tif (!ownerPlayer)\r\n\t{\r\n\t\treturn null;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"OnInventoryAmmoItemFind\", ownerPlayer.inventory, this.fuelType);\r\n\tif (returnvar is global::Item)\r\n\t{\r\n\t\treturn (global::Item)returnvar;\r\n\t}\r\n\tglobal::Item item = ownerPlayer.inventory.containerMain.FindItemsByItemName(this.fuelType.shortname);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanSeeStash",
      "HookName": "CanSeeStash",
      "HookDescription": "Called when a player is looking at a hidden stash",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "StashContainer"
      },
      "ReturnBehavior": 1,
      "TargetType": "StashContainer",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "RPC_WantsUnhide",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t\treturn;\r\n\t}\r\n\tglobal::BasePlayer player = rpc.player;\r\n\tif (this.PlayerInRange(player))\r\n\t{\r\n\t\tif (Interface.CallHook(\"CanSeeStash\", player, this) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tFacepunch.Rust.Analytics.Azure.OnStashRevealed(rpc.player, this);\r\n\t\tthis.SetHidden(false);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnStashExposed",
      "HookName": "OnStashExposed",
      "HookDescription": "Called when a player reveals a hidden stash",
      "HookParameters": {
        "instance": "StashContainer",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "StashContainer",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "RPC_WantsUnhide",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t\treturn;\r\n\t}\r\n\tglobal::BasePlayer player = rpc.player;\r\n\tif (this.PlayerInRange(player))\r\n\t{\r\n\t\tif (Interface.CallHook(\"CanSeeStash\", player, this) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tFacepunch.Rust.Analytics.Azure.OnStashRevealed(rpc.player, this);\r\n\t\tthis.SetHidden(false);\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnStashExposed [patch]",
      "HookName": "OnStashExposed [patch]",
      "ReturnBehavior": 0,
      "TargetType": "StashContainer",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "RPC_WantsUnhide",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t\treturn;\r\n\t}\r\n\tglobal::BasePlayer player = rpc.player;\r\n\tif (this.PlayerInRange(player))\r\n\t{\r\n\t\tif (Interface.CallHook(\"CanSeeStash\", player, this) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tFacepunch.Rust.Analytics.Azure.OnStashRevealed(rpc.player, this);\r\n\t\tthis.SetHidden(false);\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnBonusItemDropped [patch 1]",
      "HookName": "OnBonusItemDropped [patch 1]",
      "ReturnBehavior": 0,
      "TargetType": "LootContainer",
      "Category": "Item",
      "MethodData": {
        "MethodName": "DropBonusItems",
        "ReturnType": "void",
        "Arguments": {
          "initiator": "BaseEntity",
          "container": "ItemContainer"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t\tif (num4 > 0)\r\n\t\t\t{\r\n\t\t\t\tglobal::Item item = global::ItemManager.Create(global::LootContainer.scrapDef, num4, 0uL);\r\n\t\t\t\tif (item != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (Interface.CallHook(\"OnBonusItemDrop\", item, basePlayer) != null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t(item.Drop(this.GetDropPosition() + new Vector3(0f, 0.5f, 0f), this.GetInheritedDropVelocity(), default(Quaternion)) as global::DroppedItem).DropReason = global::DroppedItem.DropReasonEnum.Loot;\r\n\t\t\t\t\tInterface.CallHook(\"OnBonusItemDropped\", item, basePlayer);\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnBonusItemDropped [patch 2]",
      "HookName": "OnBonusItemDropped [patch 2]",
      "ReturnBehavior": 0,
      "TargetType": "LootContainer",
      "Category": "Item",
      "MethodData": {
        "MethodName": "DropBonusItems",
        "ReturnType": "void",
        "Arguments": {
          "initiator": "BaseEntity",
          "container": "ItemContainer"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t\tif (num4 > 0)\r\n\t\t\t{\r\n\t\t\t\tglobal::Item item = global::ItemManager.Create(global::LootContainer.scrapDef, num4, 0uL);\r\n\t\t\t\tif (item != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (Interface.CallHook(\"OnBonusItemDrop\", item, basePlayer) != null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t(item.Drop(this.GetDropPosition() + new Vector3(0f, 0.5f, 0f), this.GetInheritedDropVelocity(), default(Quaternion)) as global::DroppedItem).DropReason = global::DroppedItem.DropReasonEnum.Loot;\r\n\t\t\t\t\tInterface.CallHook(\"OnBonusItemDropped\", item, basePlayer);\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnBonusItemDropped [patch 3]",
      "HookName": "OnBonusItemDropped [patch 3]",
      "ReturnBehavior": 0,
      "TargetType": "LootContainer",
      "Category": "Item",
      "MethodData": {
        "MethodName": "DropBonusItems",
        "ReturnType": "void",
        "Arguments": {
          "initiator": "BaseEntity",
          "container": "ItemContainer"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t\tif (num4 > 0)\r\n\t\t\t{\r\n\t\t\t\tglobal::Item item = global::ItemManager.Create(global::LootContainer.scrapDef, num4, 0uL);\r\n\t\t\t\tif (item != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (Interface.CallHook(\"OnBonusItemDrop\", item, basePlayer) != null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t(item.Drop(this.GetDropPosition() + new Vector3(0f, 0.5f, 0f), this.GetInheritedDropVelocity(), default(Quaternion)) as global::DroppedItem).DropReason = global::DroppedItem.DropReasonEnum.Loot;\r\n\t\t\t\t\tInterface.CallHook(\"OnBonusItemDropped\", item, basePlayer);\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnBonusItemDropped [patch 4]",
      "HookName": "OnBonusItemDropped [patch 4]",
      "ReturnBehavior": 0,
      "TargetType": "LootContainer",
      "Category": "Item",
      "MethodData": {
        "MethodName": "DropBonusItems",
        "ReturnType": "void",
        "Arguments": {
          "initiator": "BaseEntity",
          "container": "ItemContainer"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t\tif (num4 > 0)\r\n\t\t\t{\r\n\t\t\t\tglobal::Item item = global::ItemManager.Create(global::LootContainer.scrapDef, num4, 0uL);\r\n\t\t\t\tif (item != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (Interface.CallHook(\"OnBonusItemDrop\", item, basePlayer) != null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t(item.Drop(this.GetDropPosition() + new Vector3(0f, 0.5f, 0f), this.GetInheritedDropVelocity(), default(Quaternion)) as global::DroppedItem).DropReason = global::DroppedItem.DropReasonEnum.Loot;\r\n\t\t\t\t\tInterface.CallHook(\"OnBonusItemDropped\", item, basePlayer);\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnBonusItemDropped [patch 5]",
      "HookName": "OnBonusItemDropped [patch 5]",
      "ReturnBehavior": 0,
      "TargetType": "LootContainer",
      "Category": "Item",
      "MethodData": {
        "MethodName": "DropBonusItems",
        "ReturnType": "void",
        "Arguments": {
          "initiator": "BaseEntity",
          "container": "ItemContainer"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t\tif (num4 > 0)\r\n\t\t\t{\r\n\t\t\t\tglobal::Item item = global::ItemManager.Create(global::LootContainer.scrapDef, num4, 0uL);\r\n\t\t\t\tif (item != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (Interface.CallHook(\"OnBonusItemDrop\", item, basePlayer) != null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t(item.Drop(this.GetDropPosition() + new Vector3(0f, 0.5f, 0f), this.GetInheritedDropVelocity(), default(Quaternion)) as global::DroppedItem).DropReason = global::DroppedItem.DropReasonEnum.Loot;\r\n\t\t\t\t\tInterface.CallHook(\"OnBonusItemDropped\", item, basePlayer);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "IOnServerCommand",
      "HookName": "IOnServerCommand",
      "HookParameters": {
        "arg": "Arg"
      },
      "ReturnBehavior": 1,
      "TargetType": "ConsoleSystem",
      "Category": "Server",
      "MethodData": {
        "MethodName": "Internal",
        "ReturnType": "bool",
        "Arguments": {
          "arg": "ConsoleSystem/Arg"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (arg.Invalid)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"IOnServerCommand\", arg);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif (!arg.HasPermission())\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "SingleCharCmdPrefix [patch]",
      "HookName": "SingleCharCmdPrefix [patch]",
      "ReturnBehavior": 0,
      "TargetType": "ConsoleSystem/Arg",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "BuildCommand",
        "ReturnType": "void",
        "Arguments": {
          "command": "string"
        }
      }
    },
    {
      "Type": 0,
      "Name": "IOnRunCommandLine",
      "HookName": "IOnRunCommandLine",
      "HookParameters": {},
      "ReturnBehavior": 1,
      "TargetType": "ConsoleSystem",
      "Category": "Server",
      "MethodData": {
        "MethodName": "UpdateValuesFromCommandLine",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public static void UpdateValuesFromCommandLine()\r\n{\r\n\tif (Interface.CallHook(\"IOnRunCommandLine\") != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tforeach (KeyValuePair<string, string> current in Facepunch.CommandLine.GetSwitches())\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "SingleCharCmdSuffix [patch]",
      "HookName": "SingleCharCmdSuffix [patch]",
      "ReturnBehavior": 0,
      "TargetType": "ConsoleSystem/Arg",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "BuildCommand",
        "ReturnType": "void",
        "Arguments": {
          "command": "string"
        }
      }
    },
    {
      "Type": 0,
      "Name": "OnRconConnection [web]",
      "HookName": "OnRconConnection",
      "HookParameters": {
        "ClientIpAddress": "IPAddress"
      },
      "ReturnBehavior": 1,
      "TargetType": "Facepunch.Rcon.Listener/<>c__DisplayClass10_0",
      "Category": "Server",
      "MethodData": {
        "MethodName": "<Start>b__0",
        "ReturnType": "void",
        "Arguments": {
          "socket": "Fleck.IWebSocketConnection"
        }
      },
      "CodeAfterInjection": "internal void <Start>b__0(IWebSocketConnection socket)\r\n{\r\n\tListener.<>c__DisplayClass10_1 <>c__DisplayClass10_ = new Listener.<>c__DisplayClass10_1();\r\n\t<>c__DisplayClass10_.CS$<>8__locals1 = this;\r\n\t<>c__DisplayClass10_.socket = socket;\r\n\tif (Interface.CallHook(\"OnRconConnection\", socket.ConnectionInfo.ClientIpAddress) != null || <>c__DisplayClass10_.socket.ConnectionInfo.Path != this.requiredPath)\r\n\t{\r\n\t\t<>c__DisplayClass10_.socket.Close();\r\n\t\treturn;\r\n\t}\r\n\t<>c__DisplayClass10_.id = Interlocked.Increment(ref this.<>4__this.nextClientId);\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnRconConnection [web, patch]",
      "HookName": "OnRconConnection [web, patch]",
      "ReturnBehavior": 0,
      "TargetType": "Facepunch.Rcon.Listener/<>c__DisplayClass10_0",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "<Start>b__0",
        "ReturnType": "void",
        "Arguments": {
          "socket": "Fleck.IWebSocketConnection"
        }
      },
      "CodeAfterInjection": "internal void <Start>b__0(IWebSocketConnection socket)\r\n{\r\n\tListener.<>c__DisplayClass10_1 <>c__DisplayClass10_ = new Listener.<>c__DisplayClass10_1();\r\n\t<>c__DisplayClass10_.CS$<>8__locals1 = this;\r\n\t<>c__DisplayClass10_.socket = socket;\r\n\tif (Interface.CallHook(\"OnRconConnection\", socket.ConnectionInfo.ClientIpAddress) != null || <>c__DisplayClass10_.socket.ConnectionInfo.Path != this.requiredPath)\r\n\t{\r\n\t\t<>c__DisplayClass10_.socket.Close();\r\n\t\treturn;\r\n\t}\r\n\t<>c__DisplayClass10_.id = Interlocked.Increment(ref this.<>4__this.nextClientId);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "IOnRconMessage",
      "HookName": "IOnRconMessage",
      "HookParameters": {
        "ClientIpAddress": "IPAddress",
        "s": "string"
      },
      "ReturnBehavior": 1,
      "TargetType": "Facepunch.Rcon.Listener/<>c__DisplayClass10_1",
      "Category": "Server",
      "MethodData": {
        "MethodName": "<Start>b__3",
        "ReturnType": "void",
        "Arguments": {
          "s": "string"
        }
      },
      "CodeAfterInjection": "internal void <Start>b__3(string s)\r\n{\r\n\tif (Interface.CallHook(\"IOnRconMessage\", this.socket.ConnectionInfo.ClientIpAddress, s) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tAction<IPAddress, int, string> expr_2F = this.CS$<>8__locals1.<>4__this.OnMessage;\r\n\tif (expr_2F == null)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnClientDisconnected",
      "HookName": "OnClientDisconnected",
      "HookParameters": {
        "cn": "Connection",
        "strReason": "string"
      },
      "ReturnBehavior": 0,
      "TargetType": "Network.Server",
      "Category": "Player",
      "MethodData": {
        "MethodName": "OnDisconnected",
        "ReturnType": "void",
        "Arguments": {
          "strReason": "string",
          "cn": "Network.Connection"
        }
      },
      "CodeAfterInjection": "...\r\n\tcn.active = false;\r\n\tif (this.callbackHandler != null)\r\n\t{\r\n\t\tthis.callbackHandler.OnDisconnected(strReason, cn);\r\n\t}\r\n\tInterface.CallHook(\"OnClientDisconnected\", cn, strReason);\r\n\tthis.RemoveConnection(cn);\r\n}\r\n\r\n"
    },
    {
      "Type": 1,
      "Name": "OnNetworkSubscriptionsUpdate",
      "HookName": "OnNetworkSubscriptionsUpdate",
      "ReturnBehavior": 0,
      "TargetType": "Network.Networkable",
      "Category": "Network",
      "MethodData": {
        "MethodName": "UpdateSubscriptions",
        "ReturnType": "bool",
        "Arguments": {
          "removeLimit": "int",
          "addLimit": "int"
        }
      },
      "CodeAfterInjection": "...\r\n\t\tList<Group> list2 = Pool.GetList<Group>();\r\n\t\tList<Group> list3 = Pool.GetList<Group>();\r\n\t\tthis.sv.visibility.GetVisibleFromFar(this.group, list3);\r\n\t\tthis.AddVisibleFromNear(this.secondaryGroup, list3);\r\n\t\tthis.subscriber.subscribed.Compare(list3, list, list2, null);\r\n\t\tif (Interface.CallHook(\"OnNetworkSubscriptionsUpdate\", this, list, list2) == null)\r\n\t\t{\r\n\t\t\tfor (int i = 0; i < list2.Count; i++)\r\n\t\t\t{\r\n\t\t\t\tGroup group = list2[i];\r\n\t\t\t\tif (removeLimit > 0)\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnNetworkSubscriptionsUpdate [2]",
      "HookName": "OnNetworkSubscriptionsUpdate",
      "ReturnBehavior": 0,
      "TargetType": "Network.Networkable",
      "Category": "Network",
      "MethodData": {
        "MethodName": "UpdateHighPrioritySubscriptions",
        "ReturnType": "bool",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\tList<Group> list = Pool.GetList<Group>();\r\n\t\tList<Group> list2 = Pool.GetList<Group>();\r\n\t\tthis.sv.visibility.GetVisibleFromNear(this.group, list2);\r\n\t\tthis.AddVisibleFromNear(this.secondaryGroup, list2);\r\n\t\tthis.subscriber.subscribed.Compare(list2, list, null, null);\r\n\t\tif (Interface.CallHook(\"OnNetworkSubscriptionsUpdate\", this, list, null) == null)\r\n\t\t{\r\n\t\t\tfor (int i = 0; i < list.Count; i++)\r\n\t\t\t{\r\n\t\t\t\tGroup group = list[i];\r\n\t\t\t\tthis.subscriber.Subscribe(group);\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "NoPragmaColumnExists [patch]",
      "HookName": "NoPragmaColumnExists",
      "ReturnBehavior": 0,
      "TargetType": "Facepunch.Sqlite.Database",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "ColumnExists",
        "ReturnType": "bool",
        "Arguments": {
          "tableName": "string",
          "columnName": "string"
        }
      }
    },
    {
      "Type": 1,
      "Name": "LogSqliteVersion [patch]",
      "HookName": "LogSqliteVersion",
      "ReturnBehavior": 0,
      "TargetType": "Facepunch.Sqlite.Database",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "Open",
        "ReturnType": "void",
        "Arguments": {
          "path": "string",
          "fastMode": "bool"
        }
      }
    }
  ]
}